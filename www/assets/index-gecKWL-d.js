(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$2 = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
function A$1(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$1 && a2[z$1] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$1.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$2 = G$1.prototype = new F();
H$2.constructor = G$1;
C$1(H$2, E$1.prototype);
H$2.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g = arguments.length - 2;
  if (1 === g)
    c2.children = e2;
  else if (1 < g) {
    for (var f2 = Array(g), m2 = 0; m2 < g; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g = a2.defaultProps, g)
      void 0 === c2[d2] && (c2[d2] = g[d2]);
  return { $$typeof: l$1, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a2, b2) {
  return { $$typeof: l$1, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$1;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$1(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$1:
          case n$1:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a2))
    for (var g = 0; g < a2.length; g++) {
      k2 = a2[g];
      var f2 = d2 + Q$1(k2, g);
      h2 += R$1(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$1(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$1(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$1(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$1, forEach: function(a2, b2, e2) {
  S$1(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$1(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$1(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$1(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$2;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g = a2.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g ? g[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g[m2] = arguments[m2 + 2];
    d2.children = g;
  }
  return { $$typeof: l$1, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$1, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a2) {
  var b2 = M$1.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$2, render: a2 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a2 }, _init: T$1 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a2();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$1.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$1.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$1.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$1.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$1.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$1.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$1.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$1.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$1.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$1.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$1.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$1.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g(C2, c2))
            n2 < e2 && 0 > g(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$1(a2, b2, c2, d2, e2, f2, g) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z[a2] = new v$1(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z[b2] = new v$1(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z[a2] = new v$1(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z[a2] = new v$1(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z[a2] = new v$1(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z[a2] = new v$1(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z[a2] = new v$1(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z[a2] = new v$1(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z[a2] = new v$1(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z[b2] = new v$1(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z[b2] = new v$1(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z[b2] = new v$1(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z[a2] = new v$1(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z[a2] = new v$1(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z.hasOwnProperty(b2) ? z[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g = e2.length - 1, h2 = f2.length - 1; 1 <= g && 0 <= h2 && e2[g] !== f2[h2]; )
        h2--;
      for (; 1 <= g && 0 <= h2; g--, h2--)
        if (e2[g] !== f2[h2]) {
          if (1 !== g || 1 !== h2) {
            do
              if (g--, h2--, 0 > h2 || e2[g] !== f2[h2]) {
                var k2 = "\n" + e2[g].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$1(91));
  return A({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$1(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$1(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$1(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$1(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$1(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$1(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g)
          throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$1(190));
  }
  if (3 !== c2.tag)
    throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g = c2 & 268435455;
  if (0 !== g) {
    var h2 = g & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g, 0 !== f2 && (d2 = tc(f2)));
  } else
    g = c2 & ~e2, 0 !== g ? d2 = tc(g) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g = 31 - oc(f2), h2 = 1 << g, k2 = e2[g];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g = c2 - a2;
  for (d2 = 1; d2 <= g && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2))
    return a2;
}
function ve(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    Jb(re, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g = Ke(
          c2,
          d2
        );
        e2 && g && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g.node || a2.focusOffset !== g.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g.node, g.offset)) : (b2.setEnd(g.node, g.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We[a2])
    return a2;
  var b2 = We[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g = d2.length - 1; 0 <= g; g--) {
          var h2 = d2[g], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g = 0; g < d2.length; g++) {
          h2 = d2[g];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g = d2.tag;
        if (3 === g || 4 === g) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g)
            for (g = d2.return; null !== g; ) {
              var k2 = g.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g = g.return;
            }
          for (; null !== h2; ) {
            g = Wc(h2);
            if (null === g)
              return;
            k2 = g.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g2 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g2.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g2, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g2, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g2, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g2.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g2, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g.length && a2.push({ event: b2, listeners: g });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$1(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$1 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E(Wf);
  E(H$1);
}
function ag(a2, b2, c2) {
  if (H$1.current !== Vf)
    throw Error(p$1(168));
  G(H$1, b2);
  G(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$1(108, Ra(a2) || "Unknown", e2));
  return A({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$1.current;
  G(H$1, a2);
  G(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$1(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H$1), G(H$1, a2)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g = e2 - e2 % 5;
    f2 = (d2 & (1 << g) - 1).toString(32);
    d2 >>= g;
    e2 -= g;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$1(418));
      a2.flags = a2.flags & -4097 | 2;
      I = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I)
    return Fg(a2), I = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$1(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$1(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$1(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g : f2 = f2.next = g;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g ? f2 = l2 : g.next = l2;
    g = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g;
    a2.lanes = g;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$1(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$1.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$1(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$1(284));
    if (!c2._owner)
      throw Error(p$1(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g2, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g2 = f2(n3, g2, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g2 = f2(x2, g2, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g2, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g2 = f2(t3, g2, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$1(174));
  return a2;
}
function Ih(a2, b2) {
  G(Gh, b2);
  G(Fh, a2);
  G(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E(Eh);
  G(Eh, b2);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G(Fh, a2), G(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p$1(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$1(301));
      f2 += 1;
      P$1 = O = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O && null !== O.next;
  Rh = 0;
  P$1 = O = N = null;
  Sh = false;
  if (b2)
    throw Error(p$1(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di() {
  if (null === O) {
    var a2 = N.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O.next;
  var b2 = null === P$1 ? N.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O = a2;
  else {
    if (null === a2)
      throw Error(p$1(310));
    O = a2;
    a2 = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P$1 ? N.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a2;
  var d2 = O, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g = e2.next;
      e2.next = f2.next;
      f2.next = g;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g = d2) : k2 = k2.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g = e2 = e2.next;
    do
      f2 = a2(f2, g.action), g = g.next;
    while (g !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O) {
    var g = O.memoizedState;
    f2 = g.destroy;
    if (null !== d2 && Wh(d2, g.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g = b2.lastRenderedState, h2 = f2(g, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N || null !== b2 && b2 === N;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N, e2 = ci();
  if (I) {
    if (void 0 === c2)
      throw Error(p$1(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O ? b2.memoizedState = a2 : Di(b2, O.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$1.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g = b2.stateNode, h2 = b2.memoizedProps;
    g.props = h2;
    var k2 = g.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$1.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g.state = r2;
    gh(b2, d2, g, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g.props = d2, g.state = k2, g.context = l2, d2 = h2) : ("function" === typeof g.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g.props = l2;
    q2 = b2.pendingProps;
    r2 = g.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$1.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g.state = r2;
    gh(b2, d2, g, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d2, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g.componentDidUpdate && (b2.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g.props = d2, g.state = n2, g.context = k2, d2 = l2) : ("function" !== typeof g.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g = 0 !== (b2.flags & 128);
  if (!d2 && !g)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M.current, f2 = false, g = 0 !== (b2.flags & 128), h2;
  (h2 = g) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G(M, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g = { mode: "hidden", children: g }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = qj(g, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g = a2.child.memoizedState;
    g = null === g ? oj(c2) : { baseLanes: g.baseLanes | c2, cachePool: null, transitions: g.transitions };
    f2.memoizedState = g;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$1(422))), tj(a2, b2, g, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g);
    b2.child.memoizedState = oj(g);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$1(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g, d2);
  }
  h2 = 0 !== (g & a2.childLanes);
  if (Ug || h2) {
    d2 = R;
    if (null !== d2) {
      switch (g & -g) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$1(421)));
    return tj(a2, b2, g, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G(M, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$1(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G(M, M.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G(M, M.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(M, M.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A({}, e2, { value: void 0 });
        d2 = A({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g in h2)
            h2.hasOwnProperty(g) && (c2 || (c2 = {}), c2[g] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g in h2)
              !h2.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c2 || (c2 = {}), c2[g] = "");
            for (g in k2)
              k2.hasOwnProperty(g) && h2[g] !== k2[g] && (c2 || (c2 = {}), c2[g] = k2[g]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E(Wf);
      E(H$1);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$1(166));
          S(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g in f2)
            if (f2.hasOwnProperty(g)) {
              var h2 = f2[g];
              "children" === g ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g.createElement(c2, { is: d2.is }) : (a2 = g.createElement(c2), "select" === c2 && (g = a2, d2.multiple ? g.multiple = true : d2.size && (g.size = d2.size))) : a2 = g.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a2);
                D("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a2
                );
                D("load", a2);
                e2 = d2;
                break;
              case "details":
                D("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A({}, d2, { value: void 0 });
                D("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta(a2, f2, k2, g));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$1(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(M);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$1(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return Rg(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(M);
      f2 = b2.memoizedState;
      if (null === f2)
        return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g = f2.rendering;
      if (null === g)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g = Mh(a2);
              if (null !== g) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a2 = g.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G(M, M.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I)
              return S(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g.sibling = b2.child, b2.child = g) : (c2 = f2.last, null !== c2 ? c2.sibling = g : b2.child = g, f2.last = g);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E(Wf), E(H$1), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E(M);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$1(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g + d2);
                3 === q2.nodeType && (g += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g);
                r2 === f2 && ++m2 === d2 && (k2 = g);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V = a2;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$1(163));
            }
        } catch (F2) {
          W(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V = a2;
          break;
        }
        V = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U || Mj(c2, b2);
    case 6:
      var d2 = X, e2 = Yj;
      X = null;
      Zj(a2, b2, c2);
      X = d2;
      Yj = e2;
      null !== X && (Yj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Yj;
      X = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g = f2.destroy;
          f2 = f2.tag;
          void 0 !== g && (0 !== (f2 & 2) ? Nj(c2, b2, g) : 0 !== (f2 & 4) && Nj(c2, b2, g));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a2, b2, c2), U = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g = b2, h2 = g;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$1(160));
        ak(f2, g, e2);
        X = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g);
            var l2 = vb(h2, f2);
            for (g = 0; g < k2.length; g += 2) {
              var m2 = k2[g], q2 = k2[g + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$1(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a2), U = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g = null !== e2.memoizedState || Kj;
      if (!g) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Kj;
        var l2 = U;
        Kj = g;
        if ((U = k2) && !l2)
          for (V = e2; null !== V; )
            g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g, V = k2) : kk(e2);
        for (; null !== f2; )
          V = f2, jk(f2), f2 = f2.sibling;
        V = e2;
        Kj = h2;
        U = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g = b2.updateQueue;
              if (null !== g) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$1(163));
          }
        U || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function hk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a2) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function kk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W(b2, g, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$1(185));
  Ac(a2, c2, d2);
  if (0 === (K & 2) || a2 !== R)
    a2 === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a2, Z)), Ek(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R ? Z : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6))
    throw Error(p$1(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Kk();
    if (R !== a2 || Z !== b2)
      vk = null, Hj = B() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g = 31 - oc(d2);
            f2 = 1 << g;
            g = b2[g];
            g > e2 && (e2 = g);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Ek(a2, B());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K & 6))
    throw Error(p$1(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B()), c2;
  if (6 === c2)
    throw Error(p$1(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B());
  return null;
}
function Rk(a2, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a2(b2);
  } finally {
    K = c2, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b2 = K;
  K |= 1;
  var c2 = pk.transition, d2 = C;
  try {
    if (pk.transition = null, C = 1, a2)
      return a2();
  } finally {
    C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E(Wf);
          E(H$1);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E(M);
          break;
        case 19:
          E(M);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R = a2;
  Y = a2 = wh(a2.current, null);
  Z = gj = b2;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g = f2.next;
          f2.next = e2;
          d2.next = g;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O = N = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        qk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Vi(g);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T && (T = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a2, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Kk();
  if (R !== a2 || Z !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K = c2;
  nk.current = d2;
  if (null !== Y)
    throw Error(p$1(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C, e2 = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6))
    throw Error(p$1(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$1(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R && (Y = R = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g = C;
    C = 1;
    var h2 = K;
    K |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K = h2;
    C = g;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C;
    try {
      pk.transition = null;
      C = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6))
          throw Error(p$1(331));
        var e2 = K;
        K |= 4;
        for (V = a2.current; null !== V; ) {
          var f2 = V, g = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g)
            g.return = f2, V = g;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a2.current;
        for (V = w2; null !== V; ) {
          g = V;
          var u2 = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u2)
            u2.return = g, V = u2;
          else
            b:
              for (g = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$1.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$1(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$1(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g = b2.memoizedState;
        d2 = g.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$1(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$1(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g = e2.children, Ef(d2, e2) ? g = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g = e2.value;
        G(Mg, d2._currentValue);
        d2._currentValue = g;
        if (null !== f2)
          if (He(f2.value, g)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g = f2.return;
                if (null === g)
                  throw Error(p$1(341));
                g.lanes |= c2;
                h2 = g.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g, c2, b2);
                g = f2.sibling;
              } else
                g = f2.child;
              if (null !== g)
                g.return = f2;
              else
                for (g = f2; null !== g; ) {
                  if (g === b2) {
                    g = null;
                    break;
                  }
                  f2 = g.sibling;
                  if (null !== f2) {
                    f2.return = g.return;
                    g = f2;
                    break;
                  }
                  g = g.return;
                }
              f2 = g;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$1(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g = 1);
  else if ("string" === typeof a2)
    g = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d2 = null;
                break a;
            }
          throw Error(p$1(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$1(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L(), g = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g);
  null !== a2 && (mh(a2, e2, g, f2), eh(a2, e2, g));
  return g;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$1(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g);
        f2.call(a3);
      };
    }
    var g = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g;
    a2[uf] = g.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g);
        h2.call(a3);
      };
    }
    gl(b2, g, a2, e2);
  } else
    g = rl(c2, b2, a2, e2, d2);
  return hl(g);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a2, b2) {
  var c2 = C;
  try {
    return C = a2, b2();
  } finally {
    C = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$1(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$1(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$1(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$1(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$1(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$1(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$1(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$1(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$1(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$1(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$1(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$1 = reactDomExports;
{
  client.createRoot = m$1.createRoot;
  client.hydrateRoot = m$1.hydrateRoot;
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    promise = Promise.all(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i = links.length - 1; i >= 0; i--) {
          const link2 = links[i];
          if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    }));
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
const BUILD = {
  allRenderFn: false,
  cmpDidLoad: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpDidRender: true,
  cmpWillLoad: true,
  cmpWillUpdate: true,
  cmpWillRender: true,
  connectedCallback: true,
  disconnectedCallback: true,
  element: true,
  event: true,
  hasRenderFn: true,
  lifecycle: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  formAssociated: false,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  scriptDataOpts: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: false,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: false,
  invisiblePrehydration: true,
  propBoolean: true,
  propNumber: true,
  propString: true,
  constructableCSS: true,
  cmpShouldUpdate: true,
  devTools: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: false,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: false
};
let scopeId;
let contentRef;
let hostTagName;
let useNativeShadowDom = false;
let checkSlotFallbackVisibility = false;
let checkSlotRelocate = false;
let isSvgMode = false;
let renderingRef = null;
let queuePending = false;
const Build = {
  isDev: false,
  isBrowser: true,
  isServer: false,
  isTesting: false
};
const getAssetPath = (path2) => {
  const assetUrl = new URL(path2, plt.$resourcesUrl$);
  return assetUrl.origin !== win$2.location.origin ? assetUrl.href : assetUrl.pathname;
};
const createTime = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
const SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
const XLINK_NS = "http://www.w3.org/1999/xlink";
const EMPTY_OBJ = {};
const SVG_NS = "http://www.w3.org/2000/svg";
const HTML_NS = "http://www.w3.org/1999/xhtml";
const isDef = (v2) => v2 != null;
const isComplexType = (o2) => {
  o2 = typeof o2;
  return o2 === "object" || o2 === "function";
};
function queryNonceMetaTagContent(doc2) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc2.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
const h$1 = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = (c2) => {
    for (let i = 0; i < c2.length; i++) {
      child = c2[i];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (vnodeData.key) {
      key = vnodeData.key;
    }
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k2) => classData[k2]).join(" ");
      }
    }
  }
  if (typeof nodeName === "function") {
    return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$key$ = key;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
const newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$key$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
const Host = {};
const isHost = (node) => node && node.$tag$ === Host;
const vdomFnUtils = {
  forEach: (children, cb2) => children.map(convertToPublic).forEach(cb2),
  map: (children, cb2) => children.map(convertToPublic).map(cb2).map(convertToPrivate)
};
const convertToPublic = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
const convertToPrivate = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = Object.assign({}, node.vattrs);
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h$1(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
const computeMode = (elm) => modeResolutionChain.map((h2) => h2(elm)).find((m2) => !!m2);
const setMode = (handler) => modeResolutionChain.push(handler);
const getMode = (ref) => getHostRef(ref).$modeName$;
const parsePropertyValue = (propValue, propType) => {
  if (propValue != null && !isComplexType(propValue)) {
    if (propType & 4) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (propType & 2) {
      return parseFloat(propValue);
    }
    if (propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
const getElement = (ref) => ref;
const createEvent = (ref, name, flags) => {
  const elm = getElement(ref);
  return {
    emit: (detail) => {
      return emitEvent(elm, name, {
        bubbles: !!(flags & 4),
        composed: !!(flags & 2),
        cancelable: !!(flags & 1),
        detail
      });
    }
  };
};
const emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
const rootAppliedStyles = /* @__PURE__ */ new WeakMap();
const registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  if (supportsConstructableStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode) => {
  var _a;
  const scopeId2 = getScopeId(cmpMeta, mode);
  const style = styles.get(scopeId2);
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc$1;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        {
          styleElm = doc$1.createElement("style");
          styleElm.innerHTML = style;
          const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc$1);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
        }
        if (cmpMeta.$flags$ & 4) {
          styleElm.innerHTML += SLOT_FB_CSS;
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
const attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);
  if (flags & 10) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
    if (flags & 2) {
      elm.classList.add(scopeId2 + "-s");
    }
  }
  endAttachStyles();
};
const getScopeId = (cmp, mode) => "sc-" + (mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement(elm, memberName);
    let ln = memberName.toLowerCase();
    if (memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList(oldValue);
      const newClasses = parseClassList(newValue);
      classList.remove(...oldClasses.filter((c2) => c2 && !newClasses.includes(c2)));
      classList.add(...newClasses.filter((c2) => c2 && !oldClasses.includes(c2)));
    } else if (memberName === "style") {
      {
        for (const prop in oldValue) {
          if (!newValue || newValue[prop] == null) {
            if (prop.includes("-")) {
              elm.style.removeProperty(prop);
            } else {
              elm.style[prop] = "";
            }
          }
        }
      }
      for (const prop in newValue) {
        if (!oldValue || newValue[prop] !== oldValue[prop]) {
          if (prop.includes("-")) {
            elm.style.setProperty(prop, newValue[prop]);
          } else {
            elm.style[prop] = newValue[prop];
          }
        }
      }
    } else if (memberName === "key")
      ;
    else if (memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if (!elm.__lookupSetter__(memberName) && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement(win$2, ln)) {
        memberName = ln.slice(2);
      } else {
        memberName = ln[2] + memberName.slice(3);
      }
      if (oldValue || newValue) {
        const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
        memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
        if (oldValue) {
          plt.rel(elm, memberName, oldValue, capture);
        }
        if (newValue) {
          plt.ael(elm, memberName, newValue, capture);
        }
      }
    } else {
      const isComplex = isComplexType(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            const n2 = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n2) {
              elm[memberName] = n2;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e2) {
        }
      }
      let xlink = false;
      {
        if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
          memberName = ln;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          if (xlink) {
            elm.removeAttributeNS(XLINK_NS, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags & 4 || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        if (xlink) {
          elm.setAttributeNS(XLINK_NS, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
const CAPTURE_EVENT_SUFFIX = "Capture";
const CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");
const updateElement = (oldVnode, newVnode, isSvgMode2, memberName) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
  {
    for (memberName in oldVnodeAttrs) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (memberName in newVnodeAttrs) {
    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId) {
        parentElm.classList.add(scopeId + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        2
      ) : (
        // slot element does not have fallback content
        1
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc$1.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = doc$1.createTextNode("");
  } else {
    if (!isSvgMode) {
      isSvgMode = newVNode2.$tag$ === "svg";
    }
    elm = newVNode2.$elm$ = doc$1.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
    if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
      isSvgMode = false;
    }
    {
      updateElement(null, newVNode2, isSvgMode);
    }
    if (isDef(scopeId) && elm["s-si"] !== scopeId) {
      elm.classList.add(elm["s-si"] = scopeId);
    }
    if (newVNode2.$children$) {
      for (i = 0; i < newVNode2.$children$.length; ++i) {
        childNode = createElm(oldParentVNode, newVNode2, i, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode = true;
      }
    }
  }
  elm["s-hn"] = hostTagName;
  {
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        {
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
    }
  }
  return elm;
};
const putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1;
  const oldSlotChildNodes = parentElm.childNodes;
  for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
    const childNode = oldSlotChildNodes[i];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      childNode["s-sh"] = void 0;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= ~1;
};
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        containerElm.insertBefore(childNode, referenceNode(before));
      }
    }
  }
};
const removeVnodes = (vnodes, startIdx, endIdx) => {
  for (let index = startIdx; index <= endIdx; ++index) {
    const vnode = vnodes[index];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs(vnode);
      if (elm) {
        {
          checkSlotFallbackVisibility = true;
          if (elm["s-ol"]) {
            elm["s-ol"].remove();
          } else {
            putBackInOriginalLocation(elm, true);
          }
        }
        elm.remove();
      }
    }
  }
};
const updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
      patch(oldStartVnode, newStartVnode, isInitialRender);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
      patch(oldEndVnode, newEndVnode, isInitialRender);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode, isInitialRender);
      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode, isInitialRender);
      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i = oldStartIdx; i <= oldEndIdx; ++i) {
          if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
            idxInOld = i;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
        } else {
          patch(elmToMove, newStartVnode, isInitialRender);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
const isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    if (!isInitialRender) {
      return leftVNode.$key$ === rightVNode.$key$;
    }
    return true;
  }
  return false;
};
const referenceNode = (node) => {
  return node && node["s-ol"] || node;
};
const parentReferenceNode = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
const patch = (oldVNode, newVNode2, isInitialRender = false) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
    }
    {
      if (tag === "slot" && !useNativeShadowDom)
        ;
      else {
        updateElement(oldVNode, newVNode2, isSvgMode);
      }
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (oldChildren !== null) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
    if (isSvgMode && tag === "svg") {
      isSvgMode = false;
    }
  } else if (defaultHolder = elm["s-cr"]) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
const updateFallbackSlotVisibility = (elm) => {
  const childNodes = elm.childNodes;
  for (const childNode of childNodes) {
    if (childNode.nodeType === 1) {
      if (childNode["s-sr"]) {
        const slotName = childNode["s-sn"];
        childNode.hidden = false;
        for (const siblingNode of childNodes) {
          if (siblingNode !== childNode) {
            if (siblingNode["s-hn"] !== childNode["s-hn"] || slotName !== "") {
              if (siblingNode.nodeType === 1 && (slotName === siblingNode.getAttribute("slot") || slotName === siblingNode["s-sn"])) {
                childNode.hidden = true;
                break;
              }
            } else {
              if (siblingNode.nodeType === 1 || siblingNode.nodeType === 3 && siblingNode.textContent.trim() !== "") {
                childNode.hidden = true;
                break;
              }
            }
          }
        }
      }
      updateFallbackSlotVisibility(childNode);
    }
  }
};
const relocateNodes = [];
const markSlotContentForRelocation = (elm) => {
  let node;
  let hostContentNodes;
  let j;
  for (const childNode of elm.childNodes) {
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      const slotName = childNode["s-sn"];
      for (j = hostContentNodes.length - 1; j >= 0; j--) {
        node = hostContentNodes[j];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"] && !BUILD.experimentalSlotFixes) {
          if (isNodeLocatedInSlot(node, slotName)) {
            let relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotName;
            if (relocateNodeData) {
              relocateNodeData.$nodeToRelocate$["s-sh"] = childNode["s-hn"];
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              node["s-sh"] = childNode["s-hn"];
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r2) => r2.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      markSlotContentForRelocation(childNode);
    }
  }
};
const isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotName === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotName) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotName) {
    return true;
  }
  return slotName === "";
};
const nullifyVNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
  }
};
const renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
  var _a, _b, _c, _d, _e;
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const rootVnode = isHost(renderFnResults) ? renderFnResults : h$1(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
  }
  if (isInitialLoad && rootVnode.$attrs$) {
    for (const key of Object.keys(rootVnode.$attrs$)) {
      if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
        rootVnode.$attrs$[key] = hostElm[key];
      }
    }
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
  {
    scopeId = hostElm["s-sc"];
  }
  useNativeShadowDom = (cmpMeta.$flags$ & 1) !== 0;
  {
    contentRef = hostElm["s-cr"];
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode, isInitialLoad);
  {
    plt.$flags$ |= 1;
    if (checkSlotRelocate) {
      markSlotContentForRelocation(rootVnode.$elm$);
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          const orgLocationNode = doc$1.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        const slotRefNode = relocateData.$slotRefNode$;
        if (slotRefNode) {
          const parentNodeRef = slotRefNode.parentNode;
          let insertBeforeNode = slotRefNode.nextSibling;
          {
            let orgLocationNode = (_a = nodeToRelocate["s-ol"]) === null || _a === void 0 ? void 0 : _a.previousSibling;
            while (orgLocationNode) {
              let refNode = (_b = orgLocationNode["s-nr"]) !== null && _b !== void 0 ? _b : null;
              if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
                refNode = refNode.nextSibling;
                if (!refNode || !refNode["s-nr"]) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
              orgLocationNode = orgLocationNode.previousSibling;
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
              if (nodeToRelocate.nodeType === 1) {
                nodeToRelocate.hidden = (_c = nodeToRelocate["s-ih"]) !== null && _c !== void 0 ? _c : false;
              }
            }
          }
        } else {
          if (nodeToRelocate.nodeType === 1) {
            if (isInitialLoad) {
              nodeToRelocate["s-ih"] = (_d = nodeToRelocate.hidden) !== null && _d !== void 0 ? _d : false;
            }
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= ~1;
    relocateNodes.length = 0;
  }
  if (BUILD.experimentalScopedSlotChanges && cmpMeta.$flags$ & 2) {
    for (const childNode of rootVnode.$elm$.childNodes) {
      if (childNode["s-hn"] !== hostTagName && !childNode["s-sh"]) {
        if (isInitialLoad && childNode["s-ih"] == null) {
          childNode["s-ih"] = (_e = childNode.hidden) !== null && _e !== void 0 ? _e : false;
        }
        childNode.hidden = true;
      }
    }
  }
  contentRef = void 0;
};
const attachToAncestor = (hostRef, ancestorComponent) => {
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return writeTask(dispatch);
};
const dispatchHooks = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = elm;
  let maybePromise;
  if (isInitialLoad) {
    {
      maybePromise = safeCall$1(instance, "componentWillLoad");
    }
  } else {
    {
      maybePromise = safeCall$1(instance, "componentWillUpdate");
    }
  }
  {
    maybePromise = enqueue(maybePromise, () => safeCall$1(instance, "componentWillRender"));
  }
  endSchedule();
  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
};
const enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn) : fn();
const isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
const updateComponent = async (hostRef, instance, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  elm["s-rc"];
  if (isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender(hostRef, instance, elm, isInitialLoad);
  }
  endRender();
  endUpdate();
  {
    postUpdateComponent(hostRef);
  }
};
const callRender = (hostRef, instance, elm, isInitialLoad) => {
  const allRenderFn = false;
  const lazyLoad = false;
  const taskQueue = true;
  const updatable = true;
  try {
    renderingRef = instance;
    instance = allRenderFn ? instance.render() : instance.render && instance.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2;
    }
    if (BUILD.hasRenderFn || BUILD.reflect) {
      if (BUILD.vdomRender || BUILD.reflect) {
        if (BUILD.hydrateServerSide)
          ;
        else {
          renderVdom(hostRef, instance, isInitialLoad);
        }
      }
    }
  } catch (e2) {
    consoleError(e2, hostRef.$hostElement$);
  }
  renderingRef = null;
  return null;
};
const postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance = elm;
  hostRef.$ancestorComponent$;
  {
    safeCall$1(instance, "componentDidRender");
  }
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    {
      safeCall$1(instance, "componentDidLoad");
    }
    endPostUpdate();
  } else {
    {
      safeCall$1(instance, "componentDidUpdate");
    }
    endPostUpdate();
  }
};
const forceUpdate = (ref) => {
  {
    const hostRef = getHostRef(ref);
    const isConnected = hostRef.$hostElement$.isConnected;
    if (isConnected && (hostRef.$flags$ & (2 | 16)) === 2) {
      scheduleUpdate(hostRef, false);
    }
    return isConnected;
  }
};
const safeCall$1 = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e2) {
      consoleError(e2);
    }
  }
  return void 0;
};
const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref);
  const elm = ref;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags = hostRef.$flags$;
  const instance = elm;
  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if (didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    {
      if (cmpMeta.$watchers$ && flags & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e2) {
              consoleError(e2, elm);
            }
          });
        }
      }
      if ((flags & (2 | 16)) === 2) {
        if (instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate(hostRef, false);
      }
    }
  }
};
const proxyComponent = (Cstr, cmpMeta, flags) => {
  var _a;
  const prototype = Cstr.prototype;
  if (cmpMeta.$members$) {
    if (Cstr.watchers) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries(cmpMeta.$members$);
    members.map(([memberName, [memberFlags]]) => {
      if (memberFlags & 31 || memberFlags & 32) {
        Object.defineProperty(prototype, memberName, {
          get() {
            return getValue(this, memberName);
          },
          set(newValue) {
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      }
    });
    {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
        plt.jmp(() => {
          var _a2;
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
            return;
          } else if (propName == null) {
            const hostRef = getHostRef(this);
            const flags2 = hostRef === null || hostRef === void 0 ? void 0 : hostRef.$flags$;
            if (flags2 && !(flags2 & 8) && flags2 & 128 && newValue !== oldValue) {
              const elm = this;
              const instance = elm;
              const entry = (_a2 = cmpMeta.$watchers$) === null || _a2 === void 0 ? void 0 : _a2[attrName];
              entry === null || entry === void 0 ? void 0 : entry.forEach((callbackName) => {
                if (instance[callbackName] != null) {
                  instance[callbackName].call(instance, newValue, oldValue, attrName);
                }
              });
            }
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((_a = cmpMeta.$watchers$) !== null && _a !== void 0 ? _a : {}),
        ...members.filter(
          ([_, m2]) => m2[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([propName, m2]) => {
          var _a2;
          const attrName = m2[1] || propName;
          attrNameToPropName.set(attrName, propName);
          if (m2[0] & 512) {
            (_a2 = cmpMeta.$attrsToReflect$) === null || _a2 === void 0 ? void 0 : _a2.push([propName, attrName]);
          }
          return attrName;
        })
      ]));
    }
  }
  return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
  let Cstr;
  if ((hostRef.$flags$ & 32) === 0) {
    hostRef.$flags$ |= 32;
    {
      Cstr = elm.constructor;
      customElements.whenDefined(cmpMeta.$tagName$).then(() => hostRef.$flags$ |= 128);
    }
    if (Cstr.style) {
      let style = Cstr.style;
      if (typeof style !== "string") {
        style = style[hostRef.$modeName$ = computeMode(elm)];
      }
      const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  {
    schedule();
  }
};
const fireConnectedCallback = (instance) => {
};
const connectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      {
        if (
          // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
          cmpMeta.$flags$ & (4 | 8)
        ) {
          setContentReference(elm);
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
        fireConnectedCallback(hostRef.$lazyInstance$);
      } else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
      }
    }
    endConnected();
  }
};
const setContentReference = (elm) => {
  const contentRefElm = elm["s-cr"] = doc$1.createComment("");
  contentRefElm["s-cn"] = true;
  elm.insertBefore(contentRefElm, elm.firstChild);
};
const disconnectedCallback = async (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    {
      if (hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
  }
};
const proxyCustomElement = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  {
    cmpMeta.$members$ = compactMeta[2];
  }
  {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  {
    cmpMeta.$attrsToReflect$ = [];
  }
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __registerHost() {
      registerHost(this, cmpMeta);
    },
    connectedCallback() {
      connectedCallback(this);
      if (originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback(this);
      if (originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    },
    __attachShadow() {
      {
        {
          this.attachShadow({
            mode: "open",
            delegatesFocus: !!(cmpMeta.$flags$ & 16)
          });
        }
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent(Cstr, cmpMeta);
};
const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
  if (listeners) {
    listeners.map(([flags, name, method]) => {
      const target = getHostListenerTarget(elm, flags);
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
const hostListenerProxy = (hostRef, methodName) => (ev) => {
  try {
    if (BUILD.lazyLoad)
      ;
    else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e2) {
    consoleError(e2);
  }
};
const getHostListenerTarget = (elm, flags) => {
  if (flags & 4)
    return doc$1;
  if (flags & 8)
    return win$2;
  if (flags & 16)
    return doc$1.body;
  return elm;
};
const hostListenerOpts = (flags) => supportsListenerOptions ? {
  passive: (flags & 1) !== 0,
  capture: (flags & 2) !== 0
} : (flags & 2) !== 0;
const hostRefs = /* @__PURE__ */ new WeakMap();
const getHostRef = (ref) => hostRefs.get(ref);
const registerHost = (hostElement, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: hostElement,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  addHostEventListeners(hostElement, hostRef, cmpMeta.$listeners$);
  return hostRefs.set(hostElement, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e2, el2) => (0, console.error)(e2, el2);
const styles = /* @__PURE__ */ new Map();
const modeResolutionChain = [];
const win$2 = typeof window !== "undefined" ? window : {};
const doc$1 = win$2.document || { head: {} };
const H = win$2.HTMLElement || class {
};
const plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el2, eventName, listener, opts) => el2.addEventListener(eventName, listener, opts),
  rel: (el2, eventName, listener, opts) => el2.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
const setPlatformHelpers = (helpers) => {
  Object.assign(plt, helpers);
};
const supportsListenerOptions = /* @__PURE__ */ (() => {
  let supportsListenerOptions2 = false;
  try {
    doc$1.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        supportsListenerOptions2 = true;
      }
    }));
  } catch (e2) {
  }
  return supportsListenerOptions2;
})();
const promiseResolve = (v2) => Promise.resolve(v2);
const supportsConstructableStylesheets = /* @__PURE__ */ (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e2) {
  }
  return false;
})();
const queueDomReads = [];
const queueDomWrites = [];
const queueTask = (queue2, write3) => (cb2) => {
  queue2.push(cb2);
  if (!queuePending) {
    queuePending = true;
    if (write3 && plt.$flags$ & 4) {
      nextTick$1(flush);
    } else {
      plt.raf(flush);
    }
  }
};
const consume = (queue2) => {
  for (let i = 0; i < queue2.length; i++) {
    try {
      queue2[i](performance.now());
    } catch (e2) {
      consoleError(e2);
    }
  }
  queue2.length = 0;
};
const flush = () => {
  consume(queueDomReads);
  {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt.raf(flush);
    }
  }
};
const nextTick$1 = (cb2) => promiseResolve().then(cb2);
const readTask = /* @__PURE__ */ queueTask(queueDomReads, false);
const writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const win$1 = typeof window !== "undefined" ? window : void 0;
const doc = typeof document !== "undefined" ? document : void 0;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const componentOnReady = (el2, callback) => {
  if (el2.componentOnReady) {
    el2.componentOnReady().then((resolvedEl) => callback(resolvedEl));
  } else {
    raf(() => callback(el2));
  }
};
const hasLazyBuild = (stencilEl) => {
  return stencilEl.componentOnReady !== void 0;
};
const inheritAttributes$2 = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const ariaAttributes = [
  "role",
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-braillelabel",
  "aria-brailleroledescription",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colindextext",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-description",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowindextext",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext"
];
const inheritAriaAttributes = (el2, ignoreList) => {
  let attributesToInherit = ariaAttributes;
  if (ignoreList && ignoreList.length > 0) {
    attributesToInherit = attributesToInherit.filter((attr) => !ignoreList.includes(attr));
  }
  return inheritAttributes$2(el2, attributesToInherit);
};
const addEventListener$1 = (el2, eventName, callback, opts) => {
  var _a;
  if (typeof window !== "undefined") {
    const win2 = window;
    const config2 = (_a = win2 === null || win2 === void 0 ? void 0 : win2.Ionic) === null || _a === void 0 ? void 0 : _a.config;
    if (config2) {
      const ael = config2.get("_ael");
      if (ael) {
        return ael(el2, eventName, callback, opts);
      } else if (config2._ael) {
        return config2._ael(el2, eventName, callback, opts);
      }
    }
  }
  return el2.addEventListener(eventName, callback, opts);
};
const removeEventListener = (el2, eventName, callback, opts) => {
  var _a;
  if (typeof window !== "undefined") {
    const win2 = window;
    const config2 = (_a = win2 === null || win2 === void 0 ? void 0 : win2.Ionic) === null || _a === void 0 ? void 0 : _a.config;
    if (config2) {
      const rel = config2.get("_rel");
      if (rel) {
        return rel(el2, eventName, callback, opts);
      } else if (config2._rel) {
        return config2._rel(el2, eventName, callback, opts);
      }
    }
  }
  return el2.removeEventListener(eventName, callback, opts);
};
const getElementRoot = (el2, fallback = el2) => {
  return el2.shadowRoot || fallback;
};
const raf = (h2) => {
  if (typeof __zone_symbol__requestAnimationFrame === "function") {
    return __zone_symbol__requestAnimationFrame(h2);
  }
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame(h2);
  }
  return setTimeout(h2);
};
const hasShadowDom = (el2) => {
  return !!el2.shadowRoot && !!el2.attachShadow;
};
const findItemLabel = (componentEl) => {
  const itemEl = componentEl.closest("ion-item");
  if (itemEl) {
    return itemEl.querySelector("ion-label");
  }
  return null;
};
const focusElement = (el2) => {
  el2.focus();
  if (el2.classList.contains("ion-focusable")) {
    const app = el2.closest("ion-app");
    if (app) {
      app.setFocus([el2]);
    }
  }
};
const getAriaLabel = (componentEl, inputId) => {
  let labelText;
  const labelledBy = componentEl.getAttribute("aria-labelledby");
  const componentId = componentEl.id;
  let labelId = labelledBy !== null && labelledBy.trim() !== "" ? labelledBy : inputId + "-lbl";
  let label = labelledBy !== null && labelledBy.trim() !== "" ? document.getElementById(labelledBy) : findItemLabel(componentEl);
  if (label) {
    if (labelledBy === null) {
      label.id = labelId;
    }
    labelText = label.textContent;
    label.setAttribute("aria-hidden", "true");
  } else if (componentId.trim() !== "") {
    label = document.querySelector(`label[for="${componentId}"]`);
    if (label) {
      if (label.id !== "") {
        labelId = label.id;
      } else {
        label.id = labelId = `${componentId}-lbl`;
      }
      labelText = label.textContent;
    }
  }
  return { label, labelId, labelText };
};
const renderHiddenInput = (always, container, name, value, disabled) => {
  if (always || hasShadowDom(container)) {
    let input = container.querySelector("input.aux-input");
    if (!input) {
      input = container.ownerDocument.createElement("input");
      input.type = "hidden";
      input.classList.add("aux-input");
      container.appendChild(input);
    }
    input.disabled = disabled;
    input.name = name;
    input.value = value || "";
  }
};
const clamp = (min, n2, max) => {
  return Math.max(min, Math.min(n2, max));
};
const assert = (actual, reason) => {
  if (!actual) {
    const message = "ASSERT: " + reason;
    console.error(message);
    debugger;
    throw new Error(message);
  }
};
const now$1 = (ev) => {
  return ev.timeStamp || Date.now();
};
const pointerCoord = (ev) => {
  if (ev) {
    const changedTouches = ev.changedTouches;
    if (changedTouches && changedTouches.length > 0) {
      const touch = changedTouches[0];
      return { x: touch.clientX, y: touch.clientY };
    }
    if (ev.pageX !== void 0) {
      return { x: ev.pageX, y: ev.pageY };
    }
  }
  return { x: 0, y: 0 };
};
const debounceEvent = (event, wait) => {
  const original = event._original || event;
  return {
    _original: event,
    emit: debounce(original.emit.bind(original), wait)
  };
};
const debounce = (func, wait = 0) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(func, wait, ...args);
  };
};
const shallowEqualStringMap = (map1, map2) => {
  map1 !== null && map1 !== void 0 ? map1 : map1 = {};
  map2 !== null && map2 !== void 0 ? map2 : map2 = {};
  if (map1 === map2) {
    return true;
  }
  const keys1 = Object.keys(map1);
  if (keys1.length !== Object.keys(map2).length) {
    return false;
  }
  for (const k1 of keys1) {
    if (!(k1 in map2)) {
      return false;
    }
    if (map1[k1] !== map2[k1]) {
      return false;
    }
  }
  return true;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
let animationPrefix;
const processKeyframes = (keyframes) => {
  keyframes.forEach((keyframe) => {
    for (const key in keyframe) {
      if (keyframe.hasOwnProperty(key)) {
        const value = keyframe[key];
        if (key === "easing") {
          const newKey = "animation-timing-function";
          keyframe[newKey] = value;
          delete keyframe[key];
        } else {
          const newKey = convertCamelCaseToHypen(key);
          if (newKey !== key) {
            keyframe[newKey] = value;
            delete keyframe[key];
          }
        }
      }
    }
  });
  return keyframes;
};
const convertCamelCaseToHypen = (str) => {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
};
const getAnimationPrefix = (el2) => {
  if (animationPrefix === void 0) {
    const supportsUnprefixed = el2.style.animationName !== void 0;
    const supportsWebkitPrefix = el2.style.webkitAnimationName !== void 0;
    animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? "-webkit-" : "";
  }
  return animationPrefix;
};
const setStyleProperty = (element, propertyName, value) => {
  const prefix = propertyName.startsWith("animation") ? getAnimationPrefix(element) : "";
  element.style.setProperty(prefix + propertyName, value);
};
const removeStyleProperty = (element, propertyName) => {
  const prefix = propertyName.startsWith("animation") ? getAnimationPrefix(element) : "";
  element.style.removeProperty(prefix + propertyName);
};
const animationEnd = (el2, callback) => {
  let unRegTrans;
  const opts = { passive: true };
  const unregister = () => {
    if (unRegTrans) {
      unRegTrans();
    }
  };
  const onTransitionEnd = (ev) => {
    if (el2 === ev.target) {
      unregister();
      callback(ev);
    }
  };
  if (el2) {
    el2.addEventListener("webkitAnimationEnd", onTransitionEnd, opts);
    el2.addEventListener("animationend", onTransitionEnd, opts);
    unRegTrans = () => {
      el2.removeEventListener("webkitAnimationEnd", onTransitionEnd, opts);
      el2.removeEventListener("animationend", onTransitionEnd, opts);
    };
  }
  return unregister;
};
const generateKeyframeRules = (keyframes = []) => {
  return keyframes.map((keyframe) => {
    const offset = keyframe.offset;
    const frameString = [];
    for (const property in keyframe) {
      if (keyframe.hasOwnProperty(property) && property !== "offset") {
        frameString.push(`${property}: ${keyframe[property]};`);
      }
    }
    return `${offset * 100}% { ${frameString.join(" ")} }`;
  }).join(" ");
};
const keyframeIds = [];
const generateKeyframeName = (keyframeRules) => {
  let index = keyframeIds.indexOf(keyframeRules);
  if (index < 0) {
    index = keyframeIds.push(keyframeRules) - 1;
  }
  return `ion-animation-${index}`;
};
const getStyleContainer = (element) => {
  const rootNode = element.getRootNode !== void 0 ? element.getRootNode() : element;
  return rootNode.head || rootNode;
};
const createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {
  var _a;
  const styleContainer = getStyleContainer(element);
  const keyframePrefix = getAnimationPrefix(element);
  const existingStylesheet = styleContainer.querySelector("#" + keyframeName);
  if (existingStylesheet) {
    return existingStylesheet;
  }
  const stylesheet = ((_a = element.ownerDocument) !== null && _a !== void 0 ? _a : document).createElement("style");
  stylesheet.id = keyframeName;
  stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;
  styleContainer.appendChild(stylesheet);
  return stylesheet;
};
const addClassToArray = (classes = [], className) => {
  if (className !== void 0) {
    const classNameToAppend = Array.isArray(className) ? className : [className];
    return [...classes, ...classNameToAppend];
  }
  return classes;
};
const createAnimation = (animationId) => {
  let _delay;
  let _duration;
  let _easing;
  let _iterations;
  let _fill;
  let _direction;
  let _keyframes = [];
  let beforeAddClasses = [];
  let beforeRemoveClasses = [];
  let initialized = false;
  let parentAnimation;
  let beforeStylesValue = {};
  let afterAddClasses = [];
  let afterRemoveClasses = [];
  let afterStylesValue = {};
  let numAnimationsRunning = 0;
  let shouldForceLinearEasing = false;
  let shouldForceSyncPlayback = false;
  let cssAnimationsTimerFallback;
  let forceDirectionValue;
  let forceDurationValue;
  let forceDelayValue;
  let willComplete = true;
  let finished = false;
  let shouldCalculateNumAnimations = true;
  let keyframeName;
  let ani;
  let paused = false;
  const id2 = animationId;
  const onFinishCallbacks = [];
  const onFinishOneTimeCallbacks = [];
  const onStopOneTimeCallbacks = [];
  const elements = [];
  const childAnimations = [];
  const stylesheets = [];
  const _beforeAddReadFunctions = [];
  const _beforeAddWriteFunctions = [];
  const _afterAddReadFunctions = [];
  const _afterAddWriteFunctions = [];
  const webAnimations = [];
  const supportsAnimationEffect = typeof AnimationEffect === "function" || win$1 !== void 0 && typeof win$1.AnimationEffect === "function";
  const supportsWebAnimations = typeof Element === "function" && typeof Element.prototype.animate === "function" && supportsAnimationEffect;
  const ANIMATION_END_FALLBACK_PADDING_MS = 100;
  const getWebAnimations = () => {
    return webAnimations;
  };
  const destroy = (clearStyleSheets) => {
    childAnimations.forEach((childAnimation) => {
      childAnimation.destroy(clearStyleSheets);
    });
    cleanUp(clearStyleSheets);
    elements.length = 0;
    childAnimations.length = 0;
    _keyframes.length = 0;
    clearOnFinish();
    initialized = false;
    shouldCalculateNumAnimations = true;
    return ani;
  };
  const cleanUp = (clearStyleSheets) => {
    cleanUpElements();
    if (clearStyleSheets) {
      cleanUpStyleSheets();
    }
  };
  const resetFlags = () => {
    shouldForceLinearEasing = false;
    shouldForceSyncPlayback = false;
    shouldCalculateNumAnimations = true;
    forceDirectionValue = void 0;
    forceDurationValue = void 0;
    forceDelayValue = void 0;
    numAnimationsRunning = 0;
    finished = false;
    willComplete = true;
    paused = false;
  };
  const isRunning = () => {
    return numAnimationsRunning !== 0 && !paused;
  };
  const clearCallback = (callbackToRemove, callbackObjects) => {
    const index = callbackObjects.findIndex((callbackObject) => callbackObject.c === callbackToRemove);
    if (index > -1) {
      callbackObjects.splice(index, 1);
    }
  };
  const onStop = (callback, opts) => {
    onStopOneTimeCallbacks.push({ c: callback, o: opts });
    return ani;
  };
  const onFinish = (callback, opts) => {
    const callbacks = (opts === null || opts === void 0 ? void 0 : opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;
    callbacks.push({ c: callback, o: opts });
    return ani;
  };
  const clearOnFinish = () => {
    onFinishCallbacks.length = 0;
    onFinishOneTimeCallbacks.length = 0;
    return ani;
  };
  const cleanUpElements = () => {
    if (supportsWebAnimations) {
      webAnimations.forEach((animation2) => {
        animation2.cancel();
      });
      webAnimations.length = 0;
    } else {
      const elementsArray = elements.slice();
      raf(() => {
        elementsArray.forEach((element) => {
          removeStyleProperty(element, "animation-name");
          removeStyleProperty(element, "animation-duration");
          removeStyleProperty(element, "animation-timing-function");
          removeStyleProperty(element, "animation-iteration-count");
          removeStyleProperty(element, "animation-delay");
          removeStyleProperty(element, "animation-play-state");
          removeStyleProperty(element, "animation-fill-mode");
          removeStyleProperty(element, "animation-direction");
        });
      });
    }
  };
  const cleanUpStyleSheets = () => {
    stylesheets.forEach((stylesheet) => {
      if (stylesheet === null || stylesheet === void 0 ? void 0 : stylesheet.parentNode) {
        stylesheet.parentNode.removeChild(stylesheet);
      }
    });
    stylesheets.length = 0;
  };
  const beforeAddRead = (readFn) => {
    _beforeAddReadFunctions.push(readFn);
    return ani;
  };
  const beforeAddWrite = (writeFn) => {
    _beforeAddWriteFunctions.push(writeFn);
    return ani;
  };
  const afterAddRead = (readFn) => {
    _afterAddReadFunctions.push(readFn);
    return ani;
  };
  const afterAddWrite = (writeFn) => {
    _afterAddWriteFunctions.push(writeFn);
    return ani;
  };
  const beforeAddClass = (className) => {
    beforeAddClasses = addClassToArray(beforeAddClasses, className);
    return ani;
  };
  const beforeRemoveClass = (className) => {
    beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);
    return ani;
  };
  const beforeStyles = (styles2 = {}) => {
    beforeStylesValue = styles2;
    return ani;
  };
  const beforeClearStyles = (propertyNames = []) => {
    for (const property of propertyNames) {
      beforeStylesValue[property] = "";
    }
    return ani;
  };
  const afterAddClass = (className) => {
    afterAddClasses = addClassToArray(afterAddClasses, className);
    return ani;
  };
  const afterRemoveClass = (className) => {
    afterRemoveClasses = addClassToArray(afterRemoveClasses, className);
    return ani;
  };
  const afterStyles = (styles2 = {}) => {
    afterStylesValue = styles2;
    return ani;
  };
  const afterClearStyles = (propertyNames = []) => {
    for (const property of propertyNames) {
      afterStylesValue[property] = "";
    }
    return ani;
  };
  const getFill = () => {
    if (_fill !== void 0) {
      return _fill;
    }
    if (parentAnimation) {
      return parentAnimation.getFill();
    }
    return "both";
  };
  const getDirection2 = () => {
    if (forceDirectionValue !== void 0) {
      return forceDirectionValue;
    }
    if (_direction !== void 0) {
      return _direction;
    }
    if (parentAnimation) {
      return parentAnimation.getDirection();
    }
    return "normal";
  };
  const getEasing = () => {
    if (shouldForceLinearEasing) {
      return "linear";
    }
    if (_easing !== void 0) {
      return _easing;
    }
    if (parentAnimation) {
      return parentAnimation.getEasing();
    }
    return "linear";
  };
  const getDuration = () => {
    if (shouldForceSyncPlayback) {
      return 0;
    }
    if (forceDurationValue !== void 0) {
      return forceDurationValue;
    }
    if (_duration !== void 0) {
      return _duration;
    }
    if (parentAnimation) {
      return parentAnimation.getDuration();
    }
    return 0;
  };
  const getIterations = () => {
    if (_iterations !== void 0) {
      return _iterations;
    }
    if (parentAnimation) {
      return parentAnimation.getIterations();
    }
    return 1;
  };
  const getDelay = () => {
    if (forceDelayValue !== void 0) {
      return forceDelayValue;
    }
    if (_delay !== void 0) {
      return _delay;
    }
    if (parentAnimation) {
      return parentAnimation.getDelay();
    }
    return 0;
  };
  const getKeyframes = () => {
    return _keyframes;
  };
  const direction = (animationDirection) => {
    _direction = animationDirection;
    update(true);
    return ani;
  };
  const fill2 = (animationFill) => {
    _fill = animationFill;
    update(true);
    return ani;
  };
  const delay = (animationDelay) => {
    _delay = animationDelay;
    update(true);
    return ani;
  };
  const easing = (animationEasing) => {
    _easing = animationEasing;
    update(true);
    return ani;
  };
  const duration = (animationDuration) => {
    if (!supportsWebAnimations && animationDuration === 0) {
      animationDuration = 1;
    }
    _duration = animationDuration;
    update(true);
    return ani;
  };
  const iterations = (animationIterations) => {
    _iterations = animationIterations;
    update(true);
    return ani;
  };
  const parent = (animation2) => {
    parentAnimation = animation2;
    return ani;
  };
  const addElement = (el2) => {
    if (el2 != null) {
      if (el2.nodeType === 1) {
        elements.push(el2);
      } else if (el2.length >= 0) {
        for (let i = 0; i < el2.length; i++) {
          elements.push(el2[i]);
        }
      } else {
        console.error("Invalid addElement value");
      }
    }
    return ani;
  };
  const addAnimation = (animationToAdd) => {
    if (animationToAdd != null) {
      if (Array.isArray(animationToAdd)) {
        for (const animation2 of animationToAdd) {
          animation2.parent(ani);
          childAnimations.push(animation2);
        }
      } else {
        animationToAdd.parent(ani);
        childAnimations.push(animationToAdd);
      }
    }
    return ani;
  };
  const keyframes = (keyframeValues) => {
    const different = _keyframes !== keyframeValues;
    _keyframes = keyframeValues;
    if (different) {
      updateKeyframes(_keyframes);
    }
    return ani;
  };
  const updateKeyframes = (keyframeValues) => {
    if (supportsWebAnimations) {
      getWebAnimations().forEach((animation2) => {
        const keyframeEffect = animation2.effect;
        if (keyframeEffect.setKeyframes) {
          keyframeEffect.setKeyframes(keyframeValues);
        } else {
          const newEffect = new KeyframeEffect(keyframeEffect.target, keyframeValues, keyframeEffect.getTiming());
          animation2.effect = newEffect;
        }
      });
    } else {
      initializeCSSAnimation();
    }
  };
  const beforeAnimation = () => {
    _beforeAddReadFunctions.forEach((callback) => callback());
    _beforeAddWriteFunctions.forEach((callback) => callback());
    const addClasses = beforeAddClasses;
    const removeClasses = beforeRemoveClasses;
    const styles2 = beforeStylesValue;
    elements.forEach((el2) => {
      const elementClassList = el2.classList;
      addClasses.forEach((c2) => elementClassList.add(c2));
      removeClasses.forEach((c2) => elementClassList.remove(c2));
      for (const property in styles2) {
        if (styles2.hasOwnProperty(property)) {
          setStyleProperty(el2, property, styles2[property]);
        }
      }
    });
  };
  const afterAnimation = () => {
    clearCSSAnimationsTimeout();
    _afterAddReadFunctions.forEach((callback) => callback());
    _afterAddWriteFunctions.forEach((callback) => callback());
    const currentStep = willComplete ? 1 : 0;
    const addClasses = afterAddClasses;
    const removeClasses = afterRemoveClasses;
    const styles2 = afterStylesValue;
    elements.forEach((el2) => {
      const elementClassList = el2.classList;
      addClasses.forEach((c2) => elementClassList.add(c2));
      removeClasses.forEach((c2) => elementClassList.remove(c2));
      for (const property in styles2) {
        if (styles2.hasOwnProperty(property)) {
          setStyleProperty(el2, property, styles2[property]);
        }
      }
    });
    forceDurationValue = void 0;
    forceDirectionValue = void 0;
    forceDelayValue = void 0;
    onFinishCallbacks.forEach((onFinishCallback) => {
      return onFinishCallback.c(currentStep, ani);
    });
    onFinishOneTimeCallbacks.forEach((onFinishCallback) => {
      return onFinishCallback.c(currentStep, ani);
    });
    onFinishOneTimeCallbacks.length = 0;
    shouldCalculateNumAnimations = true;
    if (willComplete) {
      finished = true;
    }
    willComplete = true;
  };
  const animationFinish = () => {
    if (numAnimationsRunning === 0) {
      return;
    }
    numAnimationsRunning--;
    if (numAnimationsRunning === 0) {
      afterAnimation();
      if (parentAnimation) {
        parentAnimation.animationFinish();
      }
    }
  };
  const initializeCSSAnimation = (toggleAnimationName = true) => {
    cleanUpStyleSheets();
    const processedKeyframes = processKeyframes(_keyframes);
    elements.forEach((element) => {
      if (processedKeyframes.length > 0) {
        const keyframeRules = generateKeyframeRules(processedKeyframes);
        keyframeName = animationId !== void 0 ? animationId : generateKeyframeName(keyframeRules);
        const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);
        stylesheets.push(stylesheet);
        setStyleProperty(element, "animation-duration", `${getDuration()}ms`);
        setStyleProperty(element, "animation-timing-function", getEasing());
        setStyleProperty(element, "animation-delay", `${getDelay()}ms`);
        setStyleProperty(element, "animation-fill-mode", getFill());
        setStyleProperty(element, "animation-direction", getDirection2());
        const iterationsCount = getIterations() === Infinity ? "infinite" : getIterations().toString();
        setStyleProperty(element, "animation-iteration-count", iterationsCount);
        setStyleProperty(element, "animation-play-state", "paused");
        if (toggleAnimationName) {
          setStyleProperty(element, "animation-name", `${stylesheet.id}-alt`);
        }
        raf(() => {
          setStyleProperty(element, "animation-name", stylesheet.id || null);
        });
      }
    });
  };
  const initializeWebAnimation = () => {
    elements.forEach((element) => {
      const animation2 = element.animate(_keyframes, {
        id: id2,
        delay: getDelay(),
        duration: getDuration(),
        easing: getEasing(),
        iterations: getIterations(),
        fill: getFill(),
        direction: getDirection2()
      });
      animation2.pause();
      webAnimations.push(animation2);
    });
    if (webAnimations.length > 0) {
      webAnimations[0].onfinish = () => {
        animationFinish();
      };
    }
  };
  const initializeAnimation = (toggleAnimationName = true) => {
    beforeAnimation();
    if (_keyframes.length > 0) {
      if (supportsWebAnimations) {
        initializeWebAnimation();
      } else {
        initializeCSSAnimation(toggleAnimationName);
      }
    }
    initialized = true;
  };
  const setAnimationStep = (step) => {
    step = Math.min(Math.max(step, 0), 0.9999);
    if (supportsWebAnimations) {
      webAnimations.forEach((animation2) => {
        animation2.currentTime = animation2.effect.getComputedTiming().delay + getDuration() * step;
        animation2.pause();
      });
    } else {
      const animationDuration = `-${getDuration() * step}ms`;
      elements.forEach((element) => {
        if (_keyframes.length > 0) {
          setStyleProperty(element, "animation-delay", animationDuration);
          setStyleProperty(element, "animation-play-state", "paused");
        }
      });
    }
  };
  const updateWebAnimation = (step) => {
    webAnimations.forEach((animation2) => {
      animation2.effect.updateTiming({
        delay: getDelay(),
        duration: getDuration(),
        easing: getEasing(),
        iterations: getIterations(),
        fill: getFill(),
        direction: getDirection2()
      });
    });
    if (step !== void 0) {
      setAnimationStep(step);
    }
  };
  const updateCSSAnimation = (toggleAnimationName = true, step) => {
    raf(() => {
      elements.forEach((element) => {
        setStyleProperty(element, "animation-name", keyframeName || null);
        setStyleProperty(element, "animation-duration", `${getDuration()}ms`);
        setStyleProperty(element, "animation-timing-function", getEasing());
        setStyleProperty(element, "animation-delay", step !== void 0 ? `-${step * getDuration()}ms` : `${getDelay()}ms`);
        setStyleProperty(element, "animation-fill-mode", getFill() || null);
        setStyleProperty(element, "animation-direction", getDirection2() || null);
        const iterationsCount = getIterations() === Infinity ? "infinite" : getIterations().toString();
        setStyleProperty(element, "animation-iteration-count", iterationsCount);
        if (toggleAnimationName) {
          setStyleProperty(element, "animation-name", `${keyframeName}-alt`);
        }
        raf(() => {
          setStyleProperty(element, "animation-name", keyframeName || null);
        });
      });
    });
  };
  const update = (deep = false, toggleAnimationName = true, step) => {
    if (deep) {
      childAnimations.forEach((animation2) => {
        animation2.update(deep, toggleAnimationName, step);
      });
    }
    if (supportsWebAnimations) {
      updateWebAnimation(step);
    } else {
      updateCSSAnimation(toggleAnimationName, step);
    }
    return ani;
  };
  const progressStart = (forceLinearEasing = false, step) => {
    childAnimations.forEach((animation2) => {
      animation2.progressStart(forceLinearEasing, step);
    });
    pauseAnimation();
    shouldForceLinearEasing = forceLinearEasing;
    if (!initialized) {
      initializeAnimation();
    }
    update(false, true, step);
    return ani;
  };
  const progressStep = (step) => {
    childAnimations.forEach((animation2) => {
      animation2.progressStep(step);
    });
    setAnimationStep(step);
    return ani;
  };
  const progressEnd = (playTo, step, dur) => {
    shouldForceLinearEasing = false;
    childAnimations.forEach((animation2) => {
      animation2.progressEnd(playTo, step, dur);
    });
    if (dur !== void 0) {
      forceDurationValue = dur;
    }
    finished = false;
    willComplete = true;
    if (playTo === 0) {
      forceDirectionValue = getDirection2() === "reverse" ? "normal" : "reverse";
      if (forceDirectionValue === "reverse") {
        willComplete = false;
      }
      if (supportsWebAnimations) {
        update();
        setAnimationStep(1 - step);
      } else {
        forceDelayValue = (1 - step) * getDuration() * -1;
        update(false, false);
      }
    } else if (playTo === 1) {
      if (supportsWebAnimations) {
        update();
        setAnimationStep(step);
      } else {
        forceDelayValue = step * getDuration() * -1;
        update(false, false);
      }
    }
    if (playTo !== void 0 && !parentAnimation) {
      play();
    }
    return ani;
  };
  const pauseAnimation = () => {
    if (initialized) {
      if (supportsWebAnimations) {
        webAnimations.forEach((animation2) => {
          animation2.pause();
        });
      } else {
        elements.forEach((element) => {
          setStyleProperty(element, "animation-play-state", "paused");
        });
      }
      paused = true;
    }
  };
  const pause = () => {
    childAnimations.forEach((animation2) => {
      animation2.pause();
    });
    pauseAnimation();
    return ani;
  };
  const onAnimationEndFallback = () => {
    cssAnimationsTimerFallback = void 0;
    animationFinish();
  };
  const clearCSSAnimationsTimeout = () => {
    if (cssAnimationsTimerFallback) {
      clearTimeout(cssAnimationsTimerFallback);
    }
  };
  const playCSSAnimations = () => {
    clearCSSAnimationsTimeout();
    raf(() => {
      elements.forEach((element) => {
        if (_keyframes.length > 0) {
          setStyleProperty(element, "animation-play-state", "running");
        }
      });
    });
    if (_keyframes.length === 0 || elements.length === 0) {
      animationFinish();
    } else {
      const animationDelay = getDelay() || 0;
      const animationDuration = getDuration() || 0;
      const animationIterations = getIterations() || 1;
      if (isFinite(animationIterations)) {
        cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration * animationIterations + ANIMATION_END_FALLBACK_PADDING_MS);
      }
      animationEnd(elements[0], () => {
        clearCSSAnimationsTimeout();
        raf(() => {
          clearCSSAnimationPlayState();
          raf(animationFinish);
        });
      });
    }
  };
  const clearCSSAnimationPlayState = () => {
    elements.forEach((element) => {
      removeStyleProperty(element, "animation-duration");
      removeStyleProperty(element, "animation-delay");
      removeStyleProperty(element, "animation-play-state");
    });
  };
  const playWebAnimations = () => {
    webAnimations.forEach((animation2) => {
      animation2.play();
    });
    if (_keyframes.length === 0 || elements.length === 0) {
      animationFinish();
    }
  };
  const resetAnimation = () => {
    if (supportsWebAnimations) {
      setAnimationStep(0);
      updateWebAnimation();
    } else {
      updateCSSAnimation();
    }
  };
  const play = (opts) => {
    return new Promise((resolve2) => {
      if (opts === null || opts === void 0 ? void 0 : opts.sync) {
        shouldForceSyncPlayback = true;
        onFinish(() => shouldForceSyncPlayback = false, { oneTimeCallback: true });
      }
      if (!initialized) {
        initializeAnimation();
      }
      if (finished) {
        resetAnimation();
        finished = false;
      }
      if (shouldCalculateNumAnimations) {
        numAnimationsRunning = childAnimations.length + 1;
        shouldCalculateNumAnimations = false;
      }
      const onStopCallback = () => {
        clearCallback(onFinishCallback, onFinishOneTimeCallbacks);
        resolve2();
      };
      const onFinishCallback = () => {
        clearCallback(onStopCallback, onStopOneTimeCallbacks);
        resolve2();
      };
      onFinish(onFinishCallback, { oneTimeCallback: true });
      onStop(onStopCallback, { oneTimeCallback: true });
      childAnimations.forEach((animation2) => {
        animation2.play();
      });
      if (supportsWebAnimations) {
        playWebAnimations();
      } else {
        playCSSAnimations();
      }
      paused = false;
    });
  };
  const stop = () => {
    childAnimations.forEach((animation2) => {
      animation2.stop();
    });
    if (initialized) {
      cleanUpElements();
      initialized = false;
    }
    resetFlags();
    onStopOneTimeCallbacks.forEach((onStopCallback) => onStopCallback.c(0, ani));
    onStopOneTimeCallbacks.length = 0;
  };
  const from2 = (property, value) => {
    const firstFrame = _keyframes[0];
    if (firstFrame !== void 0 && (firstFrame.offset === void 0 || firstFrame.offset === 0)) {
      firstFrame[property] = value;
    } else {
      _keyframes = [{ offset: 0, [property]: value }, ..._keyframes];
    }
    return ani;
  };
  const to = (property, value) => {
    const lastFrame = _keyframes[_keyframes.length - 1];
    if (lastFrame !== void 0 && (lastFrame.offset === void 0 || lastFrame.offset === 1)) {
      lastFrame[property] = value;
    } else {
      _keyframes = [..._keyframes, { offset: 1, [property]: value }];
    }
    return ani;
  };
  const fromTo = (property, fromValue, toValue) => {
    return from2(property, fromValue).to(property, toValue);
  };
  return ani = {
    parentAnimation,
    elements,
    childAnimations,
    id: id2,
    animationFinish,
    from: from2,
    to,
    fromTo,
    parent,
    play,
    pause,
    stop,
    destroy,
    keyframes,
    addAnimation,
    addElement,
    update,
    fill: fill2,
    direction,
    iterations,
    duration,
    easing,
    delay,
    getWebAnimations,
    getKeyframes,
    getFill,
    getDirection: getDirection2,
    getDelay,
    getIterations,
    getEasing,
    getDuration,
    afterAddRead,
    afterAddWrite,
    afterClearStyles,
    afterStyles,
    afterRemoveClass,
    afterAddClass,
    beforeAddRead,
    beforeAddWrite,
    beforeClearStyles,
    beforeStyles,
    beforeRemoveClass,
    beforeAddClass,
    onFinish,
    isRunning,
    progressStart,
    progressStep,
    progressEnd
  };
};
const LIFECYCLE_WILL_ENTER = "ionViewWillEnter";
const LIFECYCLE_DID_ENTER = "ionViewDidEnter";
const LIFECYCLE_WILL_LEAVE = "ionViewWillLeave";
const LIFECYCLE_DID_LEAVE = "ionViewDidLeave";
const LIFECYCLE_WILL_UNLOAD = "ionViewWillUnload";
const iosTransitionAnimation = () => __vitePreload(() => import("./ios.transition-PeRsoOrx.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url);
const mdTransitionAnimation = () => __vitePreload(() => import("./md.transition-BPAt6EVx.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url);
const transition = (opts) => {
  return new Promise((resolve2, reject) => {
    writeTask(() => {
      beforeTransition(opts);
      runTransition(opts).then((result) => {
        if (result.animation) {
          result.animation.destroy();
        }
        afterTransition(opts);
        resolve2(result);
      }, (error) => {
        afterTransition(opts);
        reject(error);
      });
    });
  });
};
const beforeTransition = (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  setZIndex(enteringEl, leavingEl, opts.direction);
  if (opts.showGoBack) {
    enteringEl.classList.add("can-go-back");
  } else {
    enteringEl.classList.remove("can-go-back");
  }
  setPageHidden(enteringEl, false);
  enteringEl.style.setProperty("pointer-events", "none");
  if (leavingEl) {
    setPageHidden(leavingEl, false);
    leavingEl.style.setProperty("pointer-events", "none");
  }
};
const runTransition = async (opts) => {
  const animationBuilder = await getAnimationBuilder(opts);
  const ani = animationBuilder && Build.isBrowser ? animation(animationBuilder, opts) : noAnimation(opts);
  return ani;
};
const afterTransition = (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  enteringEl.classList.remove("ion-page-invisible");
  enteringEl.style.removeProperty("pointer-events");
  if (leavingEl !== void 0) {
    leavingEl.classList.remove("ion-page-invisible");
    leavingEl.style.removeProperty("pointer-events");
  }
};
const getAnimationBuilder = async (opts) => {
  if (!opts.leavingEl || !opts.animated || opts.duration === 0) {
    return void 0;
  }
  if (opts.animationBuilder) {
    return opts.animationBuilder;
  }
  const getAnimation = opts.mode === "ios" ? (await iosTransitionAnimation()).iosTransitionAnimation : (await mdTransitionAnimation()).mdTransitionAnimation;
  return getAnimation;
};
const animation = async (animationBuilder, opts) => {
  await waitForReady(opts, true);
  const trans = animationBuilder(opts.baseEl, opts);
  fireWillEvents(opts.enteringEl, opts.leavingEl);
  const didComplete = await playTransition(trans, opts);
  if (opts.progressCallback) {
    opts.progressCallback(void 0);
  }
  if (didComplete) {
    fireDidEvents(opts.enteringEl, opts.leavingEl);
  }
  return {
    hasCompleted: didComplete,
    animation: trans
  };
};
const noAnimation = async (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  await waitForReady(opts, false);
  fireWillEvents(enteringEl, leavingEl);
  fireDidEvents(enteringEl, leavingEl);
  return {
    hasCompleted: true
  };
};
const waitForReady = async (opts, defaultDeep) => {
  const deep = opts.deepWait !== void 0 ? opts.deepWait : defaultDeep;
  if (deep) {
    await Promise.all([deepReady(opts.enteringEl), deepReady(opts.leavingEl)]);
  }
  await notifyViewReady(opts.viewIsReady, opts.enteringEl);
};
const notifyViewReady = async (viewIsReady, enteringEl) => {
  if (viewIsReady) {
    await viewIsReady(enteringEl);
  }
};
const playTransition = (trans, opts) => {
  const progressCallback = opts.progressCallback;
  const promise = new Promise((resolve2) => {
    trans.onFinish((currentStep) => resolve2(currentStep === 1));
  });
  if (progressCallback) {
    trans.progressStart(true);
    progressCallback(trans);
  } else {
    trans.play();
  }
  return promise;
};
const fireWillEvents = (enteringEl, leavingEl) => {
  lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);
  lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);
};
const fireDidEvents = (enteringEl, leavingEl) => {
  lifecycle(enteringEl, LIFECYCLE_DID_ENTER);
  lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);
};
const lifecycle = (el2, eventName) => {
  if (el2) {
    const ev = new CustomEvent(eventName, {
      bubbles: false,
      cancelable: false
    });
    el2.dispatchEvent(ev);
  }
};
const waitForMount = () => {
  return new Promise((resolve2) => raf(() => raf(() => resolve2())));
};
const deepReady = async (el2) => {
  const element = el2;
  if (element) {
    if (element.componentOnReady != null) {
      const stencilEl = await element.componentOnReady();
      if (stencilEl != null) {
        return;
      }
    } else if (element.__registerHost != null) {
      const waitForCustomElement = new Promise((resolve2) => raf(resolve2));
      await waitForCustomElement;
      return;
    }
    await Promise.all(Array.from(element.children).map(deepReady));
  }
};
const setPageHidden = (el2, hidden) => {
  if (hidden) {
    el2.setAttribute("aria-hidden", "true");
    el2.classList.add("ion-page-hidden");
  } else {
    el2.hidden = false;
    el2.removeAttribute("aria-hidden");
    el2.classList.remove("ion-page-hidden");
  }
};
const setZIndex = (enteringEl, leavingEl, direction) => {
  if (enteringEl !== void 0) {
    enteringEl.style.zIndex = direction === "back" ? "99" : "101";
  }
  if (leavingEl !== void 0) {
    leavingEl.style.zIndex = "100";
  }
};
const getIonPageElement = (element) => {
  if (element.classList.contains("ion-page")) {
    return element;
  }
  const ionPage = element.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs");
  if (ionPage) {
    return ionPage;
  }
  return element;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getTimeGivenProgression = (p0, p1, p2, p3, progression) => {
  return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map((tValue) => {
    return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);
  });
};
const solveCubicParametricEquation = (p0, p1, p2, p3, t2) => {
  const partA = 3 * p1 * Math.pow(t2 - 1, 2);
  const partB = -3 * p2 * t2 + 3 * p2 + p3 * t2;
  const partC = p0 * Math.pow(t2 - 1, 3);
  return t2 * (partA + t2 * partB) - partC;
};
const solveCubicBezier = (p0, p1, p2, p3, refPoint) => {
  p0 -= refPoint;
  p1 -= refPoint;
  p2 -= refPoint;
  p3 -= refPoint;
  const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);
  return roots.filter((root) => root >= 0 && root <= 1);
};
const solveQuadraticEquation = (a2, b2, c2) => {
  const discriminant = b2 * b2 - 4 * a2 * c2;
  if (discriminant < 0) {
    return [];
  } else {
    return [(-b2 + Math.sqrt(discriminant)) / (2 * a2), (-b2 - Math.sqrt(discriminant)) / (2 * a2)];
  }
};
const solveCubicEquation = (a2, b2, c2, d2) => {
  if (a2 === 0) {
    return solveQuadraticEquation(b2, c2, d2);
  }
  b2 /= a2;
  c2 /= a2;
  d2 /= a2;
  const p2 = (3 * c2 - b2 * b2) / 3;
  const q2 = (2 * b2 * b2 * b2 - 9 * b2 * c2 + 27 * d2) / 27;
  if (p2 === 0) {
    return [Math.pow(-q2, 1 / 3)];
  } else if (q2 === 0) {
    return [Math.sqrt(-p2), -Math.sqrt(-p2)];
  }
  const discriminant = Math.pow(q2 / 2, 2) + Math.pow(p2 / 3, 3);
  if (discriminant === 0) {
    return [Math.pow(q2 / 2, 1 / 2) - b2 / 3];
  } else if (discriminant > 0) {
    return [
      Math.pow(-(q2 / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow(q2 / 2 + Math.sqrt(discriminant), 1 / 3) - b2 / 3
    ];
  }
  const r2 = Math.sqrt(Math.pow(-(p2 / 3), 3));
  const phi = Math.acos(-(q2 / (2 * Math.sqrt(Math.pow(-(p2 / 3), 3)))));
  const s2 = 2 * Math.pow(r2, 1 / 3);
  return [
    s2 * Math.cos(phi / 3) - b2 / 3,
    s2 * Math.cos((phi + 2 * Math.PI) / 3) - b2 / 3,
    s2 * Math.cos((phi + 4 * Math.PI) / 3) - b2 / 3
  ];
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
class GestureController {
  constructor() {
    this.gestureId = 0;
    this.requestedStart = /* @__PURE__ */ new Map();
    this.disabledGestures = /* @__PURE__ */ new Map();
    this.disabledScroll = /* @__PURE__ */ new Set();
  }
  /**
   * Creates a gesture delegate based on the GestureConfig passed
   */
  createGesture(config2) {
    var _a;
    return new GestureDelegate(this, this.newID(), config2.name, (_a = config2.priority) !== null && _a !== void 0 ? _a : 0, !!config2.disableScroll);
  }
  /**
   * Creates a blocker that will block any other gesture events from firing. Set in the ion-gesture component.
   */
  createBlocker(opts = {}) {
    return new BlockerDelegate(this, this.newID(), opts.disable, !!opts.disableScroll);
  }
  start(gestureName, id2, priority) {
    if (!this.canStart(gestureName)) {
      this.requestedStart.delete(id2);
      return false;
    }
    this.requestedStart.set(id2, priority);
    return true;
  }
  capture(gestureName, id2, priority) {
    if (!this.start(gestureName, id2, priority)) {
      return false;
    }
    const requestedStart = this.requestedStart;
    let maxPriority = -1e4;
    requestedStart.forEach((value) => {
      maxPriority = Math.max(maxPriority, value);
    });
    if (maxPriority === priority) {
      this.capturedId = id2;
      requestedStart.clear();
      const event = new CustomEvent("ionGestureCaptured", { detail: { gestureName } });
      document.dispatchEvent(event);
      return true;
    }
    requestedStart.delete(id2);
    return false;
  }
  release(id2) {
    this.requestedStart.delete(id2);
    if (this.capturedId === id2) {
      this.capturedId = void 0;
    }
  }
  disableGesture(gestureName, id2) {
    let set = this.disabledGestures.get(gestureName);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      this.disabledGestures.set(gestureName, set);
    }
    set.add(id2);
  }
  enableGesture(gestureName, id2) {
    const set = this.disabledGestures.get(gestureName);
    if (set !== void 0) {
      set.delete(id2);
    }
  }
  disableScroll(id2) {
    this.disabledScroll.add(id2);
    if (this.disabledScroll.size === 1) {
      document.body.classList.add(BACKDROP_NO_SCROLL);
    }
  }
  enableScroll(id2) {
    this.disabledScroll.delete(id2);
    if (this.disabledScroll.size === 0) {
      document.body.classList.remove(BACKDROP_NO_SCROLL);
    }
  }
  canStart(gestureName) {
    if (this.capturedId !== void 0) {
      return false;
    }
    if (this.isDisabled(gestureName)) {
      return false;
    }
    return true;
  }
  isCaptured() {
    return this.capturedId !== void 0;
  }
  isScrollDisabled() {
    return this.disabledScroll.size > 0;
  }
  isDisabled(gestureName) {
    const disabled = this.disabledGestures.get(gestureName);
    if (disabled && disabled.size > 0) {
      return true;
    }
    return false;
  }
  newID() {
    this.gestureId++;
    return this.gestureId;
  }
}
class GestureDelegate {
  constructor(ctrl, id2, name, priority, disableScroll) {
    this.id = id2;
    this.name = name;
    this.disableScroll = disableScroll;
    this.priority = priority * 1e6 + id2;
    this.ctrl = ctrl;
  }
  canStart() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.canStart(this.name);
  }
  start() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.start(this.name, this.id, this.priority);
  }
  capture() {
    if (!this.ctrl) {
      return false;
    }
    const captured = this.ctrl.capture(this.name, this.id, this.priority);
    if (captured && this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
    return captured;
  }
  release() {
    if (this.ctrl) {
      this.ctrl.release(this.id);
      if (this.disableScroll) {
        this.ctrl.enableScroll(this.id);
      }
    }
  }
  destroy() {
    this.release();
    this.ctrl = void 0;
  }
}
class BlockerDelegate {
  constructor(ctrl, id2, disable, disableScroll) {
    this.id = id2;
    this.disable = disable;
    this.disableScroll = disableScroll;
    this.ctrl = ctrl;
  }
  block() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (const gesture of this.disable) {
        this.ctrl.disableGesture(gesture, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
  }
  unblock() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (const gesture of this.disable) {
        this.ctrl.enableGesture(gesture, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.enableScroll(this.id);
    }
  }
  destroy() {
    this.unblock();
    this.ctrl = void 0;
  }
}
const BACKDROP_NO_SCROLL = "backdrop-no-scroll";
const GESTURE_CONTROLLER = new GestureController();
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const addEventListener = (el2, eventName, callback, opts) => {
  const listenerOpts = supportsPassive(el2) ? {
    capture: !!opts.capture,
    passive: !!opts.passive
  } : !!opts.capture;
  let add;
  let remove;
  if (el2["__zone_symbol__addEventListener"]) {
    add = "__zone_symbol__addEventListener";
    remove = "__zone_symbol__removeEventListener";
  } else {
    add = "addEventListener";
    remove = "removeEventListener";
  }
  el2[add](eventName, callback, listenerOpts);
  return () => {
    el2[remove](eventName, callback, listenerOpts);
  };
};
const supportsPassive = (node) => {
  if (_sPassive === void 0) {
    try {
      const opts = Object.defineProperty({}, "passive", {
        get: () => {
          _sPassive = true;
        }
      });
      node.addEventListener("optsTest", () => {
        return;
      }, opts);
    } catch (e2) {
      _sPassive = false;
    }
  }
  return !!_sPassive;
};
let _sPassive;
const MOUSE_WAIT = 2e3;
const createPointerEvents = (el2, pointerDown, pointerMove, pointerUp, options) => {
  let rmTouchStart;
  let rmTouchMove;
  let rmTouchEnd;
  let rmTouchCancel;
  let rmMouseStart;
  let rmMouseMove;
  let rmMouseUp;
  let lastTouchEvent = 0;
  const handleTouchStart = (ev) => {
    lastTouchEvent = Date.now() + MOUSE_WAIT;
    if (!pointerDown(ev)) {
      return;
    }
    if (!rmTouchMove && pointerMove) {
      rmTouchMove = addEventListener(el2, "touchmove", pointerMove, options);
    }
    if (!rmTouchEnd) {
      rmTouchEnd = addEventListener(ev.target, "touchend", handleTouchEnd, options);
    }
    if (!rmTouchCancel) {
      rmTouchCancel = addEventListener(ev.target, "touchcancel", handleTouchEnd, options);
    }
  };
  const handleMouseDown = (ev) => {
    if (lastTouchEvent > Date.now()) {
      return;
    }
    if (!pointerDown(ev)) {
      return;
    }
    if (!rmMouseMove && pointerMove) {
      rmMouseMove = addEventListener(getDocument(el2), "mousemove", pointerMove, options);
    }
    if (!rmMouseUp) {
      rmMouseUp = addEventListener(getDocument(el2), "mouseup", handleMouseUp, options);
    }
  };
  const handleTouchEnd = (ev) => {
    stopTouch();
    if (pointerUp) {
      pointerUp(ev);
    }
  };
  const handleMouseUp = (ev) => {
    stopMouse();
    if (pointerUp) {
      pointerUp(ev);
    }
  };
  const stopTouch = () => {
    if (rmTouchMove) {
      rmTouchMove();
    }
    if (rmTouchEnd) {
      rmTouchEnd();
    }
    if (rmTouchCancel) {
      rmTouchCancel();
    }
    rmTouchMove = rmTouchEnd = rmTouchCancel = void 0;
  };
  const stopMouse = () => {
    if (rmMouseMove) {
      rmMouseMove();
    }
    if (rmMouseUp) {
      rmMouseUp();
    }
    rmMouseMove = rmMouseUp = void 0;
  };
  const stop = () => {
    stopTouch();
    stopMouse();
  };
  const enable = (isEnabled = true) => {
    if (!isEnabled) {
      if (rmTouchStart) {
        rmTouchStart();
      }
      if (rmMouseStart) {
        rmMouseStart();
      }
      rmTouchStart = rmMouseStart = void 0;
      stop();
    } else {
      if (!rmTouchStart) {
        rmTouchStart = addEventListener(el2, "touchstart", handleTouchStart, options);
      }
      if (!rmMouseStart) {
        rmMouseStart = addEventListener(el2, "mousedown", handleMouseDown, options);
      }
    }
  };
  const destroy = () => {
    enable(false);
    pointerUp = pointerMove = pointerDown = void 0;
  };
  return {
    enable,
    stop,
    destroy
  };
};
const getDocument = (node) => {
  return node instanceof Document ? node : node.ownerDocument;
};
const createPanRecognizer = (direction, thresh, maxAngle) => {
  const radians = maxAngle * (Math.PI / 180);
  const isDirX = direction === "x";
  const maxCosine = Math.cos(radians);
  const threshold = thresh * thresh;
  let startX = 0;
  let startY = 0;
  let dirty = false;
  let isPan = 0;
  return {
    start(x2, y2) {
      startX = x2;
      startY = y2;
      isPan = 0;
      dirty = true;
    },
    detect(x2, y2) {
      if (!dirty) {
        return false;
      }
      const deltaX = x2 - startX;
      const deltaY = y2 - startY;
      const distance = deltaX * deltaX + deltaY * deltaY;
      if (distance < threshold) {
        return false;
      }
      const hypotenuse = Math.sqrt(distance);
      const cosine = (isDirX ? deltaX : deltaY) / hypotenuse;
      if (cosine > maxCosine) {
        isPan = 1;
      } else if (cosine < -maxCosine) {
        isPan = -1;
      } else {
        isPan = 0;
      }
      dirty = false;
      return true;
    },
    isGesture() {
      return isPan !== 0;
    },
    getDirection() {
      return isPan;
    }
  };
};
const createGesture = (config2) => {
  let hasCapturedPan = false;
  let hasStartedPan = false;
  let hasFiredStart = true;
  let isMoveQueued = false;
  const finalConfig = Object.assign({ disableScroll: false, direction: "x", gesturePriority: 0, passive: true, maxAngle: 40, threshold: 10 }, config2);
  const canStart = finalConfig.canStart;
  const onWillStart = finalConfig.onWillStart;
  const onStart = finalConfig.onStart;
  const onEnd = finalConfig.onEnd;
  const notCaptured = finalConfig.notCaptured;
  const onMove = finalConfig.onMove;
  const threshold = finalConfig.threshold;
  const passive = finalConfig.passive;
  const blurOnStart = finalConfig.blurOnStart;
  const detail = {
    type: "pan",
    startX: 0,
    startY: 0,
    startTime: 0,
    currentX: 0,
    currentY: 0,
    velocityX: 0,
    velocityY: 0,
    deltaX: 0,
    deltaY: 0,
    currentTime: 0,
    event: void 0,
    data: void 0
  };
  const pan = createPanRecognizer(finalConfig.direction, finalConfig.threshold, finalConfig.maxAngle);
  const gesture = GESTURE_CONTROLLER.createGesture({
    name: config2.gestureName,
    priority: config2.gesturePriority,
    disableScroll: config2.disableScroll
  });
  const pointerDown = (ev) => {
    const timeStamp = now(ev);
    if (hasStartedPan || !hasFiredStart) {
      return false;
    }
    updateDetail(ev, detail);
    detail.startX = detail.currentX;
    detail.startY = detail.currentY;
    detail.startTime = detail.currentTime = timeStamp;
    detail.velocityX = detail.velocityY = detail.deltaX = detail.deltaY = 0;
    detail.event = ev;
    if (canStart && canStart(detail) === false) {
      return false;
    }
    gesture.release();
    if (!gesture.start()) {
      return false;
    }
    hasStartedPan = true;
    if (threshold === 0) {
      return tryToCapturePan();
    }
    pan.start(detail.startX, detail.startY);
    return true;
  };
  const pointerMove = (ev) => {
    if (hasCapturedPan) {
      if (!isMoveQueued && hasFiredStart) {
        isMoveQueued = true;
        calcGestureData(detail, ev);
        requestAnimationFrame(fireOnMove);
      }
      return;
    }
    calcGestureData(detail, ev);
    if (pan.detect(detail.currentX, detail.currentY)) {
      if (!pan.isGesture() || !tryToCapturePan()) {
        abortGesture();
      }
    }
  };
  const fireOnMove = () => {
    if (!hasCapturedPan) {
      return;
    }
    isMoveQueued = false;
    if (onMove) {
      onMove(detail);
    }
  };
  const tryToCapturePan = () => {
    if (!gesture.capture()) {
      return false;
    }
    hasCapturedPan = true;
    hasFiredStart = false;
    detail.startX = detail.currentX;
    detail.startY = detail.currentY;
    detail.startTime = detail.currentTime;
    if (onWillStart) {
      onWillStart(detail).then(fireOnStart);
    } else {
      fireOnStart();
    }
    return true;
  };
  const blurActiveElement = () => {
    if (typeof document !== "undefined") {
      const activeElement = document.activeElement;
      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur) {
        activeElement.blur();
      }
    }
  };
  const fireOnStart = () => {
    if (blurOnStart) {
      blurActiveElement();
    }
    if (onStart) {
      onStart(detail);
    }
    hasFiredStart = true;
  };
  const reset = () => {
    hasCapturedPan = false;
    hasStartedPan = false;
    isMoveQueued = false;
    hasFiredStart = true;
    gesture.release();
  };
  const pointerUp = (ev) => {
    const tmpHasCaptured = hasCapturedPan;
    const tmpHasFiredStart = hasFiredStart;
    reset();
    if (!tmpHasFiredStart) {
      return;
    }
    calcGestureData(detail, ev);
    if (tmpHasCaptured) {
      if (onEnd) {
        onEnd(detail);
      }
      return;
    }
    if (notCaptured) {
      notCaptured(detail);
    }
  };
  const pointerEvents = createPointerEvents(finalConfig.el, pointerDown, pointerMove, pointerUp, {
    capture: false,
    passive
  });
  const abortGesture = () => {
    reset();
    pointerEvents.stop();
    if (notCaptured) {
      notCaptured(detail);
    }
  };
  return {
    enable(enable = true) {
      if (!enable) {
        if (hasCapturedPan) {
          pointerUp(void 0);
        }
        reset();
      }
      pointerEvents.enable(enable);
    },
    destroy() {
      gesture.destroy();
      pointerEvents.destroy();
    }
  };
};
const calcGestureData = (detail, ev) => {
  if (!ev) {
    return;
  }
  const prevX = detail.currentX;
  const prevY = detail.currentY;
  const prevT = detail.currentTime;
  updateDetail(ev, detail);
  const currentX = detail.currentX;
  const currentY = detail.currentY;
  const timestamp = detail.currentTime = now(ev);
  const timeDelta = timestamp - prevT;
  if (timeDelta > 0 && timeDelta < 100) {
    const velocityX = (currentX - prevX) / timeDelta;
    const velocityY = (currentY - prevY) / timeDelta;
    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;
    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;
  }
  detail.deltaX = currentX - detail.startX;
  detail.deltaY = currentY - detail.startY;
  detail.event = ev;
};
const updateDetail = (ev, detail) => {
  let x2 = 0;
  let y2 = 0;
  if (ev) {
    const changedTouches = ev.changedTouches;
    if (changedTouches && changedTouches.length > 0) {
      const touch = changedTouches[0];
      x2 = touch.clientX;
      y2 = touch.clientY;
    } else if (ev.pageX !== void 0) {
      x2 = ev.pageX;
      y2 = ev.pageY;
    }
  }
  detail.currentX = x2;
  detail.currentY = y2;
};
const now = (ev) => {
  return ev.timeStamp || Date.now();
};
const index3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GESTURE_CONTROLLER,
  createGesture
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
class Config {
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  reset(configObj) {
    this.m = new Map(Object.entries(configObj));
  }
  get(key, fallback) {
    const value = this.m.get(key);
    return value !== void 0 ? value : fallback;
  }
  getBoolean(key, fallback = false) {
    const val = this.m.get(key);
    if (val === void 0) {
      return fallback;
    }
    if (typeof val === "string") {
      return val === "true";
    }
    return !!val;
  }
  getNumber(key, fallback) {
    const val = parseFloat(this.m.get(key));
    return isNaN(val) ? fallback !== void 0 ? fallback : NaN : val;
  }
  set(key, value) {
    this.m.set(key, value);
  }
}
const config$1 = /* @__PURE__ */ new Config();
const configFromSession = (win2) => {
  try {
    const configStr = win2.sessionStorage.getItem(IONIC_SESSION_KEY);
    return configStr !== null ? JSON.parse(configStr) : {};
  } catch (e2) {
    return {};
  }
};
const saveConfig = (win2, c2) => {
  try {
    win2.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(c2));
  } catch (e2) {
    return;
  }
};
const configFromURL = (win2) => {
  const configObj = {};
  win2.location.search.slice(1).split("&").map((entry) => entry.split("=")).map(([key, value]) => [decodeURIComponent(key), decodeURIComponent(value)]).filter(([key]) => startsWith(key, IONIC_PREFIX)).map(([key, value]) => [key.slice(IONIC_PREFIX.length), value]).forEach(([key, value]) => {
    configObj[key] = value;
  });
  return configObj;
};
const startsWith = (input, search2) => {
  return input.substr(0, search2.length) === search2;
};
const IONIC_PREFIX = "ionic:";
const IONIC_SESSION_KEY = "ionic-persist-config";
const getPlatforms = (win2) => setupPlatforms(win2);
const isPlatform = (winOrPlatform, platform2) => {
  if (typeof winOrPlatform === "string") {
    platform2 = winOrPlatform;
    winOrPlatform = void 0;
  }
  return getPlatforms(winOrPlatform).includes(platform2);
};
const setupPlatforms = (win2 = window) => {
  if (typeof win2 === "undefined") {
    return [];
  }
  win2.Ionic = win2.Ionic || {};
  let platforms = win2.Ionic.platforms;
  if (platforms == null) {
    platforms = win2.Ionic.platforms = detectPlatforms(win2);
    platforms.forEach((p2) => win2.document.documentElement.classList.add(`plt-${p2}`));
  }
  return platforms;
};
const detectPlatforms = (win2) => {
  const customPlatformMethods = config$1.get("platform");
  return Object.keys(PLATFORMS_MAP).filter((p2) => {
    const customMethod = customPlatformMethods === null || customPlatformMethods === void 0 ? void 0 : customPlatformMethods[p2];
    return typeof customMethod === "function" ? customMethod(win2) : PLATFORMS_MAP[p2](win2);
  });
};
const isMobileWeb = (win2) => isMobile(win2) && !isHybrid(win2);
const isIpad = (win2) => {
  if (testUserAgent(win2, /iPad/i)) {
    return true;
  }
  if (testUserAgent(win2, /Macintosh/i) && isMobile(win2)) {
    return true;
  }
  return false;
};
const isIphone = (win2) => testUserAgent(win2, /iPhone/i);
const isIOS = (win2) => testUserAgent(win2, /iPhone|iPod/i) || isIpad(win2);
const isAndroid = (win2) => testUserAgent(win2, /android|sink/i);
const isAndroidTablet = (win2) => {
  return isAndroid(win2) && !testUserAgent(win2, /mobile/i);
};
const isPhablet = (win2) => {
  const width = win2.innerWidth;
  const height = win2.innerHeight;
  const smallest = Math.min(width, height);
  const largest = Math.max(width, height);
  return smallest > 390 && smallest < 520 && largest > 620 && largest < 800;
};
const isTablet = (win2) => {
  const width = win2.innerWidth;
  const height = win2.innerHeight;
  const smallest = Math.min(width, height);
  const largest = Math.max(width, height);
  return isIpad(win2) || isAndroidTablet(win2) || smallest > 460 && smallest < 820 && largest > 780 && largest < 1400;
};
const isMobile = (win2) => matchMedia(win2, "(any-pointer:coarse)");
const isDesktop = (win2) => !isMobile(win2);
const isHybrid = (win2) => isCordova(win2) || isCapacitorNative(win2);
const isCordova = (win2) => !!(win2["cordova"] || win2["phonegap"] || win2["PhoneGap"]);
const isCapacitorNative = (win2) => {
  const capacitor = win2["Capacitor"];
  return !!(capacitor === null || capacitor === void 0 ? void 0 : capacitor.isNative);
};
const isElectron = (win2) => testUserAgent(win2, /electron/i);
const isPWA = (win2) => {
  var _a;
  return !!(((_a = win2.matchMedia) === null || _a === void 0 ? void 0 : _a.call(win2, "(display-mode: standalone)").matches) || win2.navigator.standalone);
};
const testUserAgent = (win2, expr) => expr.test(win2.navigator.userAgent);
const matchMedia = (win2, query) => {
  var _a;
  return (_a = win2.matchMedia) === null || _a === void 0 ? void 0 : _a.call(win2, query).matches;
};
const PLATFORMS_MAP = {
  ipad: isIpad,
  iphone: isIphone,
  ios: isIOS,
  android: isAndroid,
  phablet: isPhablet,
  tablet: isTablet,
  cordova: isCordova,
  capacitor: isCapacitorNative,
  electron: isElectron,
  pwa: isPWA,
  mobile: isMobile,
  mobileweb: isMobileWeb,
  desktop: isDesktop,
  hybrid: isHybrid
};
let defaultMode;
const getIonMode$2 = (ref) => {
  return ref && getMode(ref) || defaultMode;
};
const initialize = (userConfig = {}) => {
  if (typeof window === "undefined") {
    return;
  }
  const doc2 = window.document;
  const win2 = window;
  const Ionic = win2.Ionic = win2.Ionic || {};
  const platformHelpers = {};
  if (userConfig._ael) {
    platformHelpers.ael = userConfig._ael;
  }
  if (userConfig._rel) {
    platformHelpers.rel = userConfig._rel;
  }
  if (userConfig._ce) {
    platformHelpers.ce = userConfig._ce;
  }
  setPlatformHelpers(platformHelpers);
  const configObj = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(win2)), { persistConfig: false }), Ionic.config), configFromURL(win2)), userConfig);
  config$1.reset(configObj);
  if (config$1.getBoolean("persistConfig")) {
    saveConfig(win2, configObj);
  }
  setupPlatforms(win2);
  Ionic.config = config$1;
  Ionic.mode = defaultMode = config$1.get("mode", doc2.documentElement.getAttribute("mode") || (isPlatform(win2, "ios") ? "ios" : "md"));
  config$1.set("mode", defaultMode);
  doc2.documentElement.setAttribute("mode", defaultMode);
  doc2.documentElement.classList.add(defaultMode);
  if (config$1.getBoolean("_testing")) {
    config$1.set("animated", false);
  }
  const isIonicElement = (elm) => {
    var _a;
    return (_a = elm.tagName) === null || _a === void 0 ? void 0 : _a.startsWith("ION-");
  };
  const isAllowedIonicModeValue = (elmMode) => ["ios", "md"].includes(elmMode);
  setMode((elm) => {
    while (elm) {
      const elmMode = elm.mode || elm.getAttribute("mode");
      if (elmMode) {
        if (isAllowedIonicModeValue(elmMode)) {
          return elmMode;
        } else if (isIonicElement(elm)) {
          console.warn('Invalid ionic mode: "' + elmMode + '", expected: "ios" or "md"');
        }
      }
      elm = elm.parentElement;
    }
    return defaultMode;
  });
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const sanitizeDOMString = (untrustedString) => {
  try {
    if (untrustedString instanceof IonicSafeString) {
      return untrustedString.value;
    }
    if (!isSanitizerEnabled() || typeof untrustedString !== "string" || untrustedString === "") {
      return untrustedString;
    }
    if (untrustedString.includes("onload=")) {
      return "";
    }
    const documentFragment = document.createDocumentFragment();
    const workingDiv = document.createElement("div");
    documentFragment.appendChild(workingDiv);
    workingDiv.innerHTML = untrustedString;
    blockedTags.forEach((blockedTag) => {
      const getElementsToRemove = documentFragment.querySelectorAll(blockedTag);
      for (let elementIndex = getElementsToRemove.length - 1; elementIndex >= 0; elementIndex--) {
        const element = getElementsToRemove[elementIndex];
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        } else {
          documentFragment.removeChild(element);
        }
        const childElements = getElementChildren(element);
        for (let childIndex = 0; childIndex < childElements.length; childIndex++) {
          sanitizeElement(childElements[childIndex]);
        }
      }
    });
    const dfChildren = getElementChildren(documentFragment);
    for (let childIndex = 0; childIndex < dfChildren.length; childIndex++) {
      sanitizeElement(dfChildren[childIndex]);
    }
    const fragmentDiv = document.createElement("div");
    fragmentDiv.appendChild(documentFragment);
    const getInnerDiv = fragmentDiv.querySelector("div");
    return getInnerDiv !== null ? getInnerDiv.innerHTML : fragmentDiv.innerHTML;
  } catch (err) {
    console.error(err);
    return "";
  }
};
const sanitizeElement = (element) => {
  if (element.nodeType && element.nodeType !== 1) {
    return;
  }
  if (typeof NamedNodeMap !== "undefined" && !(element.attributes instanceof NamedNodeMap)) {
    element.remove();
    return;
  }
  for (let i = element.attributes.length - 1; i >= 0; i--) {
    const attribute = element.attributes.item(i);
    const attributeName = attribute.name;
    if (!allowedAttributes.includes(attributeName.toLowerCase())) {
      element.removeAttribute(attributeName);
      continue;
    }
    const attributeValue = attribute.value;
    const propertyValue = element[attributeName];
    if (attributeValue != null && attributeValue.toLowerCase().includes("javascript:") || propertyValue != null && propertyValue.toLowerCase().includes("javascript:")) {
      element.removeAttribute(attributeName);
    }
  }
  const childElements = getElementChildren(element);
  for (let i = 0; i < childElements.length; i++) {
    sanitizeElement(childElements[i]);
  }
};
const getElementChildren = (el2) => {
  return el2.children != null ? el2.children : el2.childNodes;
};
const isSanitizerEnabled = () => {
  var _a;
  const win2 = window;
  const config2 = (_a = win2 === null || win2 === void 0 ? void 0 : win2.Ionic) === null || _a === void 0 ? void 0 : _a.config;
  if (config2) {
    if (config2.get) {
      return config2.get("sanitizerEnabled", true);
    } else {
      return config2.sanitizerEnabled === true || config2.sanitizerEnabled === void 0;
    }
  }
  return true;
};
const allowedAttributes = ["class", "id", "href", "src", "name", "slot"];
const blockedTags = ["script", "style", "iframe", "meta", "link", "object", "embed"];
class IonicSafeString {
  constructor(value) {
    this.value = value;
  }
}
const ENABLE_HTML_CONTENT_DEFAULT = false;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el2) => {
  return el2.closest(selector) !== null;
};
const createColorClasses$2 = (color, cssClassMap) => {
  return typeof color === "string" && color.length > 0 ? Object.assign({ "ion-color": true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;
};
const getClassList = (classes) => {
  if (classes !== void 0) {
    const array = Array.isArray(classes) ? classes : classes.split(" ");
    return array.filter((c2) => c2 != null).map((c2) => c2.trim()).filter((c2) => c2 !== "");
  }
  return [];
};
const getClassMap = (classes) => {
  const map = {};
  getClassList(classes).forEach((c2) => map[c2] = true);
  return map;
};
const SCHEME = /^[a-z][a-z0-9+\-.]*:/;
const openURL = async (url, ev, direction, animation2) => {
  if (url != null && url[0] !== "#" && !SCHEME.test(url)) {
    const router = document.querySelector("ion-router");
    if (router) {
      if (ev != null) {
        ev.preventDefault();
      }
      return router.push(url, direction, animation2);
    }
  }
  return false;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const shoudUseCloseWatcher = () => config$1.get("experimentalCloseWatcher", false) && win$1 !== void 0 && "CloseWatcher" in win$1;
const blockHardwareBackButton = () => {
  document.addEventListener("backbutton", () => {
  });
};
const startHardwareBackButton = () => {
  const doc2 = document;
  let busy = false;
  const backButtonCallback = () => {
    if (busy) {
      return;
    }
    let index = 0;
    let handlers = [];
    const ev = new CustomEvent("ionBackButton", {
      bubbles: false,
      detail: {
        register(priority, handler) {
          handlers.push({ priority, handler, id: index++ });
        }
      }
    });
    doc2.dispatchEvent(ev);
    const executeAction = async (handlerRegister) => {
      try {
        if (handlerRegister === null || handlerRegister === void 0 ? void 0 : handlerRegister.handler) {
          const result = handlerRegister.handler(processHandlers);
          if (result != null) {
            await result;
          }
        }
      } catch (e2) {
        console.error(e2);
      }
    };
    const processHandlers = () => {
      if (handlers.length > 0) {
        let selectedHandler = {
          priority: Number.MIN_SAFE_INTEGER,
          handler: () => void 0,
          id: -1
        };
        handlers.forEach((handler) => {
          if (handler.priority >= selectedHandler.priority) {
            selectedHandler = handler;
          }
        });
        busy = true;
        handlers = handlers.filter((handler) => handler.id !== selectedHandler.id);
        executeAction(selectedHandler).then(() => busy = false);
      }
    };
    processHandlers();
  };
  if (shoudUseCloseWatcher()) {
    let watcher;
    const configureWatcher = () => {
      watcher === null || watcher === void 0 ? void 0 : watcher.destroy();
      watcher = new win$1.CloseWatcher();
      watcher.onclose = () => {
        backButtonCallback();
        configureWatcher();
      };
    };
    configureWatcher();
  } else {
    doc2.addEventListener("backbutton", backButtonCallback);
  }
};
const OVERLAY_BACK_BUTTON_PRIORITY = 100;
const MENU_BACK_BUTTON_PRIORITY = 99;
const hardwareBackButton = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MENU_BACK_BUTTON_PRIORITY,
  OVERLAY_BACK_BUTTON_PRIORITY,
  blockHardwareBackButton,
  shoudUseCloseWatcher,
  startHardwareBackButton
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const printIonWarning = (message, ...params) => {
  return console.warn(`[Ionic Warning]: ${message}`, ...params);
};
const printIonError = (message, ...params) => {
  return console.error(`[Ionic Error]: ${message}`, ...params);
};
const printRequiredElementError = (el2, ...targetSelectors) => {
  return console.error(`<${el2.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(" or ")}.`);
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const attachComponent = async (delegate, container, component, cssClasses, componentProps, inline) => {
  var _a;
  if (delegate) {
    return delegate.attachViewToDom(container, component, componentProps, cssClasses);
  }
  if (!inline && typeof component !== "string" && !(component instanceof HTMLElement)) {
    throw new Error("framework delegate is missing");
  }
  const el2 = typeof component === "string" ? (_a = container.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement(component) : component;
  if (cssClasses) {
    cssClasses.forEach((c2) => el2.classList.add(c2));
  }
  if (componentProps) {
    Object.assign(el2, componentProps);
  }
  container.appendChild(el2);
  await new Promise((resolve2) => componentOnReady(el2, resolve2));
  return el2;
};
const detachComponent = (delegate, element) => {
  if (element) {
    if (delegate) {
      const container = element.parentElement;
      return delegate.removeViewFromDom(container, element);
    }
    element.remove();
  }
  return Promise.resolve();
};
const CoreDelegate = () => {
  let BaseComponent;
  let Reference;
  const attachViewToDom = async (parentElement, userComponent, userComponentProps = {}, cssClasses = []) => {
    var _a, _b;
    BaseComponent = parentElement;
    let ChildComponent;
    if (userComponent) {
      const el2 = typeof userComponent === "string" ? (_a = BaseComponent.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement(userComponent) : userComponent;
      cssClasses.forEach((c2) => el2.classList.add(c2));
      Object.assign(el2, userComponentProps);
      BaseComponent.appendChild(el2);
      ChildComponent = el2;
      await new Promise((resolve2) => componentOnReady(el2, resolve2));
    } else if (BaseComponent.children.length > 0 && (BaseComponent.tagName === "ION-MODAL" || BaseComponent.tagName === "ION-POPOVER")) {
      const root = ChildComponent = BaseComponent.children[0];
      if (!root.classList.contains("ion-delegate-host")) {
        const el2 = (_b = BaseComponent.ownerDocument) === null || _b === void 0 ? void 0 : _b.createElement("div");
        el2.classList.add("ion-delegate-host");
        cssClasses.forEach((c2) => el2.classList.add(c2));
        el2.append(...BaseComponent.children);
        BaseComponent.appendChild(el2);
        ChildComponent = el2;
      }
    }
    const app = document.querySelector("ion-app") || document.body;
    Reference = document.createComment("ionic teleport");
    BaseComponent.parentNode.insertBefore(Reference, BaseComponent);
    app.appendChild(BaseComponent);
    return ChildComponent !== null && ChildComponent !== void 0 ? ChildComponent : BaseComponent;
  };
  const removeViewFromDom = () => {
    if (BaseComponent && Reference) {
      Reference.parentNode.insertBefore(BaseComponent, Reference);
      Reference.remove();
    }
    return Promise.resolve();
  };
  return { attachViewToDom, removeViewFromDom };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
let lastOverlayIndex = 0;
let lastId = 0;
const activeAnimations = /* @__PURE__ */ new WeakMap();
const prepareOverlay = (el2) => {
  if (typeof document !== "undefined") {
    connectListeners(document);
  }
  const overlayIndex = lastOverlayIndex++;
  el2.overlayIndex = overlayIndex;
};
const setOverlayId = (el2) => {
  if (!el2.hasAttribute("id")) {
    el2.id = `ion-overlay-${++lastId}`;
  }
  return el2.id;
};
const focusableQueryString = '[tabindex]:not([tabindex^="-"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^="-"]):not([hidden]):not([disabled]), textarea:not([tabindex^="-"]):not([hidden]):not([disabled]), button:not([tabindex^="-"]):not([hidden]):not([disabled]), select:not([tabindex^="-"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^="-"]):not([hidden]):not([disabled]), .ion-focusable[disabled="false"]:not([tabindex^="-"]):not([hidden])';
const focusFirstDescendant = (ref, overlay) => {
  let firstInput = ref.querySelector(focusableQueryString);
  const shadowRoot = firstInput === null || firstInput === void 0 ? void 0 : firstInput.shadowRoot;
  if (shadowRoot) {
    firstInput = shadowRoot.querySelector(focusableQueryString) || firstInput;
  }
  if (firstInput) {
    focusElement(firstInput);
  } else {
    overlay.focus();
  }
};
const isOverlayHidden = (overlay) => overlay.classList.contains("overlay-hidden");
const focusLastDescendant = (ref, overlay) => {
  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));
  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;
  const shadowRoot = lastInput === null || lastInput === void 0 ? void 0 : lastInput.shadowRoot;
  if (shadowRoot) {
    lastInput = shadowRoot.querySelector(focusableQueryString) || lastInput;
  }
  if (lastInput) {
    lastInput.focus();
  } else {
    overlay.focus();
  }
};
const trapKeyboardFocus = (ev, doc2) => {
  const lastOverlay = getPresentedOverlay(doc2, "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover");
  const target = ev.target;
  if (!lastOverlay || !target) {
    return;
  }
  if (lastOverlay.classList.contains("ion-disable-focus-trap")) {
    return;
  }
  const trapScopedFocus = () => {
    if (lastOverlay === target) {
      lastOverlay.lastFocus = void 0;
    } else {
      const overlayRoot = getElementRoot(lastOverlay);
      if (!overlayRoot.contains(target)) {
        return;
      }
      const overlayWrapper = overlayRoot.querySelector(".ion-overlay-wrapper");
      if (!overlayWrapper) {
        return;
      }
      if (overlayWrapper.contains(target) || target === overlayRoot.querySelector("ion-backdrop")) {
        lastOverlay.lastFocus = target;
      } else {
        const lastFocus = lastOverlay.lastFocus;
        focusFirstDescendant(overlayWrapper, lastOverlay);
        if (lastFocus === doc2.activeElement) {
          focusLastDescendant(overlayWrapper, lastOverlay);
        }
        lastOverlay.lastFocus = doc2.activeElement;
      }
    }
  };
  const trapShadowFocus = () => {
    if (lastOverlay.contains(target)) {
      lastOverlay.lastFocus = target;
    } else {
      const lastFocus = lastOverlay.lastFocus;
      focusFirstDescendant(lastOverlay, lastOverlay);
      if (lastFocus === doc2.activeElement) {
        focusLastDescendant(lastOverlay, lastOverlay);
      }
      lastOverlay.lastFocus = doc2.activeElement;
    }
  };
  if (lastOverlay.shadowRoot) {
    trapShadowFocus();
  } else {
    trapScopedFocus();
  }
};
const connectListeners = (doc2) => {
  if (lastOverlayIndex === 0) {
    lastOverlayIndex = 1;
    doc2.addEventListener("focus", (ev) => {
      trapKeyboardFocus(ev, doc2);
    }, true);
    doc2.addEventListener("ionBackButton", (ev) => {
      const lastOverlay = getPresentedOverlay(doc2);
      if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {
        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {
          lastOverlay.dismiss(void 0, BACKDROP);
        });
      }
    });
    if (!shoudUseCloseWatcher()) {
      doc2.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape") {
          const lastOverlay = getPresentedOverlay(doc2);
          if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {
            lastOverlay.dismiss(void 0, BACKDROP);
          }
        }
      });
    }
  }
};
const getOverlays = (doc2, selector) => {
  if (selector === void 0) {
    selector = "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast";
  }
  return Array.from(doc2.querySelectorAll(selector)).filter((c2) => c2.overlayIndex > 0);
};
const getPresentedOverlays = (doc2, overlayTag) => {
  return getOverlays(doc2, overlayTag).filter((o2) => !isOverlayHidden(o2));
};
const getPresentedOverlay = (doc2, overlayTag, id2) => {
  const overlays = getPresentedOverlays(doc2, overlayTag);
  return id2 === void 0 ? overlays[overlays.length - 1] : overlays.find((o2) => o2.id === id2);
};
const setRootAriaHidden = (hidden = false) => {
  const root = getAppRoot(document);
  const viewContainer = root.querySelector("ion-router-outlet, ion-nav, #ion-view-container-root");
  if (!viewContainer) {
    return;
  }
  if (hidden) {
    viewContainer.setAttribute("aria-hidden", "true");
  } else {
    viewContainer.removeAttribute("aria-hidden");
  }
};
const present = async (overlay, name, iosEnterAnimation2, mdEnterAnimation2, opts) => {
  var _a, _b;
  if (overlay.presented) {
    return;
  }
  setRootAriaHidden(true);
  if (doc !== void 0) {
    const presentedOverlays = getPresentedOverlays(doc);
    presentedOverlays.forEach((o2) => o2.setAttribute("aria-hidden", "true"));
  }
  overlay.presented = true;
  overlay.willPresent.emit();
  (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();
  const mode = getIonMode$2(overlay);
  const animationBuilder = overlay.enterAnimation ? overlay.enterAnimation : config$1.get(name, mode === "ios" ? iosEnterAnimation2 : mdEnterAnimation2);
  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
  if (completed) {
    overlay.didPresent.emit();
    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();
  }
  if (overlay.el.tagName !== "ION-TOAST") {
    restoreElementFocus(overlay.el);
  }
  if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {
    overlay.el.focus();
  }
  overlay.el.removeAttribute("aria-hidden");
};
const restoreElementFocus = async (overlayEl) => {
  let previousElement = document.activeElement;
  if (!previousElement) {
    return;
  }
  const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;
  if (shadowRoot) {
    previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;
  }
  await overlayEl.onDidDismiss();
  if (document.activeElement === null || document.activeElement === document.body) {
    previousElement.focus();
  }
};
const dismiss = async (overlay, data, role, name, iosLeaveAnimation2, mdLeaveAnimation2, opts) => {
  var _a, _b, _c;
  if (!overlay.presented) {
    return false;
  }
  if (doc !== void 0 && getPresentedOverlays(doc).length === 1) {
    setRootAriaHidden(false);
  }
  overlay.presented = false;
  try {
    overlay.el.style.setProperty("pointer-events", "none");
    overlay.willDismiss.emit({ data, role });
    (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });
    const mode = getIonMode$2(overlay);
    const animationBuilder = overlay.leaveAnimation ? overlay.leaveAnimation : config$1.get(name, mode === "ios" ? iosLeaveAnimation2 : mdLeaveAnimation2);
    if (role !== GESTURE) {
      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
    }
    overlay.didDismiss.emit({ data, role });
    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });
    const animations = activeAnimations.get(overlay) || [];
    animations.forEach((ani) => ani.destroy());
    activeAnimations.delete(overlay);
    overlay.el.classList.add("overlay-hidden");
    overlay.el.style.removeProperty("pointer-events");
    if (overlay.el.lastFocus !== void 0) {
      overlay.el.lastFocus = void 0;
    }
  } catch (err) {
    console.error(err);
  }
  overlay.el.remove();
  if (doc !== void 0) {
    (_c = getPresentedOverlay(doc)) === null || _c === void 0 ? void 0 : _c.removeAttribute("aria-hidden");
  }
  return true;
};
const getAppRoot = (doc2) => {
  return doc2.querySelector("ion-app") || doc2.body;
};
const overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {
  baseEl.classList.remove("overlay-hidden");
  const aniRoot = overlay.el;
  const animation2 = animationBuilder(aniRoot, opts);
  if (!overlay.animated || !config$1.getBoolean("animated", true)) {
    animation2.duration(0);
  }
  if (overlay.keyboardClose) {
    animation2.beforeAddWrite(() => {
      const activeElement = baseEl.ownerDocument.activeElement;
      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches("input,ion-input, ion-textarea")) {
        activeElement.blur();
      }
    });
  }
  const activeAni = activeAnimations.get(overlay) || [];
  activeAnimations.set(overlay, [...activeAni, animation2]);
  await animation2.play();
  return true;
};
const eventMethod = (element, eventName) => {
  let resolve2;
  const promise = new Promise((r2) => resolve2 = r2);
  onceEvent(element, eventName, (event) => {
    resolve2(event.detail);
  });
  return promise;
};
const onceEvent = (element, eventName, callback) => {
  const handler = (ev) => {
    removeEventListener(element, eventName, handler);
    callback(ev);
  };
  addEventListener$1(element, eventName, handler);
};
const isCancel = (role) => {
  return role === "cancel" || role === BACKDROP;
};
const defaultGate = (h2) => h2();
const safeCall = (handler, arg) => {
  if (typeof handler === "function") {
    const jmp = config$1.get("_zoneGate", defaultGate);
    return jmp(() => {
      try {
        return handler(arg);
      } catch (e2) {
        throw e2;
      }
    });
  }
  return void 0;
};
const BACKDROP = "backdrop";
const GESTURE = "gesture";
const OVERLAY_GESTURE_PRIORITY = 39;
const createDelegateController = (ref) => {
  let inline = false;
  let workingDelegate;
  const coreDelegate = CoreDelegate();
  const getDelegate = (force = false) => {
    if (workingDelegate && !force) {
      return {
        delegate: workingDelegate,
        inline
      };
    }
    const { el: el2, hasController, delegate } = ref;
    const parentEl = el2.parentNode;
    inline = parentEl !== null && !hasController;
    workingDelegate = inline ? delegate || coreDelegate : delegate;
    return { inline, delegate: workingDelegate };
  };
  const attachViewToDom = async (component) => {
    const { delegate } = getDelegate(true);
    if (delegate) {
      return await delegate.attachViewToDom(ref.el, component);
    }
    const { hasController } = ref;
    if (hasController && component !== void 0) {
      throw new Error("framework delegate is missing");
    }
    return null;
  };
  const removeViewFromDom = () => {
    const { delegate } = getDelegate();
    if (delegate && ref.el !== void 0) {
      delegate.removeViewFromDom(ref.el.parentElement, ref.el);
    }
  };
  return {
    attachViewToDom,
    removeViewFromDom
  };
};
const createTriggerController = () => {
  let destroyTriggerInteraction;
  const removeClickListener = () => {
    if (destroyTriggerInteraction) {
      destroyTriggerInteraction();
      destroyTriggerInteraction = void 0;
    }
  };
  const addClickListener = (el2, trigger) => {
    removeClickListener();
    const triggerEl = trigger !== void 0 ? document.getElementById(trigger) : null;
    if (!triggerEl) {
      printIonWarning(`A trigger element with the ID "${trigger}" was not found in the DOM. The trigger element must be in the DOM when the "trigger" property is set on an overlay component.`, el2);
      return;
    }
    const configureTriggerInteraction = (targetEl, overlayEl) => {
      const openOverlay = () => {
        overlayEl.present();
      };
      targetEl.addEventListener("click", openOverlay);
      return () => {
        targetEl.removeEventListener("click", openOverlay);
      };
    };
    destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el2);
  };
  return {
    addClickListener,
    removeClickListener
  };
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const arrowBackSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='square' stroke-miterlimit='10' stroke-width='48' d='M244 400L100 256l144-144M120 256h292' class='ionicon-fill-none'/></svg>";
const checkmarkOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M416 128L192 384l-96-96' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const chevronForward = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M184 112l144 144-144 144' class='ionicon-fill-none'/></svg>";
const closeCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm75.31 260.69a16 16 0 11-22.62 22.62L256 278.63l-52.69 52.68a16 16 0 01-22.62-22.62L233.37 256l-52.68-52.69a16 16 0 0122.62-22.62L256 233.37l52.69-52.68a16 16 0 0122.62 22.62L278.63 256z'/></svg>";
const closeSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M400 145.49L366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49z'/></svg>";
const ellipseOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><circle cx='256' cy='256' r='192' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const removeOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M400 256H112' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const searchOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M221.09 64a157.09 157.09 0 10157.09 157.09A157.1 157.1 0 00221.09 64z' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-miterlimit='10' d='M338.29 338.29L448 448' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const searchSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M464 428L339.92 303.9a160.48 160.48 0 0030.72-94.58C370.64 120.37 298.27 48 209.32 48S48 120.37 48 209.32s72.37 161.32 161.32 161.32a160.48 160.48 0 0094.58-30.72L428 464zM209.32 319.69a110.38 110.38 0 11110.37-110.37 110.5 110.5 0 01-110.37 110.37z'/></svg>";
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
let CACHED_MAP$1;
const getIconMap$1 = () => {
  if (typeof window === "undefined") {
    return /* @__PURE__ */ new Map();
  } else {
    if (!CACHED_MAP$1) {
      const win2 = window;
      win2.Ionicons = win2.Ionicons || {};
      CACHED_MAP$1 = win2.Ionicons.map = win2.Ionicons.map || /* @__PURE__ */ new Map();
    }
    return CACHED_MAP$1;
  }
};
const getUrl$1 = (i) => {
  let url = getSrc$1(i.src);
  if (url) {
    return url;
  }
  url = getName$1(i.name, i.icon, i.mode, i.ios, i.md);
  if (url) {
    return getNamedUrl$1(url, i);
  }
  if (i.icon) {
    url = getSrc$1(i.icon);
    if (url) {
      return url;
    }
    url = getSrc$1(i.icon[i.mode]);
    if (url) {
      return url;
    }
  }
  return null;
};
const getNamedUrl$1 = (iconName, iconEl) => {
  const url = getIconMap$1().get(iconName);
  if (url) {
    return url;
  }
  try {
    return getAssetPath(`svg/${iconName}.svg`);
  } catch (e2) {
    console.warn(`[Ionicons Warning]: Could not load icon with name "${iconName}". Ensure that the icon is registered using addIcons or that the icon SVG data is passed directly to the icon component.`, iconEl);
  }
};
const getName$1 = (iconName, icon, mode, ios, md2) => {
  mode = (mode && toLower$1(mode)) === "ios" ? "ios" : "md";
  if (ios && mode === "ios") {
    iconName = toLower$1(ios);
  } else if (md2 && mode === "md") {
    iconName = toLower$1(md2);
  } else {
    if (!iconName && icon && !isSrc$1(icon)) {
      iconName = icon;
    }
    if (isStr$1(iconName)) {
      iconName = toLower$1(iconName);
    }
  }
  if (!isStr$1(iconName) || iconName.trim() === "") {
    return null;
  }
  const invalidChars = iconName.replace(/[a-z]|-|\d/gi, "");
  if (invalidChars !== "") {
    return null;
  }
  return iconName;
};
const getSrc$1 = (src) => {
  if (isStr$1(src)) {
    src = src.trim();
    if (isSrc$1(src)) {
      return src;
    }
  }
  return null;
};
const isSrc$1 = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr$1 = (val) => typeof val === "string";
const toLower$1 = (val) => val.toLowerCase();
const inheritAttributes$1 = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const isRTL$2 = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
const validateContent$1 = (svgContent) => {
  const div = document.createElement("div");
  div.innerHTML = svgContent;
  for (let i = div.childNodes.length - 1; i >= 0; i--) {
    if (div.childNodes[i].nodeName.toLowerCase() !== "svg") {
      div.removeChild(div.childNodes[i]);
    }
  }
  const svgElm = div.firstElementChild;
  if (svgElm && svgElm.nodeName.toLowerCase() === "svg") {
    const svgClass = svgElm.getAttribute("class") || "";
    svgElm.setAttribute("class", (svgClass + " s-ion-icon").trim());
    if (isValid$1(svgElm)) {
      return div.innerHTML;
    }
  }
  return "";
};
const isValid$1 = (elm) => {
  if (elm.nodeType === 1) {
    if (elm.nodeName.toLowerCase() === "script") {
      return false;
    }
    for (let i = 0; i < elm.attributes.length; i++) {
      const name = elm.attributes[i].name;
      if (isStr$1(name) && name.toLowerCase().indexOf("on") === 0) {
        return false;
      }
    }
    for (let i = 0; i < elm.childNodes.length; i++) {
      if (!isValid$1(elm.childNodes[i])) {
        return false;
      }
    }
  }
  return true;
};
const isSvgDataUrl$1 = (url) => url.startsWith("data:image/svg+xml");
const isEncodedDataUrl$1 = (url) => url.indexOf(";utf8,") !== -1;
const ioniconContent$1 = /* @__PURE__ */ new Map();
const requests$1 = /* @__PURE__ */ new Map();
let parser$1;
const getSvgContent$1 = (url, sanitize) => {
  let req = requests$1.get(url);
  if (!req) {
    if (typeof fetch !== "undefined" && typeof document !== "undefined") {
      if (isSvgDataUrl$1(url) && isEncodedDataUrl$1(url)) {
        if (!parser$1) {
          parser$1 = new DOMParser();
        }
        const doc2 = parser$1.parseFromString(url, "text/html");
        const svg = doc2.querySelector("svg");
        if (svg) {
          ioniconContent$1.set(url, svg.outerHTML);
        }
        return Promise.resolve();
      } else {
        req = fetch(url).then((rsp) => {
          if (rsp.ok) {
            return rsp.text().then((svgContent) => {
              if (svgContent && sanitize !== false) {
                svgContent = validateContent$1(svgContent);
              }
              ioniconContent$1.set(url, svgContent || "");
            });
          }
          ioniconContent$1.set(url, "");
        });
        requests$1.set(url, req);
      }
    } else {
      ioniconContent$1.set(url, "");
      return Promise.resolve();
    }
  }
  return req;
};
const iconCss$1 = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}@supports (background: -webkit-named-image(i)){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}@supports not selector(:dir(rtl)) and selector(:host-context([dir='rtl'])){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}:host(.flip-rtl):host-context([dir='rtl']) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}@supports selector(:dir(rtl)){:host(.flip-rtl:dir(rtl)) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.flip-rtl:dir(ltr)) .icon-inner{-webkit-transform:scaleX(1);transform:scaleX(1)}}:host(.icon-small){font-size:1.125rem !important}:host(.icon-large){font-size:2rem !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";
const IonIconStyle0 = iconCss$1;
const Icon$1 = /* @__PURE__ */ proxyCustomElement(class Icon extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.iconName = null;
    this.inheritedAttributes = {};
    this.didLoadIcon = false;
    this.svgContent = void 0;
    this.isVisible = false;
    this.mode = getIonMode$1();
    this.color = void 0;
    this.ios = void 0;
    this.md = void 0;
    this.flipRtl = void 0;
    this.name = void 0;
    this.src = void 0;
    this.icon = void 0;
    this.size = void 0;
    this.lazy = false;
    this.sanitize = true;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes$1(this.el, ["aria-label"]);
  }
  connectedCallback() {
    this.waitUntilVisible(this.el, "50px", () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  componentDidLoad() {
    if (!this.didLoadIcon) {
      this.loadIcon();
    }
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  waitUntilVisible(el2, rootMargin, cb2) {
    if (this.lazy && typeof window !== "undefined" && window.IntersectionObserver) {
      const io = this.io = new window.IntersectionObserver((data) => {
        if (data[0].isIntersecting) {
          io.disconnect();
          this.io = void 0;
          cb2();
        }
      }, { rootMargin });
      io.observe(el2);
    } else {
      cb2();
    }
  }
  loadIcon() {
    if (this.isVisible) {
      const url = getUrl$1(this);
      if (url) {
        if (ioniconContent$1.has(url)) {
          this.svgContent = ioniconContent$1.get(url);
        } else {
          getSvgContent$1(url, this.sanitize).then(() => this.svgContent = ioniconContent$1.get(url));
        }
        this.didLoadIcon = true;
      }
    }
    this.iconName = getName$1(this.name, this.icon, this.mode, this.ios, this.md);
  }
  render() {
    const { flipRtl, iconName, inheritedAttributes, el: el2 } = this;
    const mode = this.mode || "md";
    const shouldAutoFlip = iconName ? (iconName.includes("arrow") || iconName.includes("chevron")) && flipRtl !== false : false;
    const shouldBeFlippable = flipRtl || shouldAutoFlip;
    return h$1(Host, Object.assign({ role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses$1(this.color)), { [`icon-${this.size}`]: !!this.size, "flip-rtl": shouldBeFlippable, "icon-rtl": shouldBeFlippable && isRTL$2(el2) }) }, inheritedAttributes), this.svgContent ? h$1("div", { class: "icon-inner", innerHTML: this.svgContent }) : h$1("div", { class: "icon-inner" }));
  }
  static get assetsDirs() {
    return ["svg"];
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "name": ["loadIcon"],
      "src": ["loadIcon"],
      "icon": ["loadIcon"],
      "ios": ["loadIcon"],
      "md": ["loadIcon"]
    };
  }
  static get style() {
    return IonIconStyle0;
  }
}, [1, "ion-icon", {
  "mode": [1025],
  "color": [1],
  "ios": [1],
  "md": [1],
  "flipRtl": [4, "flip-rtl"],
  "name": [513],
  "src": [1],
  "icon": [8],
  "size": [1],
  "lazy": [4],
  "sanitize": [4],
  "svgContent": [32],
  "isVisible": [32]
}, void 0, {
  "name": ["loadIcon"],
  "src": ["loadIcon"],
  "icon": ["loadIcon"],
  "ios": ["loadIcon"],
  "md": ["loadIcon"]
}]);
const getIonMode$1 = () => typeof document !== "undefined" && document.documentElement.getAttribute("mode") || "md";
const createColorClasses$1 = (color) => {
  return color ? {
    "ion-color": true,
    [`ion-color-${color}`]: true
  } : null;
};
function defineCustomElement$A() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-icon":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Icon$1);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const backdropIosCss = ":host{left:0;right:0;top:0;bottom:0;display:block;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);contain:strict;cursor:pointer;opacity:0.01;-ms-touch-action:none;touch-action:none;z-index:2}:host(.backdrop-hide){background:transparent}:host(.backdrop-no-tappable){cursor:auto}:host{background-color:var(--ion-backdrop-color, #000)}";
const IonBackdropIosStyle0 = backdropIosCss;
const backdropMdCss = ":host{left:0;right:0;top:0;bottom:0;display:block;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);contain:strict;cursor:pointer;opacity:0.01;-ms-touch-action:none;touch-action:none;z-index:2}:host(.backdrop-hide){background:transparent}:host(.backdrop-no-tappable){cursor:auto}:host{background-color:var(--ion-backdrop-color, #000)}";
const IonBackdropMdStyle0 = backdropMdCss;
const Backdrop = /* @__PURE__ */ proxyCustomElement(class Backdrop2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionBackdropTap = createEvent(this, "ionBackdropTap", 7);
    this.blocker = GESTURE_CONTROLLER.createBlocker({
      disableScroll: true
    });
    this.visible = true;
    this.tappable = true;
    this.stopPropagation = true;
  }
  connectedCallback() {
    if (this.stopPropagation) {
      this.blocker.block();
    }
  }
  disconnectedCallback() {
    this.blocker.unblock();
  }
  onMouseDown(ev) {
    this.emitTap(ev);
  }
  emitTap(ev) {
    if (this.stopPropagation) {
      ev.preventDefault();
      ev.stopPropagation();
    }
    if (this.tappable) {
      this.ionBackdropTap.emit();
    }
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "b2adb9dabef01fa49388d67d9e8a4a370931f633", tabindex: "-1", "aria-hidden": "true", class: {
      [mode]: true,
      "backdrop-hide": !this.visible,
      "backdrop-no-tappable": !this.tappable
    } });
  }
  static get style() {
    return {
      ios: IonBackdropIosStyle0,
      md: IonBackdropMdStyle0
    };
  }
}, [33, "ion-backdrop", {
  "visible": [4],
  "tappable": [4],
  "stopPropagation": [4, "stop-propagation"]
}, [[2, "click", "onMouseDown"]]]);
function defineCustomElement$z() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-backdrop"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Backdrop);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const buttonsIosCss = ".sc-ion-buttons-ios-h{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:99}.sc-ion-buttons-ios-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-ios-s ion-button{--padding-top:3px;--padding-bottom:3px;--padding-start:5px;--padding-end:5px;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;min-height:32px}.sc-ion-buttons-ios-s .button-has-icon-only{--padding-top:0;--padding-bottom:0}.sc-ion-buttons-ios-s ion-button:not(.button-round){--border-radius:4px}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button{--color:initial;--border-color:initial;--background-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-solid,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-solid{--background:var(--ion-color-contrast);--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12;--background-hover:var(--ion-color-base);--background-hover-opacity:0.45;--color:var(--ion-color-base);--color-focused:var(--ion-color-base)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-clear,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-clear{--color-activated:var(--ion-color-contrast);--color-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-outline,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-outline{--color-activated:var(--ion-color-base);--color-focused:var(--ion-color-contrast);--background-activated:var(--ion-color-contrast)}.sc-ion-buttons-ios-s .button-clear,.sc-ion-buttons-ios-s .button-outline{--background-activated:transparent;--background-focused:currentColor;--background-hover:transparent}.sc-ion-buttons-ios-s .button-solid:not(.ion-color){--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12}.sc-ion-buttons-ios-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:1.41em;line-height:0.67}.sc-ion-buttons-ios-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-start:0.4em;margin-inline-start:0.4em;font-size:1.41em;line-height:0.67}.sc-ion-buttons-ios-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:1.65em;line-height:0.67}";
const IonButtonsIosStyle0 = buttonsIosCss;
const buttonsMdCss = ".sc-ion-buttons-md-h{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:99}.sc-ion-buttons-md-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-md-s ion-button{--padding-top:3px;--padding-bottom:3px;--padding-start:8px;--padding-end:8px;--box-shadow:none;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;min-height:32px}.sc-ion-buttons-md-s .button-has-icon-only{--padding-top:0;--padding-bottom:0}.sc-ion-buttons-md-s ion-button:not(.button-round){--border-radius:2px}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button{--color:initial;--color-focused:var(--ion-color-contrast);--color-hover:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-contrast);--background-hover:var(--ion-color-contrast)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-solid,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-solid{--background:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-shade);--background-hover:var(--ion-color-base);--color:var(--ion-color-base);--color-focused:var(--ion-color-base);--color-hover:var(--ion-color-base)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-outline,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-outline{--border-color:var(--ion-color-contrast)}.sc-ion-buttons-md-s .button-has-icon-only.button-clear{--padding-top:12px;--padding-end:12px;--padding-bottom:12px;--padding-start:12px;--border-radius:50%;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;width:3rem;height:3rem}.sc-ion-buttons-md-s .button{--background-hover:currentColor}.sc-ion-buttons-md-s .button-solid{--color:var(--ion-toolbar-background, var(--ion-background-color, #fff));--background:var(--ion-toolbar-color, var(--ion-text-color, #424242));--background-activated:transparent;--background-focused:currentColor}.sc-ion-buttons-md-s .button-outline{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--border-color:currentColor}.sc-ion-buttons-md-s .button-clear{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor}.sc-ion-buttons-md-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:1.4em}.sc-ion-buttons-md-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-start:0.4em;margin-inline-start:0.4em;font-size:1.4em}.sc-ion-buttons-md-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:1.8em}";
const IonButtonsMdStyle0 = buttonsMdCss;
const Buttons = /* @__PURE__ */ proxyCustomElement(class Buttons2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.collapse = false;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "52c0c5535f5688a481746fe8fd92b6c02941526f", class: {
      [mode]: true,
      ["buttons-collapse"]: this.collapse
    } });
  }
  static get style() {
    return {
      ios: IonButtonsIosStyle0,
      md: IonButtonsMdStyle0
    };
  }
}, [34, "ion-buttons", {
  "collapse": [4]
}]);
function defineCustomElement$y() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-buttons"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-buttons":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Buttons);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$x = defineCustomElement$y;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const createLegacyFormController = (el2) => {
  const controlEl = el2;
  let legacyControl;
  const hasLegacyControl = () => {
    if (legacyControl === void 0) {
      const hasLabelProp = controlEl.label !== void 0 || hasLabelSlot(controlEl);
      const hasAriaLabelAttribute = controlEl.hasAttribute("aria-label") || // Shadow DOM form controls cannot use aria-labelledby
      controlEl.hasAttribute("aria-labelledby") && controlEl.shadowRoot === null;
      const legacyItemLabel = findItemLabel(controlEl);
      legacyControl = controlEl.legacy === true || !hasLabelProp && !hasAriaLabelAttribute && legacyItemLabel !== null;
    }
    return legacyControl;
  };
  return { hasLegacyControl };
};
const hasLabelSlot = (controlEl) => {
  if (NAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.querySelector('[slot="label"]') !== null) {
    return true;
  }
  if (UNNAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.textContent !== "") {
    return true;
  }
  return false;
};
const NAMED_LABEL_SLOT_COMPONENTS = ["ION-INPUT", "ION-TEXTAREA", "ION-SELECT", "ION-RANGE"];
const UNNAMED_LABEL_SLOT_COMPONENTS = ["ION-TOGGLE", "ION-CHECKBOX", "ION-RADIO"];
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const rippleEffectCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}:host(.unbounded){contain:layout size style}.ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;-webkit-animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;will-change:transform, opacity;pointer-events:none}.fade-out{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1));-webkit-animation:150ms fadeOutAnimation forwards;animation:150ms fadeOutAnimation forwards}@-webkit-keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@-webkit-keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@-webkit-keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}@keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}";
const IonRippleEffectStyle0 = rippleEffectCss;
const RippleEffect = /* @__PURE__ */ proxyCustomElement(class RippleEffect2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.type = "bounded";
  }
  /**
   * Adds the ripple effect to the parent element.
   *
   * @param x The horizontal coordinate of where the ripple should start.
   * @param y The vertical coordinate of where the ripple should start.
   */
  async addRipple(x2, y2) {
    return new Promise((resolve2) => {
      readTask(() => {
        const rect = this.el.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        const hypotenuse = Math.sqrt(width * width + height * height);
        const maxDim = Math.max(height, width);
        const maxRadius = this.unbounded ? maxDim : hypotenuse + PADDING;
        const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);
        const finalScale = maxRadius / initialSize;
        let posX = x2 - rect.left;
        let posY = y2 - rect.top;
        if (this.unbounded) {
          posX = width * 0.5;
          posY = height * 0.5;
        }
        const styleX = posX - initialSize * 0.5;
        const styleY = posY - initialSize * 0.5;
        const moveX = width * 0.5 - posX;
        const moveY = height * 0.5 - posY;
        writeTask(() => {
          const div = document.createElement("div");
          div.classList.add("ripple-effect");
          const style = div.style;
          style.top = styleY + "px";
          style.left = styleX + "px";
          style.width = style.height = initialSize + "px";
          style.setProperty("--final-scale", `${finalScale}`);
          style.setProperty("--translate-end", `${moveX}px, ${moveY}px`);
          const container = this.el.shadowRoot || this.el;
          container.appendChild(div);
          setTimeout(() => {
            resolve2(() => {
              removeRipple(div);
            });
          }, 225 + 100);
        });
      });
    });
  }
  get unbounded() {
    return this.type === "unbounded";
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "a9ff1956627908ee4071002ca018eaa80f87cd59", role: "presentation", class: {
      [mode]: true,
      unbounded: this.unbounded
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return IonRippleEffectStyle0;
  }
}, [1, "ion-ripple-effect", {
  "type": [1],
  "addRipple": [64]
}]);
const removeRipple = (ripple) => {
  ripple.classList.add("fade-out");
  setTimeout(() => {
    ripple.remove();
  }, 200);
};
const PADDING = 10;
const INITIAL_ORIGIN_SCALE = 0.5;
function defineCustomElement$w() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RippleEffect);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const SIZE_TO_MEDIA = {
  xs: "(min-width: 0px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)"
};
const matchBreakpoint = (breakpoint) => {
  if (breakpoint === void 0 || breakpoint === "") {
    return true;
  }
  if (window.matchMedia) {
    const mediaQuery = SIZE_TO_MEDIA[breakpoint];
    return window.matchMedia(mediaQuery).matches;
  }
  return false;
};
const colCss = ":host{-webkit-padding-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;width:100%;max-width:100%;min-height:1px}@media (min-width: 576px){:host{-webkit-padding-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px))}}@media (min-width: 768px){:host{-webkit-padding-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px))}}@media (min-width: 992px){:host{-webkit-padding-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px))}}@media (min-width: 1200px){:host{-webkit-padding-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px))}}";
const IonColStyle0 = colCss;
const win = typeof window !== "undefined" ? window : void 0;
const SUPPORTS_VARS = win && !!(win.CSS && win.CSS.supports && win.CSS.supports("--a: 0"));
const BREAKPOINTS = ["", "xs", "sm", "md", "lg", "xl"];
const Col = /* @__PURE__ */ proxyCustomElement(class Col2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.offset = void 0;
    this.offsetXs = void 0;
    this.offsetSm = void 0;
    this.offsetMd = void 0;
    this.offsetLg = void 0;
    this.offsetXl = void 0;
    this.pull = void 0;
    this.pullXs = void 0;
    this.pullSm = void 0;
    this.pullMd = void 0;
    this.pullLg = void 0;
    this.pullXl = void 0;
    this.push = void 0;
    this.pushXs = void 0;
    this.pushSm = void 0;
    this.pushMd = void 0;
    this.pushLg = void 0;
    this.pushXl = void 0;
    this.size = void 0;
    this.sizeXs = void 0;
    this.sizeSm = void 0;
    this.sizeMd = void 0;
    this.sizeLg = void 0;
    this.sizeXl = void 0;
  }
  onResize() {
    forceUpdate(this);
  }
  // Loop through all of the breakpoints to see if the media query
  // matches and grab the column value from the relevant prop if so
  getColumns(property) {
    let matched;
    for (const breakpoint of BREAKPOINTS) {
      const matches2 = matchBreakpoint(breakpoint);
      const columns = this[property + breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)];
      if (matches2 && columns !== void 0) {
        matched = columns;
      }
    }
    return matched;
  }
  calculateSize() {
    const columns = this.getColumns("size");
    if (!columns || columns === "") {
      return;
    }
    const colSize = columns === "auto" ? "auto" : (
      // If CSS supports variables we should use the grid columns var
      SUPPORTS_VARS ? `calc(calc(${columns} / var(--ion-grid-columns, 12)) * 100%)` : (
        // Convert the columns to a percentage by dividing by the total number
        // of columns (12) and then multiplying by 100
        columns / 12 * 100 + "%"
      )
    );
    return {
      flex: `0 0 ${colSize}`,
      width: `${colSize}`,
      "max-width": `${colSize}`
    };
  }
  // Called by push, pull, and offset since they use the same calculations
  calculatePosition(property, modifier) {
    const columns = this.getColumns(property);
    if (!columns) {
      return;
    }
    const amount = SUPPORTS_VARS ? (
      // If CSS supports variables we should use the grid columns var
      `calc(calc(${columns} / var(--ion-grid-columns, 12)) * 100%)`
    ) : (
      // Convert the columns to a percentage by dividing by the total number
      // of columns (12) and then multiplying by 100
      columns > 0 && columns < 12 ? columns / 12 * 100 + "%" : "auto"
    );
    return {
      [modifier]: amount
    };
  }
  calculateOffset(isRTL2) {
    return this.calculatePosition("offset", isRTL2 ? "margin-right" : "margin-left");
  }
  calculatePull(isRTL2) {
    return this.calculatePosition("pull", isRTL2 ? "left" : "right");
  }
  calculatePush(isRTL2) {
    return this.calculatePosition("push", isRTL2 ? "right" : "left");
  }
  render() {
    const isRTL2 = document.dir === "rtl";
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "c186972dd12d10a4600975c326f20666fed96abf", class: {
      [mode]: true
    }, style: Object.assign(Object.assign(Object.assign(Object.assign({}, this.calculateOffset(isRTL2)), this.calculatePull(isRTL2)), this.calculatePush(isRTL2)), this.calculateSize()) }, h$1("slot", { key: "54cc8bd92f94cfd30d9f3e8e59e0f0dc38abfd63" }));
  }
  static get style() {
    return IonColStyle0;
  }
}, [1, "ion-col", {
  "offset": [1],
  "offsetXs": [1, "offset-xs"],
  "offsetSm": [1, "offset-sm"],
  "offsetMd": [1, "offset-md"],
  "offsetLg": [1, "offset-lg"],
  "offsetXl": [1, "offset-xl"],
  "pull": [1],
  "pullXs": [1, "pull-xs"],
  "pullSm": [1, "pull-sm"],
  "pullMd": [1, "pull-md"],
  "pullLg": [1, "pull-lg"],
  "pullXl": [1, "pull-xl"],
  "push": [1],
  "pushXs": [1, "push-xs"],
  "pushSm": [1, "push-sm"],
  "pushMd": [1, "push-md"],
  "pushLg": [1, "push-lg"],
  "pushXl": [1, "push-xl"],
  "size": [1],
  "sizeXs": [1, "size-xs"],
  "sizeSm": [1, "size-sm"],
  "sizeMd": [1, "size-md"],
  "sizeLg": [1, "size-lg"],
  "sizeXl": [1, "size-xl"]
}, [[9, "resize", "onResize"]]]);
function defineCustomElement$1$j() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-col"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-col":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Col);
        }
        break;
    }
  });
}
const defineCustomElement$v = defineCustomElement$1$j;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const isRTL$1 = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const contentCss = ':host{--background:var(--ion-background-color, #fff);--color:var(--ion-text-color, #000);--padding-top:0px;--padding-bottom:0px;--padding-start:0px;--padding-end:0px;--keyboard-offset:0px;--offset-top:0px;--offset-bottom:0px;--overflow:auto;display:block;position:relative;-ms-flex:1;flex:1;width:100%;height:100%;margin:0 !important;padding:0 !important;font-family:var(--ion-font-family, inherit);contain:size style}:host(.ion-color) .inner-scroll{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.outer-content){--background:var(--ion-color-step-50, #f2f2f2)}#background-content{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);position:absolute;background:var(--background)}.inner-scroll{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:calc(var(--padding-top) + var(--offset-top));padding-bottom:calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));position:absolute;color:var(--color);-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;-ms-touch-action:pan-x pan-y pinch-zoom;touch-action:pan-x pan-y pinch-zoom}.scroll-y,.scroll-x{-webkit-overflow-scrolling:touch;z-index:0;will-change:scroll-position}.scroll-y{overflow-y:var(--overflow);overscroll-behavior-y:contain}.scroll-x{overflow-x:var(--overflow);overscroll-behavior-x:contain}.overscroll::before,.overscroll::after{position:absolute;width:1px;height:1px;content:""}.overscroll::before{bottom:-1px}.overscroll::after{top:-1px}:host(.content-sizing){display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-height:0;contain:none}:host(.content-sizing) .inner-scroll{position:relative;top:0;bottom:0;margin-top:calc(var(--offset-top) * -1);margin-bottom:calc(var(--offset-bottom) * -1)}.transition-effect{display:none;position:absolute;width:100%;height:100vh;opacity:0;pointer-events:none}:host(.content-ltr) .transition-effect{left:-100%;}:host(.content-rtl) .transition-effect{right:-100%;}.transition-cover{position:absolute;right:0;width:100%;height:100%;background:black;opacity:0.1}.transition-shadow{display:block;position:absolute;width:100%;height:100%;-webkit-box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03);box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03)}:host(.content-ltr) .transition-shadow{right:0;}:host(.content-rtl) .transition-shadow{left:0;-webkit-transform:scaleX(-1);transform:scaleX(-1)}::slotted([slot=fixed]){position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0)}';
const IonContentStyle0 = contentCss;
const Content = /* @__PURE__ */ proxyCustomElement(class Content2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionScrollStart = createEvent(this, "ionScrollStart", 7);
    this.ionScroll = createEvent(this, "ionScroll", 7);
    this.ionScrollEnd = createEvent(this, "ionScrollEnd", 7);
    this.watchDog = null;
    this.isScrolling = false;
    this.lastScroll = 0;
    this.queued = false;
    this.cTop = -1;
    this.cBottom = -1;
    this.isMainContent = true;
    this.resizeTimeout = null;
    this.tabsElement = null;
    this.detail = {
      scrollTop: 0,
      scrollLeft: 0,
      type: "scroll",
      event: void 0,
      startX: 0,
      startY: 0,
      startTime: 0,
      currentX: 0,
      currentY: 0,
      velocityX: 0,
      velocityY: 0,
      deltaX: 0,
      deltaY: 0,
      currentTime: 0,
      data: void 0,
      isScrolling: true
    };
    this.color = void 0;
    this.fullscreen = false;
    this.forceOverscroll = void 0;
    this.scrollX = false;
    this.scrollY = true;
    this.scrollEvents = false;
  }
  connectedCallback() {
    this.isMainContent = this.el.closest("ion-menu, ion-popover, ion-modal") === null;
    if (hasLazyBuild(this.el)) {
      const closestTabs = this.tabsElement = this.el.closest("ion-tabs");
      if (closestTabs !== null) {
        this.tabsLoadCallback = () => this.resize();
        closestTabs.addEventListener("ionTabBarLoaded", this.tabsLoadCallback);
      }
    }
  }
  disconnectedCallback() {
    this.onScrollEnd();
    if (hasLazyBuild(this.el)) {
      const { tabsElement, tabsLoadCallback } = this;
      if (tabsElement !== null && tabsLoadCallback !== void 0) {
        tabsElement.removeEventListener("ionTabBarLoaded", tabsLoadCallback);
      }
      this.tabsElement = null;
      this.tabsLoadCallback = void 0;
    }
  }
  /**
   * Rotating certain devices can update
   * the safe area insets. As a result,
   * the fullscreen feature on ion-content
   * needs to be recalculated.
   *
   * We listen for "resize" because we
   * do not care what the orientation of
   * the device is. Other APIs
   * such as ScreenOrientation or
   * the deviceorientation event must have
   * permission from the user first whereas
   * the "resize" event does not.
   *
   * We also throttle the callback to minimize
   * thrashing when quickly resizing a window.
   */
  onResize() {
    if (this.resizeTimeout) {
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = null;
    }
    this.resizeTimeout = setTimeout(() => {
      if (this.el.offsetParent === null) {
        return;
      }
      this.resize();
    }, 100);
  }
  shouldForceOverscroll() {
    const { forceOverscroll } = this;
    const mode = getIonMode$2(this);
    return forceOverscroll === void 0 ? mode === "ios" && isPlatform("ios") : forceOverscroll;
  }
  resize() {
    {
      if (this.fullscreen) {
        readTask(() => this.readDimensions());
      } else if (this.cTop !== 0 || this.cBottom !== 0) {
        this.cTop = this.cBottom = 0;
        forceUpdate(this);
      }
    }
  }
  readDimensions() {
    const page = getPageElement(this.el);
    const top = Math.max(this.el.offsetTop, 0);
    const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);
    const dirty = top !== this.cTop || bottom !== this.cBottom;
    if (dirty) {
      this.cTop = top;
      this.cBottom = bottom;
      forceUpdate(this);
    }
  }
  onScroll(ev) {
    const timeStamp = Date.now();
    const shouldStart = !this.isScrolling;
    this.lastScroll = timeStamp;
    if (shouldStart) {
      this.onScrollStart();
    }
    if (!this.queued && this.scrollEvents) {
      this.queued = true;
      readTask((ts) => {
        this.queued = false;
        this.detail.event = ev;
        updateScrollDetail(this.detail, this.scrollEl, ts, shouldStart);
        this.ionScroll.emit(this.detail);
      });
    }
  }
  /**
   * Get the element where the actual scrolling takes place.
   * This element can be used to subscribe to `scroll` events or manually modify
   * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:
   *
   * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events
   * and `scrollToPoint()` to scroll the content into a certain point.
   */
  async getScrollElement() {
    if (!this.scrollEl) {
      await new Promise((resolve2) => componentOnReady(this.el, resolve2));
    }
    return Promise.resolve(this.scrollEl);
  }
  /**
   * Returns the background content element.
   * @internal
   */
  async getBackgroundElement() {
    if (!this.backgroundContentEl) {
      await new Promise((resolve2) => componentOnReady(this.el, resolve2));
    }
    return Promise.resolve(this.backgroundContentEl);
  }
  /**
   * Scroll to the top of the component.
   *
   * @param duration The amount of time to take scrolling to the top. Defaults to `0`.
   */
  scrollToTop(duration = 0) {
    return this.scrollToPoint(void 0, 0, duration);
  }
  /**
   * Scroll to the bottom of the component.
   *
   * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.
   */
  async scrollToBottom(duration = 0) {
    const scrollEl = await this.getScrollElement();
    const y2 = scrollEl.scrollHeight - scrollEl.clientHeight;
    return this.scrollToPoint(void 0, y2, duration);
  }
  /**
   * Scroll by a specified X/Y distance in the component.
   *
   * @param x The amount to scroll by on the horizontal axis.
   * @param y The amount to scroll by on the vertical axis.
   * @param duration The amount of time to take scrolling by that amount.
   */
  async scrollByPoint(x2, y2, duration) {
    const scrollEl = await this.getScrollElement();
    return this.scrollToPoint(x2 + scrollEl.scrollLeft, y2 + scrollEl.scrollTop, duration);
  }
  /**
   * Scroll to a specified X/Y location in the component.
   *
   * @param x The point to scroll to on the horizontal axis.
   * @param y The point to scroll to on the vertical axis.
   * @param duration The amount of time to take scrolling to that point. Defaults to `0`.
   */
  async scrollToPoint(x2, y2, duration = 0) {
    const el2 = await this.getScrollElement();
    if (duration < 32) {
      if (y2 != null) {
        el2.scrollTop = y2;
      }
      if (x2 != null) {
        el2.scrollLeft = x2;
      }
      return;
    }
    let resolve2;
    let startTime2 = 0;
    const promise = new Promise((r2) => resolve2 = r2);
    const fromY = el2.scrollTop;
    const fromX = el2.scrollLeft;
    const deltaY = y2 != null ? y2 - fromY : 0;
    const deltaX = x2 != null ? x2 - fromX : 0;
    const step = (timeStamp) => {
      const linearTime = Math.min(1, (timeStamp - startTime2) / duration) - 1;
      const easedT = Math.pow(linearTime, 3) + 1;
      if (deltaY !== 0) {
        el2.scrollTop = Math.floor(easedT * deltaY + fromY);
      }
      if (deltaX !== 0) {
        el2.scrollLeft = Math.floor(easedT * deltaX + fromX);
      }
      if (easedT < 1) {
        requestAnimationFrame(step);
      } else {
        resolve2();
      }
    };
    requestAnimationFrame((ts) => {
      startTime2 = ts;
      step(ts);
    });
    return promise;
  }
  onScrollStart() {
    this.isScrolling = true;
    this.ionScrollStart.emit({
      isScrolling: true
    });
    if (this.watchDog) {
      clearInterval(this.watchDog);
    }
    this.watchDog = setInterval(() => {
      if (this.lastScroll < Date.now() - 120) {
        this.onScrollEnd();
      }
    }, 100);
  }
  onScrollEnd() {
    if (this.watchDog)
      clearInterval(this.watchDog);
    this.watchDog = null;
    if (this.isScrolling) {
      this.isScrolling = false;
      this.ionScrollEnd.emit({
        isScrolling: false
      });
    }
  }
  render() {
    const { isMainContent, scrollX, scrollY, el: el2 } = this;
    const rtl = isRTL$1(el2) ? "rtl" : "ltr";
    const mode = getIonMode$2(this);
    const forceOverscroll = this.shouldForceOverscroll();
    const transitionShadow = mode === "ios";
    const TagType = isMainContent ? "main" : "div";
    this.resize();
    return h$1(Host, { key: "65d85e1f7f85876a76eec79addc4bd9f697a5d84", class: createColorClasses$2(this.color, {
      [mode]: true,
      "content-sizing": hostContext("ion-popover", this.el),
      overscroll: forceOverscroll,
      [`content-${rtl}`]: true
    }), style: {
      "--offset-top": `${this.cTop}px`,
      "--offset-bottom": `${this.cBottom}px`
    } }, h$1("div", { key: "e2ac474a62cbc864772c497469100436f41289ff", ref: (el3) => this.backgroundContentEl = el3, id: "background-content", part: "background" }), h$1(TagType, { key: "567a4bc2bcb13adfd987b088f95ac4b20b789f2c", class: {
      "inner-scroll": true,
      "scroll-x": scrollX,
      "scroll-y": scrollY,
      overscroll: (scrollX || scrollY) && forceOverscroll
    }, ref: (scrollEl) => this.scrollEl = scrollEl, onScroll: this.scrollEvents ? (ev) => this.onScroll(ev) : void 0, part: "scroll" }, h$1("slot", { key: "13909f87dd9f49bf1664ad95038499da376b9480" })), transitionShadow ? h$1("div", { class: "transition-effect" }, h$1("div", { class: "transition-cover" }), h$1("div", { class: "transition-shadow" })) : null, h$1("slot", { key: "05b56c139e203cfd1e3dd08054e99328e97e9243", name: "fixed" }));
  }
  get el() {
    return this;
  }
  static get style() {
    return IonContentStyle0;
  }
}, [1, "ion-content", {
  "color": [513],
  "fullscreen": [4],
  "forceOverscroll": [1028, "force-overscroll"],
  "scrollX": [4, "scroll-x"],
  "scrollY": [4, "scroll-y"],
  "scrollEvents": [4, "scroll-events"],
  "getScrollElement": [64],
  "getBackgroundElement": [64],
  "scrollToTop": [64],
  "scrollToBottom": [64],
  "scrollByPoint": [64],
  "scrollToPoint": [64]
}, [[9, "resize", "onResize"]]]);
const getParentElement = (el2) => {
  var _a;
  if (el2.parentElement) {
    return el2.parentElement;
  }
  if ((_a = el2.parentNode) === null || _a === void 0 ? void 0 : _a.host) {
    return el2.parentNode.host;
  }
  return null;
};
const getPageElement = (el2) => {
  const tabs = el2.closest("ion-tabs");
  if (tabs) {
    return tabs;
  }
  const page = el2.closest("ion-app, ion-page, .ion-page, page-inner, .popover-content");
  if (page) {
    return page;
  }
  return getParentElement(el2);
};
const updateScrollDetail = (detail, el2, timestamp, shouldStart) => {
  const prevX = detail.currentX;
  const prevY = detail.currentY;
  const prevT = detail.currentTime;
  const currentX = el2.scrollLeft;
  const currentY = el2.scrollTop;
  const timeDelta = timestamp - prevT;
  if (shouldStart) {
    detail.startTime = timestamp;
    detail.startX = currentX;
    detail.startY = currentY;
    detail.velocityX = detail.velocityY = 0;
  }
  detail.currentTime = timestamp;
  detail.currentX = detail.scrollLeft = currentX;
  detail.currentY = detail.scrollTop = currentY;
  detail.deltaX = currentX - detail.startX;
  detail.deltaY = currentY - detail.startY;
  if (timeDelta > 0 && timeDelta < 100) {
    const velocityX = (currentX - prevX) / timeDelta;
    const velocityY = (currentY - prevY) / timeDelta;
    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;
    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;
  }
};
function defineCustomElement$1$i() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-content"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-content":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Content);
        }
        break;
    }
  });
}
const defineCustomElement$u = defineCustomElement$1$i;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const buttonIosCss = ':host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;height:100%;min-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted([slot=start]),::slotted([slot=end]){-ms-flex-negative:0;flex-shrink:0}::slotted(ion-icon){font-size:1.35em;pointer-events:none}::slotted(ion-icon[slot=start]){-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=end]){-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host(.button-outline.ion-activated.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--color));color:var(--ion-toolbar-background, var(--background), var(--ion-color-primary-contrast, #fff))}:host{--border-radius:14px;--padding-top:13px;--padding-bottom:13px;--padding-start:1em;--padding-end:1em;--transition:background-color, opacity 100ms linear;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;margin-top:4px;margin-bottom:4px;min-height:3.1em;font-size:min(1rem, 48px);font-weight:500;letter-spacing:0}:host(.button-solid){--background-activated:var(--ion-color-primary-shade, #3171e0);--background-focused:var(--ion-color-primary-shade, #3171e0);--background-hover:var(--ion-color-primary-tint, #4c8dff);--background-activated-opacity:1;--background-focused-opacity:1;--background-hover-opacity:1}:host(.button-outline){--border-radius:14px;--border-width:1px;--border-style:solid;--background-activated:var(--ion-color-primary, #3880ff);--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;--color-activated:var(--ion-color-primary-contrast, #fff)}:host(.button-clear){--background-activated:transparent;--background-activated-opacity:0;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;font-size:min(1.0625rem, 51px);font-weight:normal}:host(.in-buttons){font-size:clamp(17px, 1.0625rem, 21.08px);font-weight:400}:host(.button-large){--border-radius:16px;--padding-top:17px;--padding-start:1em;--padding-end:1em;--padding-bottom:17px;min-height:3.1em;font-size:min(1.25rem, 60px)}:host(.button-small){--border-radius:6px;--padding-top:4px;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:4px;min-height:2.1em;font-size:min(0.8125rem, 39px)}:host(.button-has-icon-only){--padding-top:0;--padding-bottom:0}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-strong){font-weight:600}:host(.button-outline.ion-focused.ion-color) .button-native,:host(.button-clear.ion-focused.ion-color) .button-native{color:var(--ion-color-base)}:host(.button-outline.ion-focused.ion-color) .button-native::after,:host(.button-clear.ion-focused.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-shade)}@media (any-hover: hover){:host(.button-clear:not(.ion-activated):hover),:host(.button-outline:not(.ion-activated):hover){opacity:0.6}:host(.button-clear.ion-color:hover) .button-native,:host(.button-outline.ion-color:hover) .button-native{color:var(--ion-color-base)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:transparent}:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-tint)}:host(:hover.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color):not(.ion-activated)) .button-native::after{background:#fff;opacity:0.1}}:host(.button-clear.ion-activated){opacity:0.4}:host(.button-outline.ion-activated.ion-color) .button-native{color:var(--ion-color-contrast)}:host(.button-outline.ion-activated.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-activated) .button-native::after{background:var(--ion-color-shade)}';
const IonButtonIosStyle0 = buttonIosCss;
const buttonMdCss = ':host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;height:100%;min-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted([slot=start]),::slotted([slot=end]){-ms-flex-negative:0;flex-shrink:0}::slotted(ion-icon){font-size:1.35em;pointer-events:none}::slotted(ion-icon[slot=start]){-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=end]){-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host(.button-outline.ion-activated.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--color));color:var(--ion-toolbar-background, var(--background), var(--ion-color-primary-contrast, #fff))}:host{--border-radius:4px;--padding-top:8px;--padding-bottom:8px;--padding-start:1.1em;--padding-end:1.1em;--transition:box-shadow 280ms cubic-bezier(.4, 0, .2, 1),\n                background-color 15ms linear,\n                color 15ms linear;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;margin-top:4px;margin-bottom:4px;min-height:36px;font-size:0.875rem;font-weight:500;letter-spacing:0.06em;text-transform:uppercase}:host(.button-solid){--background-activated:transparent;--background-hover:var(--ion-color-primary-contrast, #fff);--background-focused:var(--ion-color-primary-contrast, #fff);--background-activated-opacity:0;--background-focused-opacity:.24;--background-hover-opacity:.08;--box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}:host(.button-solid.ion-activated){--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12)}:host(.button-outline){--border-width:2px;--border-style:solid;--box-shadow:none;--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-outline.ion-activated.ion-color) .button-native{background:transparent}:host(.button-clear){--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-large){--padding-top:14px;--padding-start:1em;--padding-end:1em;--padding-bottom:14px;min-height:2.8em;font-size:1.25rem}:host(.button-small){--padding-top:4px;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:4px;min-height:2.1em;font-size:0.8125rem}:host(.button-has-icon-only){--padding-top:0;--padding-bottom:0}:host(.button-strong){font-weight:bold}::slotted(ion-icon[slot=icon-only]){padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color.ion-focused) .button-native::after,:host(.button-outline.ion-color.ion-focused) .button-native::after{background:var(--ion-color-base)}@media (any-hover: hover){:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:var(--ion-color-base)}}';
const IonButtonMdStyle0 = buttonMdCss;
const Button = /* @__PURE__ */ proxyCustomElement(class Button2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.inItem = false;
    this.inListHeader = false;
    this.inToolbar = false;
    this.formButtonEl = null;
    this.formEl = null;
    this.inheritedAttributes = {};
    this.handleClick = (ev) => {
      const { el: el2 } = this;
      if (this.type === "button") {
        openURL(this.href, ev, this.routerDirection, this.routerAnimation);
      } else if (hasShadowDom(el2)) {
        this.submitForm(ev);
      }
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.color = void 0;
    this.buttonType = "button";
    this.disabled = false;
    this.expand = void 0;
    this.fill = void 0;
    this.routerDirection = "forward";
    this.routerAnimation = void 0;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.shape = void 0;
    this.size = void 0;
    this.strong = false;
    this.target = void 0;
    this.type = "button";
    this.form = void 0;
  }
  disabledChanged() {
    const { disabled } = this;
    if (this.formButtonEl) {
      this.formButtonEl.disabled = disabled;
    }
  }
  /**
   * This is responsible for rendering a hidden native
   * button element inside the associated form. This allows
   * users to submit a form by pressing "Enter" when a text
   * field inside of the form is focused. The native button
   * rendered inside of `ion-button` is in the Shadow DOM
   * and therefore does not participate in form submission
   * which is why the following code is necessary.
   */
  renderHiddenButton() {
    const formEl = this.formEl = this.findForm();
    if (formEl) {
      const { formButtonEl } = this;
      if (formButtonEl !== null && formEl.contains(formButtonEl)) {
        return;
      }
      const newFormButtonEl = this.formButtonEl = document.createElement("button");
      newFormButtonEl.type = this.type;
      newFormButtonEl.style.display = "none";
      newFormButtonEl.disabled = this.disabled;
      formEl.appendChild(newFormButtonEl);
    }
  }
  componentWillLoad() {
    this.inToolbar = !!this.el.closest("ion-buttons");
    this.inListHeader = !!this.el.closest("ion-list-header");
    this.inItem = !!this.el.closest("ion-item") || !!this.el.closest("ion-item-divider");
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  get hasIconOnly() {
    return !!this.el.querySelector('[slot="icon-only"]');
  }
  get rippleType() {
    const hasClearFill = this.fill === void 0 || this.fill === "clear";
    if (hasClearFill && this.hasIconOnly && this.inToolbar) {
      return "unbounded";
    }
    return "bounded";
  }
  /**
   * Finds the form element based on the provided `form` selector
   * or element reference provided.
   */
  findForm() {
    const { form } = this;
    if (form instanceof HTMLFormElement) {
      return form;
    }
    if (typeof form === "string") {
      const el2 = document.getElementById(form);
      if (el2) {
        if (el2 instanceof HTMLFormElement) {
          return el2;
        } else {
          printIonWarning(`Form with selector: "#${form}" could not be found. Verify that the id is attached to a <form> element.`, this.el);
          return null;
        }
      } else {
        printIonWarning(`Form with selector: "#${form}" could not be found. Verify that the id is correct and the form is rendered in the DOM.`, this.el);
        return null;
      }
    }
    if (form !== void 0) {
      printIonWarning(`The provided "form" element is invalid. Verify that the form is a HTMLFormElement and rendered in the DOM.`, this.el);
      return null;
    }
    return this.el.closest("form");
  }
  submitForm(ev) {
    if (this.formEl && this.formButtonEl) {
      ev.preventDefault();
      this.formButtonEl.click();
    }
  }
  render() {
    const mode = getIonMode$2(this);
    const { buttonType, type, disabled, rel, target, size, href, color, expand, hasIconOnly, shape, strong, inheritedAttributes } = this;
    const finalSize = size === void 0 && this.inItem ? "small" : size;
    const TagType = href === void 0 ? "button" : "a";
    const attrs = TagType === "button" ? { type } : {
      download: this.download,
      href,
      rel,
      target
    };
    let fill2 = this.fill;
    if (fill2 == null) {
      fill2 = this.inToolbar || this.inListHeader ? "clear" : "solid";
    }
    {
      type !== "button" && this.renderHiddenButton();
    }
    return h$1(Host, { key: "8533314504b286ec10e26722f93376d86a7ca1c9", onClick: this.handleClick, "aria-disabled": disabled ? "true" : null, class: createColorClasses$2(color, {
      [mode]: true,
      [buttonType]: true,
      [`${buttonType}-${expand}`]: expand !== void 0,
      [`${buttonType}-${finalSize}`]: finalSize !== void 0,
      [`${buttonType}-${shape}`]: shape !== void 0,
      [`${buttonType}-${fill2}`]: true,
      [`${buttonType}-strong`]: strong,
      "in-toolbar": hostContext("ion-toolbar", this.el),
      "in-toolbar-color": hostContext("ion-toolbar[color]", this.el),
      "in-buttons": hostContext("ion-buttons", this.el),
      "button-has-icon-only": hasIconOnly,
      "button-disabled": disabled,
      "ion-activatable": true,
      "ion-focusable": true
    }) }, h$1(TagType, Object.assign({ key: "79bf020fdac0c2ceb2b05547b3e5a9a11e60abb4" }, attrs, { class: "button-native", part: "native", disabled, onFocus: this.onFocus, onBlur: this.onBlur }, inheritedAttributes), h$1("span", { key: "109481ba86102647023b746b054b2718d3c9d92a", class: "button-inner" }, h$1("slot", { key: "f824ddd9f988b9bd33136555b16aa790d9291b49", name: "icon-only" }), h$1("slot", { key: "d614f4e430792c5f93be4b3a8c57a826d74b9cfd", name: "start" }), h$1("slot", { key: "95d00c8a980c31cc7f84732f51a17a0cd285a7cb" }), h$1("slot", { key: "a228ff52cbe04dc9d2e22bb66611ecc96d130e6f", name: "end" })), mode === "md" && h$1("ion-ripple-effect", { type: this.rippleType })));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "disabled": ["disabledChanged"]
    };
  }
  static get style() {
    return {
      ios: IonButtonIosStyle0,
      md: IonButtonMdStyle0
    };
  }
}, [33, "ion-button", {
  "color": [513],
  "buttonType": [1025, "button-type"],
  "disabled": [516],
  "expand": [513],
  "fill": [1537],
  "routerDirection": [1, "router-direction"],
  "routerAnimation": [16],
  "download": [1],
  "href": [1],
  "rel": [1],
  "shape": [513],
  "size": [513],
  "strong": [4],
  "target": [1],
  "type": [1],
  "form": [1]
}, void 0, {
  "disabled": ["disabledChanged"]
}]);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const noteIosCss = ":host{color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-base)}:host{--color:var(--ion-color-step-350, #a6a6a6);font-size:max(14px, 1rem)}";
const IonNoteIosStyle0 = noteIosCss;
const noteMdCss = ":host{color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-base)}:host{--color:var(--ion-color-step-600, #666666);font-size:0.875rem}";
const IonNoteMdStyle0 = noteMdCss;
const Note = /* @__PURE__ */ proxyCustomElement(class Note2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "eebc0ea94483a248192408a1546739700281d2ae", class: createColorClasses$2(this.color, {
      [mode]: true
    }) }, h$1("slot", { key: "33018e11967398327a0e7c20522547a4d9e8f55b" }));
  }
  static get style() {
    return {
      ios: IonNoteIosStyle0,
      md: IonNoteMdStyle0
    };
  }
}, [33, "ion-note", {
  "color": [513]
}]);
function defineCustomElement$t() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-note"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-note":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Note);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const itemIosCss = ':host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:1.25em;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native,:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-inner{border-color:var(--ion-color-shade)}:host(.ion-activated) .item-native{color:var(--color-activated)}:host(.ion-activated) .item-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-color.ion-activated) .item-native{color:var(--ion-color-contrast)}:host(.ion-focused) .item-native{color:var(--color-focused)}:host(.ion-focused) .item-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-color.ion-focused) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .item-native::after{background:var(--ion-color-contrast)}@media (any-hover: hover){:host(.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--color-hover)}:host(.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--ion-color-contrast)}}:host(.item-has-interactive-control){cursor:pointer}:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){cursor:default;opacity:0.3;pointer-events:none}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-right:var(--padding-end);padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;z-index:1;-webkit-box-sizing:border-box;box-sizing:border-box}:host-context([dir=rtl]) .item-native{padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}[dir=rtl] .item-native{padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}@supports selector(:dir(rtl)){.item-native:dir(rtl){padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}}.item-native::-moz-focus-inner{border:0}.item-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0;-webkit-transition:var(--transition);transition:var(--transition);z-index:-1}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-left:var(--inner-padding-start);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host-context([dir=rtl]) .item-inner{padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}[dir=rtl] .item-inner{padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}@supports selector(:dir(rtl)){.item-inner:dir(rtl){padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}}.item-bottom{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:calc(var(--inner-padding-end) + var(--ion-safe-area-right, 0px));display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}:host-context([dir=rtl]) .item-bottom{padding-left:calc(var(--inner-padding-end) + var(--ion-safe-area-left, 0px));padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px))}[dir=rtl] .item-bottom{padding-left:calc(var(--inner-padding-end) + var(--ion-safe-area-left, 0px));padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px))}@supports selector(:dir(rtl)){.item-bottom:dir(rtl){padding-left:calc(var(--inner-padding-end) + var(--ion-safe-area-left, 0px));padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px))}}.item-detail-icon{-webkit-margin-start:calc(var(--inner-padding-end) / 2);margin-inline-start:calc(var(--inner-padding-end) / 2);-webkit-margin-end:-6px;margin-inline-end:-6px;color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label:not([slot=end])){-ms-flex:1;flex:1;width:-webkit-min-content;width:-moz-min-content;width:min-content;max-width:100%}:host(.item-input){-ms-flex-align:center;align-items:center}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-stacked),:host(.item-label-floating){-ms-flex-align:start;align-items:start}:host(.item-label-stacked) .input-wrapper,:host(.item-label-floating) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}.item-highlight,.item-inner-highlight{left:0;right:0;top:0;bottom:0;border-radius:inherit;position:absolute;width:100%;height:100%;-webkit-transform:scaleX(0);transform:scaleX(0);-webkit-transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:transform 200ms, border-bottom-width 200ms;transition:transform 200ms, border-bottom-width 200ms, -webkit-transform 200ms;z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus),:host(.item-interactive.ion-touched.ion-invalid){--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}:host(.ion-focused) .item-highlight,:host(.ion-focused) .item-inner-highlight,:host(.item-has-focus) .item-highlight,:host(.item-has-focus) .item-inner-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-style:var(--border-style);border-color:var(--highlight-background)}:host(.ion-focused) .item-highlight,:host(.item-has-focus) .item-highlight{border-width:var(--full-highlight-height);opacity:var(--show-full-highlight)}:host(.ion-focused) .item-inner-highlight,:host(.item-has-focus) .item-inner-highlight{border-bottom-width:var(--inset-highlight-height);opacity:var(--show-inset-highlight)}:host(.ion-focused.item-fill-solid) .item-highlight,:host(.item-has-focus.item-fill-solid) .item-highlight{border-width:calc(var(--full-highlight-height) - 1px)}:host(.ion-focused) .item-inner-highlight,:host(.ion-focused:not(.item-fill-outline)) .item-highlight,:host(.item-has-focus) .item-inner-highlight,:host(.item-has-focus:not(.item-fill-outline)) .item-highlight{border-top:none;border-right:none;border-left:none}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus){--highlight-background:var(--highlight-color-focused)}:host(.item-interactive.ion-valid){--highlight-background:var(--highlight-color-valid)}:host(.item-interactive.ion-invalid){--highlight-background:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=helper]){display:none}::slotted([slot=error]){display:none;color:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=error]){display:block}:host(:not(.item-label)) ::slotted(ion-select.legacy-select){--padding-start:0;max-width:none}:host(.item-label-stacked) ::slotted(ion-select.legacy-select),:host(.item-label-floating) ::slotted(ion-select.legacy-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0;-ms-flex-item-align:stretch;align-self:stretch;width:100%;max-width:100%}:host(:not(.item-label)) ::slotted(ion-datetime){--padding-start:0}:host(.item-label-stacked) ::slotted(ion-datetime),:host(.item-label-floating) ::slotted(ion-datetime){--padding-start:0;width:100%}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio),:host(.item-multiple-inputs) ::slotted(ion-select.legacy-select){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted([slot=helper]),::slotted([slot=error]),.item-counter{padding-top:5px;font-size:0.75rem;z-index:1}.item-counter{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, #737373);white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}@media (prefers-reduced-motion: reduce){.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}}:host{--min-height:44px;--transition:background-color 200ms linear, opacity 200ms linear;--padding-start:16px;--inner-padding-end:16px;--inner-border-width:0px 0px 0.55px 0px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:var(--ion-text-color, #000);--background-focused:var(--ion-text-color, #000);--background-hover:currentColor;--background-activated-opacity:.12;--background-focused-opacity:.15;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));--color:var(--ion-item-color, var(--ion-text-color, #000));--highlight-height:0px;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--bottom-padding-start:0px;font-size:1rem}:host(.ion-activated){--transition:none}:host(.ion-color.ion-focused) .item-native::after{background:#000;opacity:0.15}:host(.ion-color.ion-activated) .item-native::after{background:#000;opacity:0.12}:host(.item-interactive){--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-full){--border-width:0px 0px 0.55px 0px;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-inset){--inner-border-width:0px 0px 0.55px 0px;--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0px;--show-full-highlight:0}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0px;--show-inset-highlight:0}.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}:host(.item-has-focus) .item-inner-highlight,:host(.item-has-focus) .item-highlight{border-top:none;border-right:none;border-left:none}::slotted([slot=start]){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:2px;margin-bottom:2px}::slotted(ion-icon[slot=start]),::slotted(ion-icon[slot=end]){margin-top:7px;margin-bottom:7px}::slotted(ion-toggle[slot=start]),::slotted(ion-toggle[slot=end]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}:host(.item-label-stacked) ::slotted([slot=end]),:host(.item-label-floating) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}::slotted(.button-small){--padding-top:1px;--padding-bottom:1px;--padding-start:.5em;--padding-end:.5em;min-height:24px;font-size:0.8125rem}::slotted(ion-avatar){width:36px;height:36px}::slotted(ion-thumbnail){--size:56px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:8px;margin-bottom:8px}:host(.item-radio) ::slotted(ion-label),:host(.item-toggle) ::slotted(ion-label){-webkit-margin-start:0px;margin-inline-start:0px}::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:10px;margin-bottom:10px}:host(.item-label-floating),:host(.item-label-stacked){--min-height:68px}:host(.item-label-stacked) ::slotted(ion-select.legacy-select),:host(.item-label-floating) ::slotted(ion-select.legacy-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0px}:host(.item-label-fixed) ::slotted(ion-select.legacy-select),:host(.item-label-fixed) ::slotted(ion-datetime){--padding-start:0}';
const IonItemIosStyle0 = itemIosCss;
const itemMdCss = ':host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:1.25em;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native,:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-inner{border-color:var(--ion-color-shade)}:host(.ion-activated) .item-native{color:var(--color-activated)}:host(.ion-activated) .item-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-color.ion-activated) .item-native{color:var(--ion-color-contrast)}:host(.ion-focused) .item-native{color:var(--color-focused)}:host(.ion-focused) .item-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-color.ion-focused) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .item-native::after{background:var(--ion-color-contrast)}@media (any-hover: hover){:host(.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--color-hover)}:host(.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--ion-color-contrast)}}:host(.item-has-interactive-control){cursor:pointer}:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){cursor:default;opacity:0.3;pointer-events:none}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-right:var(--padding-end);padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;z-index:1;-webkit-box-sizing:border-box;box-sizing:border-box}:host-context([dir=rtl]) .item-native{padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}[dir=rtl] .item-native{padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}@supports selector(:dir(rtl)){.item-native:dir(rtl){padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}}.item-native::-moz-focus-inner{border:0}.item-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0;-webkit-transition:var(--transition);transition:var(--transition);z-index:-1}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-left:var(--inner-padding-start);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host-context([dir=rtl]) .item-inner{padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}[dir=rtl] .item-inner{padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}@supports selector(:dir(rtl)){.item-inner:dir(rtl){padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}}.item-bottom{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:calc(var(--inner-padding-end) + var(--ion-safe-area-right, 0px));display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}:host-context([dir=rtl]) .item-bottom{padding-left:calc(var(--inner-padding-end) + var(--ion-safe-area-left, 0px));padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px))}[dir=rtl] .item-bottom{padding-left:calc(var(--inner-padding-end) + var(--ion-safe-area-left, 0px));padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px))}@supports selector(:dir(rtl)){.item-bottom:dir(rtl){padding-left:calc(var(--inner-padding-end) + var(--ion-safe-area-left, 0px));padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px))}}.item-detail-icon{-webkit-margin-start:calc(var(--inner-padding-end) / 2);margin-inline-start:calc(var(--inner-padding-end) / 2);-webkit-margin-end:-6px;margin-inline-end:-6px;color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label:not([slot=end])){-ms-flex:1;flex:1;width:-webkit-min-content;width:-moz-min-content;width:min-content;max-width:100%}:host(.item-input){-ms-flex-align:center;align-items:center}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-stacked),:host(.item-label-floating){-ms-flex-align:start;align-items:start}:host(.item-label-stacked) .input-wrapper,:host(.item-label-floating) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}.item-highlight,.item-inner-highlight{left:0;right:0;top:0;bottom:0;border-radius:inherit;position:absolute;width:100%;height:100%;-webkit-transform:scaleX(0);transform:scaleX(0);-webkit-transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:transform 200ms, border-bottom-width 200ms;transition:transform 200ms, border-bottom-width 200ms, -webkit-transform 200ms;z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus),:host(.item-interactive.ion-touched.ion-invalid){--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}:host(.ion-focused) .item-highlight,:host(.ion-focused) .item-inner-highlight,:host(.item-has-focus) .item-highlight,:host(.item-has-focus) .item-inner-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-style:var(--border-style);border-color:var(--highlight-background)}:host(.ion-focused) .item-highlight,:host(.item-has-focus) .item-highlight{border-width:var(--full-highlight-height);opacity:var(--show-full-highlight)}:host(.ion-focused) .item-inner-highlight,:host(.item-has-focus) .item-inner-highlight{border-bottom-width:var(--inset-highlight-height);opacity:var(--show-inset-highlight)}:host(.ion-focused.item-fill-solid) .item-highlight,:host(.item-has-focus.item-fill-solid) .item-highlight{border-width:calc(var(--full-highlight-height) - 1px)}:host(.ion-focused) .item-inner-highlight,:host(.ion-focused:not(.item-fill-outline)) .item-highlight,:host(.item-has-focus) .item-inner-highlight,:host(.item-has-focus:not(.item-fill-outline)) .item-highlight{border-top:none;border-right:none;border-left:none}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus){--highlight-background:var(--highlight-color-focused)}:host(.item-interactive.ion-valid){--highlight-background:var(--highlight-color-valid)}:host(.item-interactive.ion-invalid){--highlight-background:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=helper]){display:none}::slotted([slot=error]){display:none;color:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=error]){display:block}:host(:not(.item-label)) ::slotted(ion-select.legacy-select){--padding-start:0;max-width:none}:host(.item-label-stacked) ::slotted(ion-select.legacy-select),:host(.item-label-floating) ::slotted(ion-select.legacy-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0;-ms-flex-item-align:stretch;align-self:stretch;width:100%;max-width:100%}:host(:not(.item-label)) ::slotted(ion-datetime){--padding-start:0}:host(.item-label-stacked) ::slotted(ion-datetime),:host(.item-label-floating) ::slotted(ion-datetime){--padding-start:0;width:100%}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio),:host(.item-multiple-inputs) ::slotted(ion-select.legacy-select){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted([slot=helper]),::slotted([slot=error]),.item-counter{padding-top:5px;font-size:0.75rem;z-index:1}.item-counter{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, #737373);white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}@media (prefers-reduced-motion: reduce){.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}}:host{--min-height:48px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--color:var(--ion-item-color, var(--ion-text-color, #000));--transition:opacity 15ms linear, background-color 15ms linear;--padding-start:16px;--inner-padding-end:16px;--inner-border-width:0 0 1px 0;--highlight-height:1px;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);font-size:1rem;font-weight:normal;text-transform:none}:host(.item-fill-outline){--highlight-height:2px}:host(.item-fill-none.item-interactive.ion-focus) .item-highlight,:host(.item-fill-none.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-none.item-interactive.ion-touched.ion-invalid) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-width:0 0 var(--full-highlight-height) 0;border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-none.item-interactive.ion-focus) .item-native,:host(.item-fill-none.item-interactive.item-has-focus) .item-native,:host(.item-fill-none.item-interactive.ion-touched.ion-invalid) .item-native{border-bottom-color:var(--highlight-background)}:host(.item-fill-outline.item-interactive.ion-focus) .item-highlight,:host(.item-fill-outline.item-interactive.item-has-focus) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1)}:host(.item-fill-outline.item-interactive.ion-focus) .item-highlight,:host(.item-fill-outline.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-outline.item-interactive.ion-touched.ion-invalid) .item-highlight{border-width:var(--full-highlight-height);border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-outline.item-interactive.ion-touched.ion-invalid) .item-native{border-color:var(--highlight-background)}:host(.item-fill-solid.item-interactive.ion-focus) .item-highlight,:host(.item-fill-solid.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-solid.item-interactive.ion-touched.ion-invalid) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-width:0 0 var(--full-highlight-height) 0;border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-solid.item-interactive.ion-focus) .item-native,:host(.item-fill-solid.item-interactive.item-has-focus) .item-native,:host(.item-fill-solid.item-interactive.ion-touched.ion-invalid) .item-native{border-bottom-color:var(--highlight-background)}:host(.ion-color.ion-activated) .item-native::after{background:transparent}:host(.item-has-focus) .item-native{caret-color:var(--highlight-background)}:host(.item-interactive){--border-width:0 0 1px 0;--inner-border-width:0;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-full){--border-width:0 0 1px 0;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-inset){--inner-border-width:0 0 1px 0;--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0;--show-full-highlight:0}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0;--show-inset-highlight:0}:host(.item-fill-outline) .item-highlight{--position-offset:calc(-1 * var(--border-width));top:var(--position-offset);width:calc(100% + 2 * var(--border-width));height:calc(100% + 2 * var(--border-width));-webkit-transition:none;transition:none}@supports (inset-inline-start: 0){:host(.item-fill-outline) .item-highlight{inset-inline-start:var(--position-offset)}}@supports not (inset-inline-start: 0){:host(.item-fill-outline) .item-highlight{left:var(--position-offset)}:host-context([dir=rtl]):host(.item-fill-outline) .item-highlight,:host-context([dir=rtl]).item-fill-outline .item-highlight{left:unset;right:unset;right:var(--position-offset)}@supports selector(:dir(rtl)){:host(.item-fill-outline:dir(rtl)) .item-highlight{left:unset;right:unset;right:var(--position-offset)}}}:host(.item-fill-outline.ion-focused) .item-native,:host(.item-fill-outline.item-has-focus) .item-native{border-color:transparent}:host(.item-multi-line) ::slotted([slot=start]),:host(.item-multi-line) ::slotted([slot=end]){margin-top:16px;margin-bottom:16px;-ms-flex-item-align:start;align-self:flex-start}::slotted([slot=start]){-webkit-margin-end:32px;margin-inline-end:32px}::slotted([slot=end]){-webkit-margin-start:32px;margin-inline-start:32px}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted(ion-icon){color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);font-size:1.5em}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) ::slotted(ion-icon){color:var(--ion-color-contrast)}::slotted(ion-icon[slot]){margin-top:12px;margin-bottom:12px}::slotted(ion-icon[slot=start]){-webkit-margin-end:32px;margin-inline-end:32px}::slotted(ion-icon[slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}:host(.item-fill-solid) ::slotted(ion-icon[slot=start]),:host(.item-fill-outline) ::slotted(ion-icon[slot=start]){-webkit-margin-end:8px;margin-inline-end:8px}::slotted(ion-toggle[slot=start]),::slotted(ion-toggle[slot=end]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}::slotted(ion-note){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-ms-flex-item-align:start;align-self:flex-start;font-size:0.6875rem}::slotted(ion-note[slot]:not([slot=helper]):not([slot=error])){padding-left:0;padding-right:0;padding-top:18px;padding-bottom:10px}::slotted(ion-note[slot=start]){-webkit-padding-end:16px;padding-inline-end:16px}::slotted(ion-note[slot=end]){-webkit-padding-start:16px;padding-inline-start:16px}::slotted(ion-avatar){width:40px;height:40px}::slotted(ion-thumbnail){--size:56px}::slotted(ion-avatar),::slotted(ion-thumbnail){margin-top:8px;margin-bottom:8px}::slotted(ion-avatar[slot=start]),::slotted(ion-thumbnail[slot=start]){-webkit-margin-end:16px;margin-inline-end:16px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:10px;margin-bottom:10px}:host(.item-label-stacked) ::slotted([slot=end]),:host(.item-label-floating) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}:host(.item-label-fixed) ::slotted(ion-select.legacy-select),:host(.item-label-fixed) ::slotted(ion-datetime){--padding-start:8px}:host(.item-toggle) ::slotted(ion-label),:host(.item-radio) ::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0}::slotted(.button-small){--padding-top:2px;--padding-bottom:2px;--padding-start:.6em;--padding-end:.6em;min-height:25px;font-size:0.75rem}:host(.item-label-floating),:host(.item-label-stacked){--min-height:55px}:host(.item-label-stacked) ::slotted(ion-select.legacy-select),:host(.item-label-floating) ::slotted(ion-select.legacy-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0}:host(.ion-focused:not(.ion-color)) ::slotted(.label-stacked),:host(.ion-focused:not(.ion-color)) ::slotted(.label-floating),:host(.item-has-focus:not(.ion-color)) ::slotted(.label-stacked),:host(.item-has-focus:not(.ion-color)) ::slotted(.label-floating){color:var(--ion-color-primary, #3880ff)}:host(.ion-color){--highlight-color-focused:var(--ion-color-contrast)}:host(.item-label-color){--highlight-color-focused:var(--ion-color-base)}:host(.item-fill-solid.ion-color),:host(.item-fill-outline.ion-color){--highlight-color-focused:var(--ion-color-base)}:host(.item-fill-solid){--background:var(--ion-color-step-50, #f2f2f2);--background-hover:var(--ion-color-step-100, #e6e6e6);--background-focused:var(--ion-color-step-150, #d9d9d9);--border-width:0 0 1px 0;--inner-border-width:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.item-fill-solid),:host-context([dir=rtl]).item-fill-solid{border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}@supports selector(:dir(rtl)){:host(.item-fill-solid:dir(rtl)){border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}}:host(.item-fill-solid) .item-native{--border-color:var(--ion-color-step-500, gray)}:host(.item-fill-solid.ion-focused) .item-native,:host(.item-fill-solid.item-has-focus) .item-native{--background:var(--background-focused)}:host(.item-fill-solid.item-shape-round){border-top-left-radius:16px;border-top-right-radius:16px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.item-fill-solid.item-shape-round),:host-context([dir=rtl]).item-fill-solid.item-shape-round{border-top-left-radius:16px;border-top-right-radius:16px;border-bottom-right-radius:0;border-bottom-left-radius:0}@supports selector(:dir(rtl)){:host(.item-fill-solid.item-shape-round:dir(rtl)){border-top-left-radius:16px;border-top-right-radius:16px;border-bottom-right-radius:0;border-bottom-left-radius:0}}@media (any-hover: hover){:host(.item-fill-solid:hover) .item-native{--background:var(--background-hover);--border-color:var(--ion-color-step-750, #404040)}}:host(.item-fill-outline){--ripple-color:transparent;--background-focused:transparent;--background-hover:transparent;--border-color:var(--ion-color-step-500, gray);--border-width:1px;border:none;overflow:visible}:host(.item-fill-outline) .item-native{--native-padding-left:16px;border-radius:4px}:host(.item-fill-outline.item-shape-round) .item-native{--inner-padding-start:16px;border-radius:28px}:host(.item-fill-outline.item-shape-round) .item-bottom{-webkit-padding-start:32px;padding-inline-start:32px}:host(.item-fill-outline.item-label-floating.ion-focused) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.ion-focused) .item-native ::slotted(ion-textarea:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-focus) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-focus) .item-native ::slotted(ion-textarea:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-value) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-value) .item-native ::slotted(ion-textarea:not(:first-child)){-webkit-transform:translateY(-14px);transform:translateY(-14px)}@media (any-hover: hover){:host(.item-fill-outline:hover) .item-native{--border-color:var(--ion-color-step-750, #404040)}}.item-counter{letter-spacing:0.0333333333em}';
const IonItemMdStyle0 = itemMdCss;
const Item$1 = /* @__PURE__ */ proxyCustomElement(class Item extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.labelColorStyles = {};
    this.itemStyles = /* @__PURE__ */ new Map();
    this.inheritedAriaAttributes = {};
    this.multipleInputs = false;
    this.focusable = true;
    this.color = void 0;
    this.button = false;
    this.detail = void 0;
    this.detailIcon = chevronForward;
    this.disabled = false;
    this.download = void 0;
    this.fill = void 0;
    this.shape = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.lines = void 0;
    this.counter = false;
    this.routerAnimation = void 0;
    this.routerDirection = "forward";
    this.target = void 0;
    this.type = "button";
    this.counterFormatter = void 0;
    this.counterString = void 0;
  }
  buttonChanged() {
    this.focusable = this.isFocusable();
  }
  counterFormatterChanged() {
    this.updateCounterOutput(this.getFirstInput());
  }
  handleIonInput(ev) {
    if (this.counter && ev.target === this.getFirstInput()) {
      this.updateCounterOutput(ev.target);
    }
  }
  labelColorChanged(ev) {
    const { color } = this;
    if (color === void 0) {
      this.labelColorStyles = ev.detail;
    }
  }
  itemStyle(ev) {
    ev.stopPropagation();
    const tagName = ev.target.tagName;
    const updatedStyles = ev.detail;
    const newStyles = {};
    const childStyles = this.itemStyles.get(tagName) || {};
    let hasStyleChange = false;
    Object.keys(updatedStyles).forEach((key) => {
      if (updatedStyles[key]) {
        const itemKey = `item-${key}`;
        if (!childStyles[itemKey]) {
          hasStyleChange = true;
        }
        newStyles[itemKey] = true;
      }
    });
    if (!hasStyleChange && Object.keys(newStyles).length !== Object.keys(childStyles).length) {
      hasStyleChange = true;
    }
    if (hasStyleChange) {
      this.itemStyles.set(tagName, newStyles);
      forceUpdate(this);
    }
  }
  connectedCallback() {
    if (this.counter) {
      this.updateCounterOutput(this.getFirstInput());
    }
    this.hasStartEl();
  }
  componentWillLoad() {
    this.inheritedAriaAttributes = inheritAttributes$2(this.el, ["aria-label"]);
  }
  componentDidLoad() {
    const { el: el2, counter, counterFormatter, fill: fill2, shape } = this;
    const hasHelperSlot = el2.querySelector('[slot="helper"]') !== null;
    if (hasHelperSlot) {
      printIonWarning('The "helper" slot has been deprecated in favor of using the "helperText" property on ion-input or ion-textarea.', el2);
    }
    const hasErrorSlot = el2.querySelector('[slot="error"]') !== null;
    if (hasErrorSlot) {
      printIonWarning('The "error" slot has been deprecated in favor of using the "errorText" property on ion-input or ion-textarea.', el2);
    }
    if (counter === true) {
      printIonWarning('The "counter" property has been deprecated in favor of using the "counter" property on ion-input or ion-textarea.', el2);
    }
    if (counterFormatter !== void 0) {
      printIonWarning('The "counterFormatter" property has been deprecated in favor of using the "counterFormatter" property on ion-input or ion-textarea.', el2);
    }
    if (fill2 !== void 0) {
      printIonWarning('The "fill" property has been deprecated in favor of using the "fill" property on ion-input or ion-textarea.', el2);
    }
    if (shape !== void 0) {
      printIonWarning('The "shape" property has been deprecated in favor of using the "shape" property on ion-input or ion-textarea.', el2);
    }
    raf(() => {
      this.setMultipleInputs();
      this.focusable = this.isFocusable();
    });
  }
  // If the item contains multiple clickable elements and/or inputs, then the item
  // should not have a clickable input cover over the entire item to prevent
  // interfering with their individual click events
  setMultipleInputs() {
    const covers = this.el.querySelectorAll("ion-checkbox, ion-datetime, ion-select, ion-radio");
    const inputs = this.el.querySelectorAll("ion-input, ion-range, ion-searchbar, ion-segment, ion-textarea, ion-toggle");
    const clickables = this.el.querySelectorAll("ion-anchor, ion-button, a, button");
    this.multipleInputs = covers.length + inputs.length > 1 || covers.length + clickables.length > 1 || covers.length > 0 && this.isClickable();
  }
  // If the item contains an input including a checkbox, datetime, select, or radio
  // then the item will have a clickable input cover that covers the item
  // that should get the hover, focused and activated states UNLESS it has multiple
  // inputs, then those need to individually get each click
  hasCover() {
    const inputs = this.el.querySelectorAll("ion-checkbox, ion-datetime, ion-select, ion-radio");
    return inputs.length === 1 && !this.multipleInputs;
  }
  // If the item has an href or button property it will render a native
  // anchor or button that is clickable
  isClickable() {
    return this.href !== void 0 || this.button;
  }
  canActivate() {
    return this.isClickable() || this.hasCover();
  }
  isFocusable() {
    const focusableChild = this.el.querySelector(".ion-focusable");
    return this.canActivate() || focusableChild !== null;
  }
  getFirstInput() {
    const inputs = this.el.querySelectorAll("ion-input, ion-textarea");
    return inputs[0];
  }
  updateCounterOutput(inputEl) {
    var _a, _b;
    const { counter, counterFormatter, defaultCounterFormatter } = this;
    if (counter && !this.multipleInputs && (inputEl === null || inputEl === void 0 ? void 0 : inputEl.maxlength) !== void 0) {
      const length = (_b = (_a = inputEl === null || inputEl === void 0 ? void 0 : inputEl.value) === null || _a === void 0 ? void 0 : _a.toString().length) !== null && _b !== void 0 ? _b : 0;
      if (counterFormatter === void 0) {
        this.counterString = defaultCounterFormatter(length, inputEl.maxlength);
      } else {
        try {
          this.counterString = counterFormatter(length, inputEl.maxlength);
        } catch (e2) {
          printIonError("Exception in provided `counterFormatter`.", e2);
          this.counterString = defaultCounterFormatter(length, inputEl.maxlength);
        }
      }
    }
  }
  defaultCounterFormatter(length, maxlength) {
    return `${length} / ${maxlength}`;
  }
  hasStartEl() {
    const startEl = this.el.querySelector('[slot="start"]');
    if (startEl !== null) {
      this.el.classList.add("item-has-start-slot");
    }
  }
  getFirstInteractive() {
    const controls = this.el.querySelectorAll("ion-toggle:not([disabled]), ion-checkbox:not([disabled]), ion-radio:not([disabled]), ion-select:not([disabled])");
    return controls[0];
  }
  render() {
    const { counterString, detail, detailIcon, download, fill: fill2, labelColorStyles, lines, disabled, href, rel, shape, target, routerAnimation, routerDirection, inheritedAriaAttributes, multipleInputs } = this;
    const childStyles = {};
    const mode = getIonMode$2(this);
    const clickable = this.isClickable();
    const canActivate = this.canActivate();
    const TagType = clickable ? href === void 0 ? "button" : "a" : "div";
    const attrs = TagType === "button" ? { type: this.type } : {
      download,
      href,
      rel,
      target
    };
    let clickFn = {};
    const firstInteractive = this.getFirstInteractive();
    if (clickable || firstInteractive !== void 0 && !multipleInputs) {
      clickFn = {
        onClick: (ev) => {
          if (clickable) {
            openURL(href, ev, routerDirection, routerAnimation);
          }
          if (firstInteractive !== void 0 && !multipleInputs) {
            const path2 = ev.composedPath();
            const target2 = path2[0];
            if (ev.isTrusted) {
              const clickedWithinShadowRoot = this.el.shadowRoot.contains(target2);
              if (clickedWithinShadowRoot) {
                firstInteractive.click();
              }
            }
          }
        }
      };
    }
    const showDetail = detail !== void 0 ? detail : mode === "ios" && clickable;
    this.itemStyles.forEach((value) => {
      Object.assign(childStyles, value);
    });
    const ariaDisabled = disabled || childStyles["item-interactive-disabled"] ? "true" : null;
    const fillValue = fill2 || "none";
    const inList = hostContext("ion-list", this.el) && !hostContext("ion-radio-group", this.el);
    return h$1(Host, { key: "077c9ab04985292f79c30691151d2778a26285fb", "aria-disabled": ariaDisabled, class: Object.assign(Object.assign(Object.assign({}, childStyles), labelColorStyles), createColorClasses$2(this.color, {
      item: true,
      [mode]: true,
      "item-lines-default": lines === void 0,
      [`item-lines-${lines}`]: lines !== void 0,
      [`item-fill-${fillValue}`]: true,
      [`item-shape-${shape}`]: shape !== void 0,
      "item-has-interactive-control": firstInteractive !== void 0,
      "item-disabled": disabled,
      "in-list": inList,
      "item-multiple-inputs": this.multipleInputs,
      "ion-activatable": canActivate,
      "ion-focusable": this.focusable,
      "item-rtl": document.dir === "rtl"
    })), role: inList ? "listitem" : null }, h$1(TagType, Object.assign({ key: "08bb75c85d0584e9fb7f461e9e06b9b651ef3515" }, attrs, inheritedAriaAttributes, { class: "item-native", part: "native", disabled }, clickFn), h$1("slot", { key: "3f742b07c4a58eadedf675be4878a3e00070750e", name: "start" }), h$1("div", { key: "0160b8963434f3107856a2df2fb96f1abb4fdbfe", class: "item-inner" }, h$1("div", { key: "9439b21474443341f06a651d7c44aef90bd4c591", class: "input-wrapper" }, h$1("slot", { key: "8034e1337a6c950b7725bc9aa46d55de980827bf" })), h$1("slot", { key: "690de6d3dd3a238ab7a2d3dfea69daa6647e5134", name: "end" }), showDetail && h$1("ion-icon", { icon: detailIcon, lazy: false, class: "item-detail-icon", part: "detail-icon", "aria-hidden": "true", "flip-rtl": detailIcon === chevronForward }), h$1("div", { key: "e96885084ca845656fd4d18902528ce7de207c86", class: "item-inner-highlight" })), canActivate && mode === "md" && h$1("ion-ripple-effect", null), h$1("div", { key: "64e5323c380e05aa183e8dd7fbe560d084725f5e", class: "item-highlight" })), h$1("div", { key: "677132e6193981697f494b215ddc02407fdd96a5", class: "item-bottom" }, h$1("slot", { key: "cda34a9208020bbb18ca5313e0bfbf270f024012", name: "error" }), h$1("slot", { key: "c1b3541b11ece13309d0e28dd3a95c048dfab43f", name: "helper" }), counterString && h$1("ion-note", { class: "item-counter" }, counterString)));
  }
  static get delegatesFocus() {
    return true;
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "button": ["buttonChanged"],
      "counterFormatter": ["counterFormatterChanged"]
    };
  }
  static get style() {
    return {
      ios: IonItemIosStyle0,
      md: IonItemMdStyle0
    };
  }
}, [49, "ion-item", {
  "color": [513],
  "button": [4],
  "detail": [4],
  "detailIcon": [1, "detail-icon"],
  "disabled": [4],
  "download": [1],
  "fill": [1],
  "shape": [1],
  "href": [1],
  "rel": [1],
  "lines": [1],
  "counter": [4],
  "routerAnimation": [16],
  "routerDirection": [1, "router-direction"],
  "target": [1],
  "type": [1],
  "counterFormatter": [16],
  "multipleInputs": [32],
  "focusable": [32],
  "counterString": [32]
}, [[0, "ionInput", "handleIonInput"], [0, "ionColor", "labelColorChanged"], [0, "ionStyle", "itemStyle"]], {
  "button": ["buttonChanged"],
  "counterFormatter": ["counterFormatterChanged"]
}]);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const labelIosCss = ".item.sc-ion-label-ios-h,.item .sc-ion-label-ios-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;-webkit-box-sizing:border-box;box-sizing:border-box}.item-legacy.sc-ion-label-ios-h,.item-legacy .sc-ion-label-ios-h{white-space:nowrap;overflow:hidden}.item.sc-ion-label-ios-h:not(.item-input):not(.item-legacy),.item:not(.item-input):not(.item-legacy) .sc-ion-label-ios-h{-ms-flex-positive:1;flex-grow:1}.ion-color.sc-ion-label-ios-h{color:var(--ion-color-base)}.ion-text-nowrap.sc-ion-label-ios-h{overflow:hidden}.item-interactive-disabled.sc-ion-label-ios-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-ios-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-ios-h,.item-input .sc-ion-label-ios-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-ios-h,.item-textarea .sc-ion-label-ios-h{-ms-flex-item-align:baseline;align-self:baseline}.item-skeleton-text.sc-ion-label-ios-h,.item-skeleton-text .sc-ion-label-ios-h{overflow:hidden}.label-fixed.sc-ion-label-ios-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-ios-h,.label-floating.sc-ion-label-ios-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-ios-h{-webkit-transition:none;transition:none}.sc-ion-label-ios-s h1,.sc-ion-label-ios-s h2,.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-ios-h{font-size:0.875rem;line-height:1.5}.label-stacked.sc-ion-label-ios-h{margin-bottom:4px;font-size:0.875rem}.label-floating.sc-ion-label-ios-h{margin-bottom:0;-webkit-transform:translate(0, 29px);transform:translate(0, 29px);-webkit-transform-origin:left top;transform-origin:left top;-webkit-transition:-webkit-transform 150ms ease-in-out;transition:-webkit-transform 150ms ease-in-out;transition:transform 150ms ease-in-out;transition:transform 150ms ease-in-out, -webkit-transform 150ms ease-in-out}[dir=rtl].sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl] .sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl].label-floating.sc-ion-label-ios-h,[dir=rtl] .label-floating.sc-ion-label-ios-h{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.label-floating.sc-ion-label-ios-h:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.item-textarea.label-floating.sc-ion-label-ios-h,.item-textarea .label-floating.sc-ion-label-ios-h{-webkit-transform:translate(0, 28px);transform:translate(0, 28px)}.item-has-focus.label-floating.sc-ion-label-ios-h,.item-has-focus .label-floating.sc-ion-label-ios-h,.item-has-placeholder.sc-ion-label-ios-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-ios-h,.item-has-value.label-floating.sc-ion-label-ios-h,.item-has-value .label-floating.sc-ion-label-ios-h{-webkit-transform:scale(0.82);transform:scale(0.82)}.sc-ion-label-ios-s h1{margin-left:0;margin-right:0;margin-top:3px;margin-bottom:2px;font-size:1.375rem;font-weight:normal}.sc-ion-label-ios-s h2{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:1.0625rem;font-weight:normal}.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:0.875rem;font-weight:normal;line-height:normal}.sc-ion-label-ios-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:0.875rem;line-height:normal;text-overflow:inherit;overflow:inherit}.sc-ion-label-ios-s>p{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.4)}.sc-ion-label-ios-h.in-item-color.sc-ion-label-ios-s>p{color:inherit}.sc-ion-label-ios-s h2:last-child,.sc-ion-label-ios-s h3:last-child,.sc-ion-label-ios-s h4:last-child,.sc-ion-label-ios-s h5:last-child,.sc-ion-label-ios-s h6:last-child,.sc-ion-label-ios-s p:last-child{margin-bottom:0}";
const IonLabelIosStyle0 = labelIosCss;
const labelMdCss = '.item.sc-ion-label-md-h,.item .sc-ion-label-md-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;-webkit-box-sizing:border-box;box-sizing:border-box}.item-legacy.sc-ion-label-md-h,.item-legacy .sc-ion-label-md-h{white-space:nowrap;overflow:hidden}.item.sc-ion-label-md-h:not(.item-input):not(.item-legacy),.item:not(.item-input):not(.item-legacy) .sc-ion-label-md-h{-ms-flex-positive:1;flex-grow:1}.ion-color.sc-ion-label-md-h{color:var(--ion-color-base)}.ion-text-nowrap.sc-ion-label-md-h{overflow:hidden}.item-interactive-disabled.sc-ion-label-md-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-md-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-md-h,.item-input .sc-ion-label-md-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-md-h,.item-textarea .sc-ion-label-md-h{-ms-flex-item-align:baseline;align-self:baseline}.item-skeleton-text.sc-ion-label-md-h,.item-skeleton-text .sc-ion-label-md-h{overflow:hidden}.label-fixed.sc-ion-label-md-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-md-h{-webkit-transition:none;transition:none}.sc-ion-label-md-s h1,.sc-ion-label-md-s h2,.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-md-h{line-height:1.5}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-transform-origin:top left;transform-origin:top left}.label-stacked.label-rtl.sc-ion-label-md-h,.label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform-origin:top right;transform-origin:top right}.label-stacked.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.label-floating.sc-ion-label-md-h{-webkit-transform:translateY(96%);transform:translateY(96%);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1)}.ion-focused.label-floating.sc-ion-label-md-h,.ion-focused .label-floating.sc-ion-label-md-h,.item-has-focus.label-floating.sc-ion-label-md-h,.item-has-focus .label-floating.sc-ion-label-md-h,.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-has-value.label-floating.sc-ion-label-md-h,.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75)}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(-6px) scale(0.75);transform:translateY(-6px) scale(0.75);position:relative;max-width:-webkit-min-content;max-width:-moz-min-content;max-width:min-content;background-color:var(--ion-item-background, var(--ion-background-color, #fff));overflow:visible;z-index:3}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::after,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::before,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::after,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::after{position:absolute;width:4px;height:100%;background-color:var(--ion-item-background, var(--ion-background-color, #fff));content:""}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::before,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::before{left:calc(-1 * 4px)}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::after,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::after,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::after{right:calc(-1 * 4px)}.item-fill-outline.ion-focused.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.ion-focused.item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).item-has-start-slot.label-floating,.item-fill-outline.item-has-placeholder:not(.item-input).item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot .label-floating.sc-ion-label-md-h{-webkit-transform:translateX(-32px) translateY(-6px) scale(0.75);transform:translateX(-32px) translateY(-6px) scale(0.75)}.item-fill-outline.ion-focused.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.ion-focused.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).item-has-start-slot.label-floating.label-rtl,.item-fill-outline.item-has-placeholder:not(.item-input).item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform:translateX(calc(-1 * -32px)) translateY(-6px) scale(0.75);transform:translateX(calc(-1 * -32px)) translateY(-6px) scale(0.75)}.ion-focused.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-primary, #3880ff)}.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-contrast)}.item-fill-solid.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-base)}.ion-invalid.ion-touched.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--highlight-color-invalid)}.sc-ion-label-md-s h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:1.5rem;font-weight:normal}.sc-ion-label-md-s h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:1rem;font-weight:normal}.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:0.875rem;font-weight:normal;line-height:normal}.sc-ion-label-md-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:0.875rem;line-height:1.25rem;text-overflow:inherit;overflow:inherit}.sc-ion-label-md-s>p{color:var(--ion-color-step-600, #666666)}.sc-ion-label-md-h.in-item-color.sc-ion-label-md-s>p{color:inherit}';
const IonLabelMdStyle0 = labelMdCss;
const Label = /* @__PURE__ */ proxyCustomElement(class Label2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.ionColor = createEvent(this, "ionColor", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.inRange = false;
    this.color = void 0;
    this.position = void 0;
    this.noAnimate = false;
  }
  componentWillLoad() {
    this.inRange = !!this.el.closest("ion-range");
    this.noAnimate = this.position === "floating";
    this.emitStyle();
    this.emitColor();
  }
  componentDidLoad() {
    if (this.noAnimate) {
      setTimeout(() => {
        this.noAnimate = false;
      }, 1e3);
    }
  }
  colorChanged() {
    this.emitColor();
  }
  positionChanged() {
    this.emitStyle();
  }
  emitColor() {
    const { color } = this;
    this.ionColor.emit({
      "item-label-color": color !== void 0,
      [`ion-color-${color}`]: color !== void 0
    });
  }
  emitStyle() {
    const { inRange, position } = this;
    if (!inRange) {
      this.ionStyle.emit({
        label: true,
        [`label-${position}`]: position !== void 0
      });
    }
  }
  render() {
    const position = this.position;
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "813192a6460057c6d1e42f50f3f257bee2f550d8", class: createColorClasses$2(this.color, {
      [mode]: true,
      "in-item-color": hostContext("ion-item.ion-color", this.el),
      [`label-${position}`]: position !== void 0,
      [`label-no-animate`]: this.noAnimate,
      "label-rtl": document.dir === "rtl"
    }) });
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "color": ["colorChanged"],
      "position": ["positionChanged"]
    };
  }
  static get style() {
    return {
      ios: IonLabelIosStyle0,
      md: IonLabelMdStyle0
    };
  }
}, [34, "ion-label", {
  "color": [513],
  "position": [1],
  "noAnimate": [32]
}, void 0, {
  "color": ["colorChanged"],
  "position": ["positionChanged"]
}]);
function defineCustomElement$s() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-label"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-label":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Label);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getCapacitor = () => {
  if (win$1 !== void 0) {
    return win$1.Capacitor;
  }
  return void 0;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
var ImpactStyle;
(function(ImpactStyle2) {
  ImpactStyle2["Heavy"] = "HEAVY";
  ImpactStyle2["Medium"] = "MEDIUM";
  ImpactStyle2["Light"] = "LIGHT";
})(ImpactStyle || (ImpactStyle = {}));
var NotificationType;
(function(NotificationType2) {
  NotificationType2["Success"] = "SUCCESS";
  NotificationType2["Warning"] = "WARNING";
  NotificationType2["Error"] = "ERROR";
})(NotificationType || (NotificationType = {}));
const HapticEngine = {
  getEngine() {
    const tapticEngine = window.TapticEngine;
    if (tapticEngine) {
      return tapticEngine;
    }
    const capacitor = getCapacitor();
    if (capacitor === null || capacitor === void 0 ? void 0 : capacitor.isPluginAvailable("Haptics")) {
      return capacitor.Plugins.Haptics;
    }
    return void 0;
  },
  available() {
    const engine = this.getEngine();
    if (!engine) {
      return false;
    }
    const capacitor = getCapacitor();
    if ((capacitor === null || capacitor === void 0 ? void 0 : capacitor.getPlatform()) === "web") {
      return typeof navigator !== "undefined" && navigator.vibrate !== void 0;
    }
    return true;
  },
  isCordova() {
    return window.TapticEngine !== void 0;
  },
  isCapacitor() {
    return getCapacitor() !== void 0;
  },
  impact(options) {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    const style = this.isCapacitor() ? options.style : options.style.toLowerCase();
    engine.impact({ style });
  },
  notification(options) {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    const type = this.isCapacitor() ? options.type : options.type.toLowerCase();
    engine.notification({ type });
  },
  selection() {
    const style = this.isCapacitor() ? ImpactStyle.Light : "light";
    this.impact({ style });
  },
  selectionStart() {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    if (this.isCapacitor()) {
      engine.selectionStart();
    } else {
      engine.gestureSelectionStart();
    }
  },
  selectionChanged() {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    if (this.isCapacitor()) {
      engine.selectionChanged();
    } else {
      engine.gestureSelectionChanged();
    }
  },
  selectionEnd() {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    if (this.isCapacitor()) {
      engine.selectionEnd();
    } else {
      engine.gestureSelectionEnd();
    }
  }
};
const hapticAvailable = () => {
  return HapticEngine.available();
};
const hapticSelection = () => {
  hapticAvailable() && HapticEngine.selection();
};
const hapticSelectionStart = () => {
  hapticAvailable() && HapticEngine.selectionStart();
};
const hapticSelectionChanged = () => {
  hapticAvailable() && HapticEngine.selectionChanged();
};
const hapticSelectionEnd = () => {
  hapticAvailable() && HapticEngine.selectionEnd();
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const createLockController = () => {
  let waitPromise;
  const lock = async () => {
    const p2 = waitPromise;
    let resolve2;
    waitPromise = new Promise((r2) => resolve2 = r2);
    if (p2 !== void 0) {
      await p2;
    }
    return resolve2;
  };
  return {
    lock
  };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const ION_CONTENT_TAG_NAME = "ION-CONTENT";
const ION_CONTENT_ELEMENT_SELECTOR = "ion-content";
const ION_CONTENT_CLASS_SELECTOR = ".ion-content-scroll-host";
const ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;
const isIonContent = (el2) => el2.tagName === ION_CONTENT_TAG_NAME;
const getScrollElement = async (el2) => {
  if (isIonContent(el2)) {
    await new Promise((resolve2) => componentOnReady(el2, resolve2));
    return el2.getScrollElement();
  }
  return el2;
};
const findIonContent = (el2) => {
  const customContentHost = el2.querySelector(ION_CONTENT_CLASS_SELECTOR);
  if (customContentHost) {
    return customContentHost;
  }
  return el2.querySelector(ION_CONTENT_SELECTOR);
};
const findClosestIonContent = (el2) => {
  return el2.closest(ION_CONTENT_SELECTOR);
};
const scrollToTop = (el2, durationMs) => {
  if (isIonContent(el2)) {
    const content = el2;
    return content.scrollToTop(durationMs);
  }
  return Promise.resolve(el2.scrollTo({
    top: 0,
    left: 0,
    behavior: durationMs > 0 ? "smooth" : "auto"
  }));
};
const scrollByPoint = (el2, x2, y2, durationMs) => {
  if (isIonContent(el2)) {
    const content = el2;
    return content.scrollByPoint(x2, y2, durationMs);
  }
  return Promise.resolve(el2.scrollBy({
    top: y2,
    left: x2,
    behavior: durationMs > 0 ? "smooth" : "auto"
  }));
};
const printIonContentErrorMsg = (el2) => {
  return printRequiredElementError(el2, ION_CONTENT_ELEMENT_SELECTOR);
};
const disableContentScrollY = (contentEl) => {
  if (isIonContent(contentEl)) {
    const ionContent = contentEl;
    const initialScrollY = ionContent.scrollY;
    ionContent.scrollY = false;
    return initialScrollY;
  } else {
    contentEl.style.setProperty("overflow", "hidden");
    return true;
  }
};
const resetContentScrollY = (contentEl, initialScrollY) => {
  if (isIonContent(contentEl)) {
    contentEl.scrollY = initialScrollY;
  } else {
    contentEl.style.removeProperty("overflow");
  }
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
var ExceptionCode$1;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode$1 || (ExceptionCode$1 = {}));
var KeyboardResize;
(function(KeyboardResize2) {
  KeyboardResize2["Body"] = "body";
  KeyboardResize2["Ionic"] = "ionic";
  KeyboardResize2["Native"] = "native";
  KeyboardResize2["None"] = "none";
})(KeyboardResize || (KeyboardResize = {}));
const Keyboard = {
  getEngine() {
    const capacitor = getCapacitor();
    if (capacitor === null || capacitor === void 0 ? void 0 : capacitor.isPluginAvailable("Keyboard")) {
      return capacitor.Plugins.Keyboard;
    }
    return void 0;
  },
  getResizeMode() {
    const engine = this.getEngine();
    if (!(engine === null || engine === void 0 ? void 0 : engine.getResizeMode)) {
      return Promise.resolve(void 0);
    }
    return engine.getResizeMode().catch((e2) => {
      if (e2.code === ExceptionCode$1.Unimplemented) {
        return void 0;
      }
      throw e2;
    });
  }
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getResizeContainer = (resizeMode) => {
  if (doc === void 0 || resizeMode === KeyboardResize.None || resizeMode === void 0) {
    return null;
  }
  const ionApp = doc.querySelector("ion-app");
  return ionApp !== null && ionApp !== void 0 ? ionApp : doc.body;
};
const getResizeContainerHeight = (resizeMode) => {
  const containerElement = getResizeContainer(resizeMode);
  return containerElement === null ? 0 : containerElement.clientHeight;
};
const createKeyboardController = async (keyboardChangeCallback) => {
  let keyboardWillShowHandler;
  let keyboardWillHideHandler;
  let keyboardVisible;
  let initialResizeContainerHeight;
  const init2 = async () => {
    const resizeOptions = await Keyboard.getResizeMode();
    const resizeMode = resizeOptions === void 0 ? void 0 : resizeOptions.mode;
    keyboardWillShowHandler = () => {
      if (initialResizeContainerHeight === void 0) {
        initialResizeContainerHeight = getResizeContainerHeight(resizeMode);
      }
      keyboardVisible = true;
      fireChangeCallback(keyboardVisible, resizeMode);
    };
    keyboardWillHideHandler = () => {
      keyboardVisible = false;
      fireChangeCallback(keyboardVisible, resizeMode);
    };
    win$1 === null || win$1 === void 0 ? void 0 : win$1.addEventListener("keyboardWillShow", keyboardWillShowHandler);
    win$1 === null || win$1 === void 0 ? void 0 : win$1.addEventListener("keyboardWillHide", keyboardWillHideHandler);
  };
  const fireChangeCallback = (state, resizeMode) => {
    if (keyboardChangeCallback) {
      keyboardChangeCallback(state, createResizePromiseIfNeeded(resizeMode));
    }
  };
  const createResizePromiseIfNeeded = (resizeMode) => {
    if (
      /**
       * If we are in an SSR environment then there is
       * no window to resize. Additionally, if there
       * is no resize mode or the resize mode is "None"
       * then initialResizeContainerHeight will be 0
       */
      initialResizeContainerHeight === 0 || /**
       * If the keyboard is closed before the webview resizes initially
       * then the webview will never resize.
       */
      initialResizeContainerHeight === getResizeContainerHeight(resizeMode)
    ) {
      return;
    }
    const containerElement = getResizeContainer(resizeMode);
    if (containerElement === null) {
      return;
    }
    return new Promise((resolve2) => {
      const callback = () => {
        if (containerElement.clientHeight === initialResizeContainerHeight) {
          ro.disconnect();
          resolve2();
        }
      };
      const ro = new ResizeObserver(callback);
      ro.observe(containerElement);
    });
  };
  const destroy = () => {
    win$1 === null || win$1 === void 0 ? void 0 : win$1.removeEventListener("keyboardWillShow", keyboardWillShowHandler);
    win$1 === null || win$1 === void 0 ? void 0 : win$1.removeEventListener("keyboardWillHide", keyboardWillHideHandler);
    keyboardWillShowHandler = keyboardWillHideHandler = void 0;
  };
  const isKeyboardVisible = () => keyboardVisible;
  await init2();
  return { init: init2, destroy, isKeyboardVisible };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const handleFooterFade = (scrollEl, baseEl) => {
  readTask(() => {
    const scrollTop = scrollEl.scrollTop;
    const maxScroll = scrollEl.scrollHeight - scrollEl.clientHeight;
    const fadeDuration = 10;
    const fadeStart = maxScroll - fadeDuration;
    const distanceToStart = scrollTop - fadeStart;
    const scale = clamp(0, 1 - distanceToStart / fadeDuration, 1);
    writeTask(() => {
      baseEl.style.setProperty("--opacity-scale", scale.toString());
    });
  });
};
const footerIosCss = "ion-footer{display:block;position:relative;-ms-flex-order:1;order:1;width:100%;z-index:10}ion-footer.footer-toolbar-padding ion-toolbar:last-of-type{padding-bottom:var(--ion-safe-area-bottom, 0)}.footer-ios ion-toolbar:first-of-type{--border-width:0.55px 0 0}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.footer-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.footer-translucent-ios ion-toolbar{--opacity:.8}}.footer-ios.ion-no-border ion-toolbar:first-of-type{--border-width:0}.footer-collapse-fade ion-toolbar{--opacity-scale:inherit}";
const IonFooterIosStyle0 = footerIosCss;
const footerMdCss = "ion-footer{display:block;position:relative;-ms-flex-order:1;order:1;width:100%;z-index:10}ion-footer.footer-toolbar-padding ion-toolbar:last-of-type{padding-bottom:var(--ion-safe-area-bottom, 0)}.footer-md{-webkit-box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12)}.footer-md.ion-no-border{-webkit-box-shadow:none;box-shadow:none}";
const IonFooterMdStyle0 = footerMdCss;
const Footer = /* @__PURE__ */ proxyCustomElement(class Footer2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.keyboardCtrl = null;
    this.checkCollapsibleFooter = () => {
      const mode = getIonMode$2(this);
      if (mode !== "ios") {
        return;
      }
      const { collapse } = this;
      const hasFade = collapse === "fade";
      this.destroyCollapsibleFooter();
      if (hasFade) {
        const pageEl = this.el.closest("ion-app,ion-page,.ion-page,page-inner");
        const contentEl = pageEl ? findIonContent(pageEl) : null;
        if (!contentEl) {
          printIonContentErrorMsg(this.el);
          return;
        }
        this.setupFadeFooter(contentEl);
      }
    };
    this.setupFadeFooter = async (contentEl) => {
      const scrollEl = this.scrollEl = await getScrollElement(contentEl);
      this.contentScrollCallback = () => {
        handleFooterFade(scrollEl, this.el);
      };
      scrollEl.addEventListener("scroll", this.contentScrollCallback);
      handleFooterFade(scrollEl, this.el);
    };
    this.keyboardVisible = false;
    this.collapse = void 0;
    this.translucent = false;
  }
  componentDidLoad() {
    this.checkCollapsibleFooter();
  }
  componentDidUpdate() {
    this.checkCollapsibleFooter();
  }
  async connectedCallback() {
    this.keyboardCtrl = await createKeyboardController(async (keyboardOpen2, waitForResize) => {
      if (keyboardOpen2 === false && waitForResize !== void 0) {
        await waitForResize;
      }
      this.keyboardVisible = keyboardOpen2;
    });
  }
  disconnectedCallback() {
    if (this.keyboardCtrl) {
      this.keyboardCtrl.destroy();
    }
  }
  destroyCollapsibleFooter() {
    if (this.scrollEl && this.contentScrollCallback) {
      this.scrollEl.removeEventListener("scroll", this.contentScrollCallback);
      this.contentScrollCallback = void 0;
    }
  }
  render() {
    const { translucent, collapse } = this;
    const mode = getIonMode$2(this);
    const tabs = this.el.closest("ion-tabs");
    const tabBar = tabs === null || tabs === void 0 ? void 0 : tabs.querySelector(":scope > ion-tab-bar");
    return h$1(Host, { key: "550b8b8fb614e541e1d369fc1ac5ba1f083913b4", role: "contentinfo", class: {
      [mode]: true,
      // Used internally for styling
      [`footer-${mode}`]: true,
      [`footer-translucent`]: translucent,
      [`footer-translucent-${mode}`]: translucent,
      ["footer-toolbar-padding"]: !this.keyboardVisible && (!tabBar || tabBar.slot !== "bottom"),
      [`footer-collapse-${collapse}`]: collapse !== void 0
    } }, mode === "ios" && translucent && h$1("div", { class: "footer-background" }), h$1("slot", { key: "d25187ecc2ce7848ba882af078cb634e9d5e8814" }));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonFooterIosStyle0,
      md: IonFooterMdStyle0
    };
  }
}, [36, "ion-footer", {
  "collapse": [1],
  "translucent": [4],
  "keyboardVisible": [32]
}]);
function defineCustomElement$1$h() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-footer"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-footer":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Footer);
        }
        break;
    }
  });
}
const defineCustomElement$r = defineCustomElement$1$h;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const gridCss = ":host{-webkit-padding-start:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;display:block;-ms-flex:1;flex:1}@media (min-width: 576px){:host{-webkit-padding-start:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px))}}@media (min-width: 768px){:host{-webkit-padding-start:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px))}}@media (min-width: 992px){:host{-webkit-padding-start:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px))}}@media (min-width: 1200px){:host{-webkit-padding-start:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px))}}:host(.grid-fixed){width:var(--ion-grid-width-xs, var(--ion-grid-width, 100%));max-width:100%}@media (min-width: 576px){:host(.grid-fixed){width:var(--ion-grid-width-sm, var(--ion-grid-width, 540px))}}@media (min-width: 768px){:host(.grid-fixed){width:var(--ion-grid-width-md, var(--ion-grid-width, 720px))}}@media (min-width: 992px){:host(.grid-fixed){width:var(--ion-grid-width-lg, var(--ion-grid-width, 960px))}}@media (min-width: 1200px){:host(.grid-fixed){width:var(--ion-grid-width-xl, var(--ion-grid-width, 1140px))}}:host(.ion-no-padding){--ion-grid-column-padding:0;--ion-grid-column-padding-xs:0;--ion-grid-column-padding-sm:0;--ion-grid-column-padding-md:0;--ion-grid-column-padding-lg:0;--ion-grid-column-padding-xl:0}";
const IonGridStyle0 = gridCss;
const Grid = /* @__PURE__ */ proxyCustomElement(class Grid2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.fixed = false;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "03a8975bb9320192033219fc9e06fe7afa4fae4a", class: {
      [mode]: true,
      "grid-fixed": this.fixed
    } }, h$1("slot", { key: "8d95abb4614e73a46a274668c13fe7c7f011c537" }));
  }
  static get style() {
    return IonGridStyle0;
  }
}, [1, "ion-grid", {
  "fixed": [4]
}]);
function defineCustomElement$1$g() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-grid"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-grid":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Grid);
        }
        break;
    }
  });
}
const defineCustomElement$q = defineCustomElement$1$g;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const TRANSITION = "all 0.2s ease-in-out";
const cloneElement = (tagName) => {
  const getCachedEl = document.querySelector(`${tagName}.ion-cloned-element`);
  if (getCachedEl !== null) {
    return getCachedEl;
  }
  const clonedEl = document.createElement(tagName);
  clonedEl.classList.add("ion-cloned-element");
  clonedEl.style.setProperty("display", "none");
  document.body.appendChild(clonedEl);
  return clonedEl;
};
const createHeaderIndex = (headerEl) => {
  if (!headerEl) {
    return;
  }
  const toolbars = headerEl.querySelectorAll("ion-toolbar");
  return {
    el: headerEl,
    toolbars: Array.from(toolbars).map((toolbar) => {
      const ionTitleEl = toolbar.querySelector("ion-title");
      return {
        el: toolbar,
        background: toolbar.shadowRoot.querySelector(".toolbar-background"),
        ionTitleEl,
        innerTitleEl: ionTitleEl ? ionTitleEl.shadowRoot.querySelector(".toolbar-title") : null,
        ionButtonsEl: Array.from(toolbar.querySelectorAll("ion-buttons"))
      };
    })
  };
};
const handleContentScroll = (scrollEl, scrollHeaderIndex, contentEl) => {
  readTask(() => {
    const scrollTop = scrollEl.scrollTop;
    const scale = clamp(1, 1 + -scrollTop / 500, 1.1);
    const nativeRefresher = contentEl.querySelector("ion-refresher.refresher-native");
    if (nativeRefresher === null) {
      writeTask(() => {
        scaleLargeTitles(scrollHeaderIndex.toolbars, scale);
      });
    }
  });
};
const setToolbarBackgroundOpacity = (headerEl, opacity) => {
  if (headerEl.collapse === "fade") {
    return;
  }
  if (opacity === void 0) {
    headerEl.style.removeProperty("--opacity-scale");
  } else {
    headerEl.style.setProperty("--opacity-scale", opacity.toString());
  }
};
const handleToolbarBorderIntersection = (ev, mainHeaderIndex, scrollTop) => {
  if (!ev[0].isIntersecting) {
    return;
  }
  const scale = ev[0].intersectionRatio > 0.9 || scrollTop <= 0 ? 0 : (1 - ev[0].intersectionRatio) * 100 / 75;
  setToolbarBackgroundOpacity(mainHeaderIndex.el, scale === 1 ? void 0 : scale);
};
const handleToolbarIntersection = (ev, mainHeaderIndex, scrollHeaderIndex, scrollEl) => {
  writeTask(() => {
    const scrollTop = scrollEl.scrollTop;
    handleToolbarBorderIntersection(ev, mainHeaderIndex, scrollTop);
    const event = ev[0];
    const intersection = event.intersectionRect;
    const intersectionArea = intersection.width * intersection.height;
    const rootArea = event.rootBounds.width * event.rootBounds.height;
    const isPageHidden = intersectionArea === 0 && rootArea === 0;
    const leftDiff = Math.abs(intersection.left - event.boundingClientRect.left);
    const rightDiff = Math.abs(intersection.right - event.boundingClientRect.right);
    const isPageTransitioning = intersectionArea > 0 && (leftDiff >= 5 || rightDiff >= 5);
    if (isPageHidden || isPageTransitioning) {
      return;
    }
    if (event.isIntersecting) {
      setHeaderActive(mainHeaderIndex, false);
      setHeaderActive(scrollHeaderIndex);
    } else {
      const hasValidIntersection = intersection.x === 0 && intersection.y === 0 || intersection.width !== 0 && intersection.height !== 0;
      if (hasValidIntersection && scrollTop > 0) {
        setHeaderActive(mainHeaderIndex);
        setHeaderActive(scrollHeaderIndex, false);
        setToolbarBackgroundOpacity(mainHeaderIndex.el);
      }
    }
  });
};
const setHeaderActive = (headerIndex, active = true) => {
  const headerEl = headerIndex.el;
  if (active) {
    headerEl.classList.remove("header-collapse-condense-inactive");
    headerEl.removeAttribute("aria-hidden");
  } else {
    headerEl.classList.add("header-collapse-condense-inactive");
    headerEl.setAttribute("aria-hidden", "true");
  }
};
const scaleLargeTitles = (toolbars = [], scale = 1, transition2 = false) => {
  toolbars.forEach((toolbar) => {
    const ionTitle = toolbar.ionTitleEl;
    const titleDiv = toolbar.innerTitleEl;
    if (!ionTitle || ionTitle.size !== "large") {
      return;
    }
    titleDiv.style.transition = transition2 ? TRANSITION : "";
    titleDiv.style.transform = `scale3d(${scale}, ${scale}, 1)`;
  });
};
const handleHeaderFade = (scrollEl, baseEl, condenseHeader) => {
  readTask(() => {
    const scrollTop = scrollEl.scrollTop;
    const baseElHeight = baseEl.clientHeight;
    const fadeStart = condenseHeader ? condenseHeader.clientHeight : 0;
    if (condenseHeader !== null && scrollTop < fadeStart) {
      baseEl.style.setProperty("--opacity-scale", "0");
      scrollEl.style.setProperty("clip-path", `inset(${baseElHeight}px 0px 0px 0px)`);
      return;
    }
    const distanceToStart = scrollTop - fadeStart;
    const fadeDuration = 10;
    const scale = clamp(0, distanceToStart / fadeDuration, 1);
    writeTask(() => {
      scrollEl.style.removeProperty("clip-path");
      baseEl.style.setProperty("--opacity-scale", scale.toString());
    });
  });
};
const headerIosCss = "ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-ios ion-toolbar:last-of-type{--border-width:0 0 0.55px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.header-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.header-translucent-ios ion-toolbar{--opacity:.8}.header-collapse-condense-inactive .header-background{-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}}.header-ios.ion-no-border ion-toolbar:last-of-type{--border-width:0}.header-collapse-fade ion-toolbar{--opacity-scale:inherit}.header-collapse-condense{z-index:9}.header-collapse-condense ion-toolbar{position:-webkit-sticky;position:sticky;top:0}.header-collapse-condense ion-toolbar:first-of-type{padding-top:0px;z-index:1}.header-collapse-condense ion-toolbar{--background:var(--ion-background-color, #fff);z-index:0}.header-collapse-condense ion-toolbar:last-of-type{--border-width:0px}.header-collapse-condense ion-toolbar ion-searchbar{padding-top:0px;padding-bottom:13px}.header-collapse-main{--opacity-scale:1}.header-collapse-main ion-toolbar{--opacity-scale:inherit}.header-collapse-main ion-toolbar.in-toolbar ion-title,.header-collapse-main ion-toolbar.in-toolbar ion-buttons{-webkit-transition:all 0.2s ease-in-out;transition:all 0.2s ease-in-out}.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-buttons.buttons-collapse{opacity:0;pointer-events:none}.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-buttons.buttons-collapse{visibility:hidden}ion-header:not(.header-collapse-main):has(~ion-content ion-header[collapse=condense],~ion-content ion-header.header-collapse-condense){opacity:0}";
const IonHeaderIosStyle0 = headerIosCss;
const headerMdCss = "ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-md{-webkit-box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12)}.header-collapse-condense{display:none}.header-md.ion-no-border{-webkit-box-shadow:none;box-shadow:none}";
const IonHeaderMdStyle0 = headerMdCss;
const Header = /* @__PURE__ */ proxyCustomElement(class Header2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.inheritedAttributes = {};
    this.setupFadeHeader = async (contentEl, condenseHeader) => {
      const scrollEl = this.scrollEl = await getScrollElement(contentEl);
      this.contentScrollCallback = () => {
        handleHeaderFade(this.scrollEl, this.el, condenseHeader);
      };
      scrollEl.addEventListener("scroll", this.contentScrollCallback);
      handleHeaderFade(this.scrollEl, this.el, condenseHeader);
    };
    this.collapse = void 0;
    this.translucent = false;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  componentDidLoad() {
    this.checkCollapsibleHeader();
  }
  componentDidUpdate() {
    this.checkCollapsibleHeader();
  }
  disconnectedCallback() {
    this.destroyCollapsibleHeader();
  }
  async checkCollapsibleHeader() {
    const mode = getIonMode$2(this);
    if (mode !== "ios") {
      return;
    }
    const { collapse } = this;
    const hasCondense = collapse === "condense";
    const hasFade = collapse === "fade";
    this.destroyCollapsibleHeader();
    if (hasCondense) {
      const pageEl = this.el.closest("ion-app,ion-page,.ion-page,page-inner");
      const contentEl = pageEl ? findIonContent(pageEl) : null;
      writeTask(() => {
        const title2 = cloneElement("ion-title");
        title2.size = "large";
        cloneElement("ion-back-button");
      });
      await this.setupCondenseHeader(contentEl, pageEl);
    } else if (hasFade) {
      const pageEl = this.el.closest("ion-app,ion-page,.ion-page,page-inner");
      const contentEl = pageEl ? findIonContent(pageEl) : null;
      if (!contentEl) {
        printIonContentErrorMsg(this.el);
        return;
      }
      const condenseHeader = contentEl.querySelector('ion-header[collapse="condense"]');
      await this.setupFadeHeader(contentEl, condenseHeader);
    }
  }
  destroyCollapsibleHeader() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      this.intersectionObserver = void 0;
    }
    if (this.scrollEl && this.contentScrollCallback) {
      this.scrollEl.removeEventListener("scroll", this.contentScrollCallback);
      this.contentScrollCallback = void 0;
    }
    if (this.collapsibleMainHeader) {
      this.collapsibleMainHeader.classList.remove("header-collapse-main");
      this.collapsibleMainHeader = void 0;
    }
  }
  async setupCondenseHeader(contentEl, pageEl) {
    if (!contentEl || !pageEl) {
      printIonContentErrorMsg(this.el);
      return;
    }
    if (typeof IntersectionObserver === "undefined") {
      return;
    }
    this.scrollEl = await getScrollElement(contentEl);
    const headers = pageEl.querySelectorAll("ion-header");
    this.collapsibleMainHeader = Array.from(headers).find((header) => header.collapse !== "condense");
    if (!this.collapsibleMainHeader) {
      return;
    }
    const mainHeaderIndex = createHeaderIndex(this.collapsibleMainHeader);
    const scrollHeaderIndex = createHeaderIndex(this.el);
    if (!mainHeaderIndex || !scrollHeaderIndex) {
      return;
    }
    setHeaderActive(mainHeaderIndex, false);
    setToolbarBackgroundOpacity(mainHeaderIndex.el, 0);
    const toolbarIntersection = (ev) => {
      handleToolbarIntersection(ev, mainHeaderIndex, scrollHeaderIndex, this.scrollEl);
    };
    this.intersectionObserver = new IntersectionObserver(toolbarIntersection, {
      root: contentEl,
      threshold: [0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
    });
    this.intersectionObserver.observe(scrollHeaderIndex.toolbars[scrollHeaderIndex.toolbars.length - 1].el);
    this.contentScrollCallback = () => {
      handleContentScroll(this.scrollEl, scrollHeaderIndex, contentEl);
    };
    this.scrollEl.addEventListener("scroll", this.contentScrollCallback);
    writeTask(() => {
      if (this.collapsibleMainHeader !== void 0) {
        this.collapsibleMainHeader.classList.add("header-collapse-main");
      }
    });
  }
  render() {
    const { translucent, inheritedAttributes } = this;
    const mode = getIonMode$2(this);
    const collapse = this.collapse || "none";
    const roleType = hostContext("ion-menu", this.el) ? "none" : "banner";
    return h$1(Host, Object.assign({ key: "a33e7e1818cb4718ae36b8bcfa811c4138b85fac", role: roleType, class: {
      [mode]: true,
      // Used internally for styling
      [`header-${mode}`]: true,
      [`header-translucent`]: this.translucent,
      [`header-collapse-${collapse}`]: true,
      [`header-translucent-${mode}`]: this.translucent
    } }, inheritedAttributes), mode === "ios" && translucent && h$1("div", { class: "header-background" }), h$1("slot", { key: "7e2fa75034f7422a3dc5691e9b3c25393e16c0ca" }));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonHeaderIosStyle0,
      md: IonHeaderMdStyle0
    };
  }
}, [36, "ion-header", {
  "collapse": [1],
  "translucent": [4]
}]);
function defineCustomElement$1$f() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-header"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-header":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Header);
        }
        break;
    }
  });
}
const defineCustomElement$p = defineCustomElement$1$f;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const spinners = {
  bubbles: {
    dur: 1e3,
    circles: 9,
    fn: (dur, index, total) => {
      const animationDelay = `${dur * index / total - dur}ms`;
      const angle = 2 * Math.PI * index / total;
      return {
        r: 5,
        style: {
          top: `${32 * Math.sin(angle)}%`,
          left: `${32 * Math.cos(angle)}%`,
          "animation-delay": animationDelay
        }
      };
    }
  },
  circles: {
    dur: 1e3,
    circles: 8,
    fn: (dur, index, total) => {
      const step = index / total;
      const animationDelay = `${dur * step - dur}ms`;
      const angle = 2 * Math.PI * step;
      return {
        r: 5,
        style: {
          top: `${32 * Math.sin(angle)}%`,
          left: `${32 * Math.cos(angle)}%`,
          "animation-delay": animationDelay
        }
      };
    }
  },
  circular: {
    dur: 1400,
    elmDuration: true,
    circles: 1,
    fn: () => {
      return {
        r: 20,
        cx: 48,
        cy: 48,
        fill: "none",
        viewBox: "24 24 48 48",
        transform: "translate(0,0)",
        style: {}
      };
    }
  },
  crescent: {
    dur: 750,
    circles: 1,
    fn: () => {
      return {
        r: 26,
        style: {}
      };
    }
  },
  dots: {
    dur: 750,
    circles: 3,
    fn: (_, index) => {
      const animationDelay = -(110 * index) + "ms";
      return {
        r: 6,
        style: {
          left: `${32 - 32 * index}%`,
          "animation-delay": animationDelay
        }
      };
    }
  },
  lines: {
    dur: 1e3,
    lines: 8,
    fn: (dur, index, total) => {
      const transform = `rotate(${360 / total * index + (index < total / 2 ? 180 : -180)}deg)`;
      const animationDelay = `${dur * index / total - dur}ms`;
      return {
        y1: 14,
        y2: 26,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-small": {
    dur: 1e3,
    lines: 8,
    fn: (dur, index, total) => {
      const transform = `rotate(${360 / total * index + (index < total / 2 ? 180 : -180)}deg)`;
      const animationDelay = `${dur * index / total - dur}ms`;
      return {
        y1: 12,
        y2: 20,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-sharp": {
    dur: 1e3,
    lines: 12,
    fn: (dur, index, total) => {
      const transform = `rotate(${30 * index + (index < 6 ? 180 : -180)}deg)`;
      const animationDelay = `${dur * index / total - dur}ms`;
      return {
        y1: 17,
        y2: 29,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-sharp-small": {
    dur: 1e3,
    lines: 12,
    fn: (dur, index, total) => {
      const transform = `rotate(${30 * index + (index < 6 ? 180 : -180)}deg)`;
      const animationDelay = `${dur * index / total - dur}ms`;
      return {
        y1: 12,
        y2: 20,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  }
};
const SPINNERS = spinners;
const spinnerCss = ":host{display:inline-block;position:relative;width:28px;height:28px;color:var(--color);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.ion-color){color:var(--ion-color-base)}svg{-webkit-transform-origin:center;transform-origin:center;position:absolute;top:0;left:0;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0)}:host-context([dir=rtl]) svg{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}[dir=rtl] svg{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}@supports selector(:dir(rtl)){svg:dir(rtl){-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}}:host(.spinner-lines) line,:host(.spinner-lines-small) line{stroke-width:7px}:host(.spinner-lines-sharp) line,:host(.spinner-lines-sharp-small) line{stroke-width:4px}:host(.spinner-lines) line,:host(.spinner-lines-small) line,:host(.spinner-lines-sharp) line,:host(.spinner-lines-sharp-small) line{stroke-linecap:round;stroke:currentColor}:host(.spinner-lines) svg,:host(.spinner-lines-small) svg,:host(.spinner-lines-sharp) svg,:host(.spinner-lines-sharp-small) svg{-webkit-animation:spinner-fade-out 1s linear infinite;animation:spinner-fade-out 1s linear infinite}:host(.spinner-bubbles) svg{-webkit-animation:spinner-scale-out 1s linear infinite;animation:spinner-scale-out 1s linear infinite;fill:currentColor}:host(.spinner-circles) svg{-webkit-animation:spinner-fade-out 1s linear infinite;animation:spinner-fade-out 1s linear infinite;fill:currentColor}:host(.spinner-crescent) circle{fill:transparent;stroke-width:4px;stroke-dasharray:128px;stroke-dashoffset:82px;stroke:currentColor}:host(.spinner-crescent) svg{-webkit-animation:spinner-rotate 1s linear infinite;animation:spinner-rotate 1s linear infinite}:host(.spinner-dots) circle{stroke-width:0;fill:currentColor}:host(.spinner-dots) svg{-webkit-animation:spinner-dots 1s linear infinite;animation:spinner-dots 1s linear infinite}:host(.spinner-circular) svg{-webkit-animation:spinner-circular linear infinite;animation:spinner-circular linear infinite}:host(.spinner-circular) circle{-webkit-animation:spinner-circular-inner ease-in-out infinite;animation:spinner-circular-inner ease-in-out infinite;stroke:currentColor;stroke-dasharray:80px, 200px;stroke-dashoffset:0px;stroke-width:5.6;fill:none}:host(.spinner-paused),:host(.spinner-paused) svg,:host(.spinner-paused) circle{-webkit-animation-play-state:paused;animation-play-state:paused}@-webkit-keyframes spinner-fade-out{0%{opacity:1}100%{opacity:0}}@keyframes spinner-fade-out{0%{opacity:1}100%{opacity:0}}@-webkit-keyframes spinner-scale-out{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1)}100%{-webkit-transform:scale(0, 0);transform:scale(0, 0)}}@keyframes spinner-scale-out{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1)}100%{-webkit-transform:scale(0, 0);transform:scale(0, 0)}}@-webkit-keyframes spinner-rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes spinner-dots{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}50%{-webkit-transform:scale(0.4, 0.4);transform:scale(0.4, 0.4);opacity:0.3}100%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}}@keyframes spinner-dots{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}50%{-webkit-transform:scale(0.4, 0.4);transform:scale(0.4, 0.4);opacity:0.3}100%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}}@-webkit-keyframes spinner-circular{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-circular{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes spinner-circular-inner{0%{stroke-dasharray:1px, 200px;stroke-dashoffset:0px}50%{stroke-dasharray:100px, 200px;stroke-dashoffset:-15px}100%{stroke-dasharray:100px, 200px;stroke-dashoffset:-125px}}@keyframes spinner-circular-inner{0%{stroke-dasharray:1px, 200px;stroke-dashoffset:0px}50%{stroke-dasharray:100px, 200px;stroke-dashoffset:-15px}100%{stroke-dasharray:100px, 200px;stroke-dashoffset:-125px}}";
const IonSpinnerStyle0 = spinnerCss;
const Spinner = /* @__PURE__ */ proxyCustomElement(class Spinner2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
    this.duration = void 0;
    this.name = void 0;
    this.paused = false;
  }
  getName() {
    const spinnerName = this.name || config$1.get("spinner");
    const mode = getIonMode$2(this);
    if (spinnerName) {
      return spinnerName;
    }
    return mode === "ios" ? "lines" : "circular";
  }
  render() {
    var _a;
    const self2 = this;
    const mode = getIonMode$2(self2);
    const spinnerName = self2.getName();
    const spinner = (_a = SPINNERS[spinnerName]) !== null && _a !== void 0 ? _a : SPINNERS["lines"];
    const duration = typeof self2.duration === "number" && self2.duration > 10 ? self2.duration : spinner.dur;
    const svgs = [];
    if (spinner.circles !== void 0) {
      for (let i = 0; i < spinner.circles; i++) {
        svgs.push(buildCircle(spinner, duration, i, spinner.circles));
      }
    } else if (spinner.lines !== void 0) {
      for (let i = 0; i < spinner.lines; i++) {
        svgs.push(buildLine(spinner, duration, i, spinner.lines));
      }
    }
    return h$1(Host, { key: "47cd6cd98e36e5b99fbe263a6a102610cae240c3", class: createColorClasses$2(self2.color, {
      [mode]: true,
      [`spinner-${spinnerName}`]: true,
      "spinner-paused": self2.paused || config$1.getBoolean("_testing")
    }), role: "progressbar", style: spinner.elmDuration ? { animationDuration: duration + "ms" } : {} }, svgs);
  }
  static get style() {
    return IonSpinnerStyle0;
  }
}, [1, "ion-spinner", {
  "color": [513],
  "duration": [2],
  "name": [1],
  "paused": [4]
}]);
const buildCircle = (spinner, duration, index, total) => {
  const data = spinner.fn(duration, index, total);
  data.style["animation-duration"] = duration + "ms";
  return h$1("svg", { viewBox: data.viewBox || "0 0 64 64", style: data.style }, h$1("circle", { transform: data.transform || "translate(32,32)", cx: data.cx, cy: data.cy, r: data.r, style: spinner.elmDuration ? { animationDuration: duration + "ms" } : {} }));
};
const buildLine = (spinner, duration, index, total) => {
  const data = spinner.fn(duration, index, total);
  data.style["animation-duration"] = duration + "ms";
  return h$1("svg", { viewBox: data.viewBox || "0 0 64 64", style: data.style }, h$1("line", { transform: "translate(32,32)", y1: data.y1, y2: data.y2 }));
};
function defineCustomElement$o() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-spinner"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-spinner":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Spinner);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$n = defineCustomElement$s;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const listIosCss = "ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-ios{background:var(--ion-item-background, var(--ion-background-color, #fff))}.list-ios.list-inset{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:16px;margin-bottom:16px;border-radius:10px}.list-ios.list-inset ion-item:only-child,.list-ios.list-inset ion-item:not(:only-of-type):last-of-type,.list-ios.list-inset ion-item-sliding:last-of-type ion-item{--border-width:0;--inner-border-width:0}.list-ios.list-inset+ion-list.list-inset{margin-top:0}.list-ios-lines-none .item-lines-default{--inner-border-width:0px;--border-width:0px}.list-ios-lines-full .item-lines-default{--inner-border-width:0px;--border-width:0 0 0.55px 0}.list-ios-lines-inset .item-lines-default{--inner-border-width:0 0 0.55px 0;--border-width:0px}ion-card .list-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}";
const IonListIosStyle0 = listIosCss;
const listMdCss = "ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:8px;padding-bottom:8px;background:var(--ion-item-background, var(--ion-background-color, #fff))}@supports (inset-inline-start: 0){.list-md>.input:last-child::after{inset-inline-start:0}}@supports not (inset-inline-start: 0){.list-md>.input:last-child::after{left:0}:host-context([dir=rtl]) .list-md>.input:last-child::after{left:unset;right:unset;right:0}[dir=rtl] .list-md>.input:last-child::after{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.list-md>.input:last-child::after:dir(rtl){left:unset;right:unset;right:0}}}.list-md.list-inset{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:16px;margin-bottom:16px;border-radius:2px}.list-md.list-inset ion-item:not(:only-of-type):last-of-type,.list-md.list-inset ion-item-sliding:last-of-type ion-item{--border-width:0;--inner-border-width:0}.list-md.list-inset ion-item:only-child{--border-width:0;--inner-border-width:0}.list-md.list-inset+ion-list.list-inset{margin-top:0}.list-md-lines-none .item-lines-default{--inner-border-width:0px;--border-width:0px}.list-md-lines-full .item-lines-default{--inner-border-width:0px;--border-width:0 0 1px 0}.list-md-lines-inset .item-lines-default{--inner-border-width:0 0 1px 0;--border-width:0px}ion-card .list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}";
const IonListMdStyle0 = listMdCss;
const List = /* @__PURE__ */ proxyCustomElement(class List2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.lines = void 0;
    this.inset = false;
  }
  /**
   * If `ion-item-sliding` are used inside the list, this method closes
   * any open sliding item.
   *
   * Returns `true` if an actual `ion-item-sliding` is closed.
   */
  async closeSlidingItems() {
    const item = this.el.querySelector("ion-item-sliding");
    if (item === null || item === void 0 ? void 0 : item.closeOpened) {
      return item.closeOpened();
    }
    return false;
  }
  render() {
    const mode = getIonMode$2(this);
    const { lines, inset } = this;
    return h$1(Host, { key: "2cb1b689d9460d9576b471bb8b13d14fe34d1c2c", role: "list", class: {
      [mode]: true,
      // Used internally for styling
      [`list-${mode}`]: true,
      "list-inset": inset,
      [`list-lines-${lines}`]: lines !== void 0,
      [`list-${mode}-lines-${lines}`]: lines !== void 0
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonListIosStyle0,
      md: IonListMdStyle0
    };
  }
}, [32, "ion-list", {
  "lines": [1],
  "inset": [4],
  "closeSlidingItems": [64]
}]);
function defineCustomElement$m() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-list"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-list":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, List);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$l = defineCustomElement$m;
const VIEW_STATE_NEW = 1;
const VIEW_STATE_ATTACHED = 2;
const VIEW_STATE_DESTROYED = 3;
class ViewController {
  constructor(component, params) {
    this.component = component;
    this.params = params;
    this.state = VIEW_STATE_NEW;
  }
  async init(container) {
    this.state = VIEW_STATE_ATTACHED;
    if (!this.element) {
      const component = this.component;
      this.element = await attachComponent(this.delegate, container, component, ["ion-page", "ion-page-invisible"], this.params);
    }
  }
  /**
   * DOM WRITE
   */
  _destroy() {
    assert(this.state !== VIEW_STATE_DESTROYED, "view state must be ATTACHED");
    const element = this.element;
    if (element) {
      if (this.delegate) {
        this.delegate.removeViewFromDom(element.parentElement, element);
      } else {
        element.remove();
      }
    }
    this.nav = void 0;
    this.state = VIEW_STATE_DESTROYED;
  }
}
const matches = (view, id2, params) => {
  if (!view) {
    return false;
  }
  if (view.component !== id2) {
    return false;
  }
  return shallowEqualStringMap(view.params, params);
};
const convertToView = (page, params) => {
  if (!page) {
    return null;
  }
  if (page instanceof ViewController) {
    return page;
  }
  return new ViewController(page, params);
};
const convertToViews = (pages) => {
  return pages.map((page) => {
    if (page instanceof ViewController) {
      return page;
    }
    if ("component" in page) {
      return convertToView(page.component, page.componentProps === null ? void 0 : page.componentProps);
    }
    return convertToView(page, void 0);
  }).filter((v2) => v2 !== null);
};
const navCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;z-index:0}";
const IonNavStyle0 = navCss;
const Nav = /* @__PURE__ */ proxyCustomElement(class Nav2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionNavWillLoad = createEvent(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = createEvent(this, "ionNavWillChange", 3);
    this.ionNavDidChange = createEvent(this, "ionNavDidChange", 3);
    this.transInstr = [];
    this.gestureOrAnimationInProgress = false;
    this.useRouter = false;
    this.isTransitioning = false;
    this.destroyed = false;
    this.views = [];
    this.didLoad = false;
    this.delegate = void 0;
    this.swipeGesture = void 0;
    this.animated = true;
    this.animation = void 0;
    this.rootParams = void 0;
    this.root = void 0;
  }
  swipeGestureChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeGesture === true);
    }
  }
  rootChanged() {
    if (this.root === void 0) {
      return;
    }
    if (this.didLoad === false) {
      return;
    }
    if (!this.useRouter) {
      if (this.root !== void 0) {
        this.setRoot(this.root, this.rootParams);
      }
    }
  }
  componentWillLoad() {
    this.useRouter = document.querySelector("ion-router") !== null && this.el.closest("[no-router]") === null;
    if (this.swipeGesture === void 0) {
      const mode = getIonMode$2(this);
      this.swipeGesture = config$1.getBoolean("swipeBackEnabled", mode === "ios");
    }
    this.ionNavWillLoad.emit();
  }
  async componentDidLoad() {
    this.didLoad = true;
    this.rootChanged();
    this.gesture = (await __vitePreload(() => import("./swipe-back-DcwzW9An.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url)).createSwipeBackGesture(this.el, this.canStart.bind(this), this.onStart.bind(this), this.onMove.bind(this), this.onEnd.bind(this));
    this.swipeGestureChanged();
  }
  connectedCallback() {
    this.destroyed = false;
  }
  disconnectedCallback() {
    for (const view of this.views) {
      lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);
      view._destroy();
    }
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
    this.transInstr.length = 0;
    this.views.length = 0;
    this.destroyed = true;
  }
  /**
   * Push a new component onto the current navigation stack. Pass any additional
   * information along as an object. This additional information is accessible
   * through NavParams.
   *
   * @param component The component to push onto the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  push(component, componentProps, opts, done) {
    return this.insert(-1, component, componentProps, opts, done);
  }
  /**
   * Inserts a component into the navigation stack at the specified index.
   * This is useful to add a component at any point in the navigation stack.
   *
   * @param insertIndex The index to insert the component at in the stack.
   * @param component The component to insert into the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  insert(insertIndex, component, componentProps, opts, done) {
    return this.insertPages(insertIndex, [{ component, componentProps }], opts, done);
  }
  /**
   * Inserts an array of components into the navigation stack at the specified index.
   * The last component in the array will become instantiated as a view, and animate
   * in to become the active view.
   *
   * @param insertIndex The index to insert the components at in the stack.
   * @param insertComponents The components to insert into the navigation stack.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  insertPages(insertIndex, insertComponents, opts, done) {
    return this.queueTrns({
      insertStart: insertIndex,
      insertViews: insertComponents,
      opts
    }, done);
  }
  /**
   * Pop a component off of the navigation stack. Navigates back from the current
   * component.
   *
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  pop(opts, done) {
    return this.removeIndex(-1, 1, opts, done);
  }
  /**
   * Pop to a specific index in the navigation stack.
   *
   * @param indexOrViewCtrl The index or view controller to pop to.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  popTo(indexOrViewCtrl, opts, done) {
    const ti2 = {
      removeStart: -1,
      removeCount: -1,
      opts
    };
    if (typeof indexOrViewCtrl === "object" && indexOrViewCtrl.component) {
      ti2.removeView = indexOrViewCtrl;
      ti2.removeStart = 1;
    } else if (typeof indexOrViewCtrl === "number") {
      ti2.removeStart = indexOrViewCtrl + 1;
    }
    return this.queueTrns(ti2, done);
  }
  /**
   * Navigate back to the root of the stack, no matter how far back that is.
   *
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  popToRoot(opts, done) {
    return this.removeIndex(1, -1, opts, done);
  }
  /**
   * Removes a component from the navigation stack at the specified index.
   *
   * @param startIndex The number to begin removal at.
   * @param removeCount The number of components to remove.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  removeIndex(startIndex, removeCount = 1, opts, done) {
    return this.queueTrns({
      removeStart: startIndex,
      removeCount,
      opts
    }, done);
  }
  /**
   * Set the root for the current navigation stack to a component.
   *
   * @param component The component to set as the root of the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  setRoot(component, componentProps, opts, done) {
    return this.setPages([{ component, componentProps }], opts, done);
  }
  /**
   * Set the views of the current navigation stack and navigate to the last view.
   * By default animations are disabled, but they can be enabled by passing options
   * to the navigation controller. Navigation parameters can also be passed to the
   * individual pages in the array.
   *
   * @param views The list of views to set as the navigation stack.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  setPages(views, opts, done) {
    opts !== null && opts !== void 0 ? opts : opts = {};
    if (opts.animated !== true) {
      opts.animated = false;
    }
    return this.queueTrns({
      insertStart: 0,
      insertViews: views,
      removeStart: 0,
      removeCount: -1,
      opts
    }, done);
  }
  /**
   * Called by the router to update the view.
   *
   * @param id The component tag.
   * @param params The component params.
   * @param direction A direction hint.
   * @param animation an AnimationBuilder.
   *
   * @return the status.
   * @internal
   */
  setRouteId(id2, params, direction, animation2) {
    const active = this.getActiveSync();
    if (matches(active, id2, params)) {
      return Promise.resolve({
        changed: false,
        element: active.element
      });
    }
    let resolve2;
    const promise = new Promise((r2) => resolve2 = r2);
    let finish;
    const commonOpts = {
      updateURL: false,
      viewIsReady: (enteringEl) => {
        let mark;
        const p2 = new Promise((r2) => mark = r2);
        resolve2({
          changed: true,
          element: enteringEl,
          markVisible: async () => {
            mark();
            await finish;
          }
        });
        return p2;
      }
    };
    if (direction === "root") {
      finish = this.setRoot(id2, params, commonOpts);
    } else {
      const viewController = this.views.find((v2) => matches(v2, id2, params));
      if (viewController) {
        finish = this.popTo(viewController, Object.assign(Object.assign({}, commonOpts), { direction: "back", animationBuilder: animation2 }));
      } else if (direction === "forward") {
        finish = this.push(id2, params, Object.assign(Object.assign({}, commonOpts), { animationBuilder: animation2 }));
      } else if (direction === "back") {
        finish = this.setRoot(id2, params, Object.assign(Object.assign({}, commonOpts), { direction: "back", animated: true, animationBuilder: animation2 }));
      }
    }
    return promise;
  }
  /**
   * Called by <ion-router> to retrieve the current component.
   *
   * @internal
   */
  async getRouteId() {
    const active = this.getActiveSync();
    if (active) {
      return {
        id: active.element.tagName,
        params: active.params,
        element: active.element
      };
    }
    return void 0;
  }
  /**
   * Get the active view.
   */
  async getActive() {
    return this.getActiveSync();
  }
  /**
   * Get the view at the specified index.
   *
   * @param index The index of the view.
   */
  async getByIndex(index) {
    return this.views[index];
  }
  /**
   * Returns `true` if the current view can go back.
   *
   * @param view The view to check.
   */
  async canGoBack(view) {
    return this.canGoBackSync(view);
  }
  /**
   * Get the previous view.
   *
   * @param view The view to get.
   */
  async getPrevious(view) {
    return this.getPreviousSync(view);
  }
  getLength() {
    return this.views.length;
  }
  getActiveSync() {
    return this.views[this.views.length - 1];
  }
  canGoBackSync(view = this.getActiveSync()) {
    return !!(view && this.getPreviousSync(view));
  }
  getPreviousSync(view = this.getActiveSync()) {
    if (!view) {
      return void 0;
    }
    const views = this.views;
    const index = views.indexOf(view);
    return index > 0 ? views[index - 1] : void 0;
  }
  /**
   * Adds a navigation stack change to the queue and schedules it to run.
   *
   * @returns Whether the transition succeeds.
   */
  async queueTrns(ti2, done) {
    var _a, _b;
    if (this.isTransitioning && ((_a = ti2.opts) === null || _a === void 0 ? void 0 : _a.skipIfBusy)) {
      return false;
    }
    const promise = new Promise((resolve2, reject) => {
      ti2.resolve = resolve2;
      ti2.reject = reject;
    });
    ti2.done = done;
    if (ti2.opts && ti2.opts.updateURL !== false && this.useRouter) {
      const router = document.querySelector("ion-router");
      if (router) {
        const canTransition = await router.canTransition();
        if (canTransition === false) {
          return false;
        }
        if (typeof canTransition === "string") {
          router.push(canTransition, ti2.opts.direction || "back");
          return false;
        }
      }
    }
    if (((_b = ti2.insertViews) === null || _b === void 0 ? void 0 : _b.length) === 0) {
      ti2.insertViews = void 0;
    }
    this.transInstr.push(ti2);
    this.nextTrns();
    return promise;
  }
  success(result, ti2) {
    if (this.destroyed) {
      this.fireError("nav controller was destroyed", ti2);
      return;
    }
    if (ti2.done) {
      ti2.done(result.hasCompleted, result.requiresTransition, result.enteringView, result.leavingView, result.direction);
    }
    ti2.resolve(result.hasCompleted);
    if (ti2.opts.updateURL !== false && this.useRouter) {
      const router = document.querySelector("ion-router");
      if (router) {
        const direction = result.direction === "back" ? "back" : "forward";
        router.navChanged(direction);
      }
    }
  }
  failed(rejectReason, ti2) {
    if (this.destroyed) {
      this.fireError("nav controller was destroyed", ti2);
      return;
    }
    this.transInstr.length = 0;
    this.fireError(rejectReason, ti2);
  }
  fireError(rejectReason, ti2) {
    if (ti2.done) {
      ti2.done(false, false, rejectReason);
    }
    if (ti2.reject && !this.destroyed) {
      ti2.reject(rejectReason);
    } else {
      ti2.resolve(false);
    }
  }
  /**
   * Consumes the next transition in the queue.
   *
   * @returns whether the transition is executed.
   */
  nextTrns() {
    if (this.isTransitioning) {
      return false;
    }
    const ti2 = this.transInstr.shift();
    if (!ti2) {
      return false;
    }
    this.runTransition(ti2);
    return true;
  }
  /** Executes all the transition instruction from the queue. */
  async runTransition(ti2) {
    try {
      this.ionNavWillChange.emit();
      this.isTransitioning = true;
      this.prepareTI(ti2);
      const leavingView = this.getActiveSync();
      const enteringView = this.getEnteringView(ti2, leavingView);
      if (!leavingView && !enteringView) {
        throw new Error("no views in the stack to be removed");
      }
      if (enteringView && enteringView.state === VIEW_STATE_NEW) {
        await enteringView.init(this.el);
      }
      this.postViewInit(enteringView, leavingView, ti2);
      const requiresTransition = (ti2.enteringRequiresTransition || ti2.leavingRequiresTransition) && enteringView !== leavingView;
      if (requiresTransition && ti2.opts && leavingView) {
        const isBackDirection = ti2.opts.direction === "back";
        if (isBackDirection) {
          ti2.opts.animationBuilder = ti2.opts.animationBuilder || (enteringView === null || enteringView === void 0 ? void 0 : enteringView.animationBuilder);
        }
        leavingView.animationBuilder = ti2.opts.animationBuilder;
      }
      let result;
      if (requiresTransition) {
        result = await this.transition(enteringView, leavingView, ti2);
      } else {
        result = {
          hasCompleted: true,
          requiresTransition: false
        };
      }
      this.success(result, ti2);
      this.ionNavDidChange.emit();
    } catch (rejectReason) {
      this.failed(rejectReason, ti2);
    }
    this.isTransitioning = false;
    this.nextTrns();
  }
  prepareTI(ti2) {
    var _a, _b;
    var _c;
    const viewsLength = this.views.length;
    (_a = ti2.opts) !== null && _a !== void 0 ? _a : ti2.opts = {};
    (_b = (_c = ti2.opts).delegate) !== null && _b !== void 0 ? _b : _c.delegate = this.delegate;
    if (ti2.removeView !== void 0) {
      assert(ti2.removeStart !== void 0, "removeView needs removeStart");
      assert(ti2.removeCount !== void 0, "removeView needs removeCount");
      const index = this.views.indexOf(ti2.removeView);
      if (index < 0) {
        throw new Error("removeView was not found");
      }
      ti2.removeStart += index;
    }
    if (ti2.removeStart !== void 0) {
      if (ti2.removeStart < 0) {
        ti2.removeStart = viewsLength - 1;
      }
      if (ti2.removeCount < 0) {
        ti2.removeCount = viewsLength - ti2.removeStart;
      }
      ti2.leavingRequiresTransition = ti2.removeCount > 0 && ti2.removeStart + ti2.removeCount === viewsLength;
    }
    if (ti2.insertViews) {
      if (ti2.insertStart < 0 || ti2.insertStart > viewsLength) {
        ti2.insertStart = viewsLength;
      }
      ti2.enteringRequiresTransition = ti2.insertStart === viewsLength;
    }
    const insertViews = ti2.insertViews;
    if (!insertViews) {
      return;
    }
    assert(insertViews.length > 0, "length can not be zero");
    const viewControllers = convertToViews(insertViews);
    if (viewControllers.length === 0) {
      throw new Error("invalid views to insert");
    }
    for (const view of viewControllers) {
      view.delegate = ti2.opts.delegate;
      const nav = view.nav;
      if (nav && nav !== this) {
        throw new Error("inserted view was already inserted");
      }
      if (view.state === VIEW_STATE_DESTROYED) {
        throw new Error("inserted view was already destroyed");
      }
    }
    ti2.insertViews = viewControllers;
  }
  /**
   * Returns the view that will be entered considering the transition instructions.
   *
   * @param ti The instructions.
   * @param leavingView The view being left or undefined if none.
   *
   * @returns The view that will be entered, undefined if none.
   */
  getEnteringView(ti2, leavingView) {
    const insertViews = ti2.insertViews;
    if (insertViews !== void 0) {
      return insertViews[insertViews.length - 1];
    }
    const removeStart = ti2.removeStart;
    if (removeStart !== void 0) {
      const views = this.views;
      const removeEnd = removeStart + ti2.removeCount;
      for (let i = views.length - 1; i >= 0; i--) {
        const view = views[i];
        if ((i < removeStart || i >= removeEnd) && view !== leavingView) {
          return view;
        }
      }
    }
    return void 0;
  }
  /**
   * Adds and Removes the views from the navigation stack.
   *
   * @param enteringView The view being entered.
   * @param leavingView The view being left.
   * @param ti The instructions.
   */
  postViewInit(enteringView, leavingView, ti2) {
    var _a, _b, _c;
    assert(leavingView || enteringView, "Both leavingView and enteringView are null");
    assert(ti2.resolve, "resolve must be valid");
    assert(ti2.reject, "reject must be valid");
    const opts = ti2.opts;
    const { insertViews, removeStart, removeCount } = ti2;
    let destroyQueue;
    if (removeStart !== void 0 && removeCount !== void 0) {
      assert(removeStart >= 0, "removeStart can not be negative");
      assert(removeCount >= 0, "removeCount can not be negative");
      destroyQueue = [];
      for (let i = removeStart; i < removeStart + removeCount; i++) {
        const view = this.views[i];
        if (view !== void 0 && view !== enteringView && view !== leavingView) {
          destroyQueue.push(view);
        }
      }
      (_a = opts.direction) !== null && _a !== void 0 ? _a : opts.direction = "back";
    }
    const finalNumViews = this.views.length + ((_b = insertViews === null || insertViews === void 0 ? void 0 : insertViews.length) !== null && _b !== void 0 ? _b : 0) - (removeCount !== null && removeCount !== void 0 ? removeCount : 0);
    assert(finalNumViews >= 0, "final balance can not be negative");
    if (finalNumViews === 0) {
      console.warn(`You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.`, this, this.el);
      throw new Error("navigation stack needs at least one root page");
    }
    if (insertViews) {
      let insertIndex = ti2.insertStart;
      for (const view of insertViews) {
        this.insertViewAt(view, insertIndex);
        insertIndex++;
      }
      if (ti2.enteringRequiresTransition) {
        (_c = opts.direction) !== null && _c !== void 0 ? _c : opts.direction = "forward";
      }
    }
    if (destroyQueue && destroyQueue.length > 0) {
      for (const view of destroyQueue) {
        lifecycle(view.element, LIFECYCLE_WILL_LEAVE);
        lifecycle(view.element, LIFECYCLE_DID_LEAVE);
        lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);
      }
      for (const view of destroyQueue) {
        this.destroyView(view);
      }
    }
  }
  async transition(enteringView, leavingView, ti2) {
    const opts = ti2.opts;
    const progressCallback = opts.progressAnimation ? (ani) => {
      if (ani !== void 0 && !this.gestureOrAnimationInProgress) {
        this.gestureOrAnimationInProgress = true;
        ani.onFinish(() => {
          this.gestureOrAnimationInProgress = false;
        }, { oneTimeCallback: true });
        ani.progressEnd(0, 0, 0);
      } else {
        this.sbAni = ani;
      }
    } : void 0;
    const mode = getIonMode$2(this);
    const enteringEl = enteringView.element;
    const leavingEl = leavingView && leavingView.element;
    const animationOpts = Object.assign(Object.assign({
      mode,
      showGoBack: this.canGoBackSync(enteringView),
      baseEl: this.el,
      progressCallback,
      animated: this.animated && config$1.getBoolean("animated", true),
      enteringEl,
      leavingEl
    }, opts), { animationBuilder: opts.animationBuilder || this.animation || config$1.get("navAnimation") });
    const { hasCompleted } = await transition(animationOpts);
    return this.transitionFinish(hasCompleted, enteringView, leavingView, opts);
  }
  transitionFinish(hasCompleted, enteringView, leavingView, opts) {
    const activeView = hasCompleted ? enteringView : leavingView;
    if (activeView) {
      this.unmountInactiveViews(activeView);
    }
    return {
      hasCompleted,
      requiresTransition: true,
      enteringView,
      leavingView,
      direction: opts.direction
    };
  }
  /**
   * Inserts a view at the specified index.
   *
   * When the view already is in the stack it will be moved to the new position.
   *
   * @param view The view to insert.
   * @param index The index where to insert the view.
   */
  insertViewAt(view, index) {
    const views = this.views;
    const existingIndex = views.indexOf(view);
    if (existingIndex > -1) {
      assert(view.nav === this, "view is not part of the nav");
      views.splice(existingIndex, 1);
      views.splice(index, 0, view);
    } else {
      assert(!view.nav, "nav is used");
      view.nav = this;
      views.splice(index, 0, view);
    }
  }
  /**
   * Removes a view from the stack.
   *
   * @param view The view to remove.
   */
  removeView(view) {
    assert(view.state === VIEW_STATE_ATTACHED || view.state === VIEW_STATE_DESTROYED, "view state should be loaded or destroyed");
    const views = this.views;
    const index = views.indexOf(view);
    assert(index > -1, "view must be part of the stack");
    if (index >= 0) {
      views.splice(index, 1);
    }
  }
  destroyView(view) {
    view._destroy();
    this.removeView(view);
  }
  /**
   * Unmounts all inactive views after the specified active view.
   *
   * DOM WRITE
   *
   * @param activeView The view that is actively visible in the stack. Used to calculate which views to unmount.
   */
  unmountInactiveViews(activeView) {
    if (this.destroyed) {
      return;
    }
    const views = this.views;
    const activeViewIndex = views.indexOf(activeView);
    for (let i = views.length - 1; i >= 0; i--) {
      const view = views[i];
      const element = view.element;
      if (element) {
        if (i > activeViewIndex) {
          lifecycle(element, LIFECYCLE_WILL_UNLOAD);
          this.destroyView(view);
        } else if (i < activeViewIndex) {
          setPageHidden(element, true);
        }
      }
    }
  }
  canStart() {
    return !this.gestureOrAnimationInProgress && !!this.swipeGesture && !this.isTransitioning && this.transInstr.length === 0 && this.canGoBackSync();
  }
  onStart() {
    this.gestureOrAnimationInProgress = true;
    this.pop({ direction: "back", progressAnimation: true });
  }
  onMove(stepValue) {
    if (this.sbAni) {
      this.sbAni.progressStep(stepValue);
    }
  }
  onEnd(shouldComplete, stepValue, dur) {
    if (this.sbAni) {
      this.sbAni.onFinish(() => {
        this.gestureOrAnimationInProgress = false;
      }, { oneTimeCallback: true });
      let newStepValue = shouldComplete ? -1e-3 : 1e-3;
      if (!shouldComplete) {
        this.sbAni.easing("cubic-bezier(1, 0, 0.68, 0.28)");
        newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], stepValue)[0];
      } else {
        newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], stepValue)[0];
      }
      this.sbAni.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
    } else {
      this.gestureOrAnimationInProgress = false;
    }
  }
  render() {
    return h$1("slot", { key: "654286a8a7ef03d4a22497eb51e781a9a8979774" });
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "swipeGesture": ["swipeGestureChanged"],
      "root": ["rootChanged"]
    };
  }
  static get style() {
    return IonNavStyle0;
  }
}, [1, "ion-nav", {
  "delegate": [16],
  "swipeGesture": [1028, "swipe-gesture"],
  "animated": [4],
  "animation": [16],
  "rootParams": [16],
  "root": [1],
  "push": [64],
  "insert": [64],
  "insertPages": [64],
  "pop": [64],
  "popTo": [64],
  "popToRoot": [64],
  "removeIndex": [64],
  "setRoot": [64],
  "setPages": [64],
  "setRouteId": [64],
  "getRouteId": [64],
  "getActive": [64],
  "getByIndex": [64],
  "canGoBack": [64],
  "getPrevious": [64]
}, void 0, {
  "swipeGesture": ["swipeGestureChanged"],
  "root": ["rootChanged"]
}]);
function defineCustomElement$1$e() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-nav"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-nav":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Nav);
        }
        break;
    }
  });
}
const defineCustomElement$k = defineCustomElement$1$e;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$j = defineCustomElement$t;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const progressBarIosCss = ":host{--background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.3);--progress-background:var(--ion-color-primary, #3880ff);--buffer-background:var(--background);display:block;position:relative;width:100%;contain:strict;direction:ltr;overflow:hidden}.progress,.progress-indeterminate,.indeterminate-bar-primary,.indeterminate-bar-secondary,.progress-buffer-bar{left:0;right:0;top:0;bottom:0;position:absolute;width:100%;height:100%}.buffer-circles-container,.buffer-circles{left:0;right:0;top:0;bottom:0;position:absolute}.buffer-circles{right:-10px;left:-10px;}.progress,.progress-buffer-bar,.buffer-circles-container{-webkit-transform-origin:left top;transform-origin:left top;-webkit-transition:-webkit-transform 150ms linear;transition:-webkit-transform 150ms linear;transition:transform 150ms linear;transition:transform 150ms linear, -webkit-transform 150ms linear}.progress,.progress-indeterminate{background:var(--progress-background);z-index:2}.progress-buffer-bar{background:var(--buffer-background);z-index:1}.buffer-circles-container{overflow:hidden}.indeterminate-bar-primary{top:0;right:0;bottom:0;left:-145.166611%;-webkit-animation:primary-indeterminate-translate 2s infinite linear;animation:primary-indeterminate-translate 2s infinite linear}.indeterminate-bar-primary .progress-indeterminate{-webkit-animation:primary-indeterminate-scale 2s infinite linear;animation:primary-indeterminate-scale 2s infinite linear;-webkit-animation-play-state:inherit;animation-play-state:inherit}.indeterminate-bar-secondary{top:0;right:0;bottom:0;left:-54.888891%;-webkit-animation:secondary-indeterminate-translate 2s infinite linear;animation:secondary-indeterminate-translate 2s infinite linear}.indeterminate-bar-secondary .progress-indeterminate{-webkit-animation:secondary-indeterminate-scale 2s infinite linear;animation:secondary-indeterminate-scale 2s infinite linear;-webkit-animation-play-state:inherit;animation-play-state:inherit}.buffer-circles{background-image:radial-gradient(ellipse at center, var(--buffer-background) 0%, var(--buffer-background) 30%, transparent 30%);background-repeat:repeat-x;background-position:5px center;background-size:10px 10px;z-index:0;-webkit-animation:buffering 450ms infinite linear;animation:buffering 450ms infinite linear}:host(.progress-bar-reversed){-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.progress-paused) .indeterminate-bar-secondary,:host(.progress-paused) .indeterminate-bar-primary,:host(.progress-paused) .buffer-circles{-webkit-animation-play-state:paused;animation-play-state:paused}:host(.ion-color) .progress-buffer-bar{background:rgba(var(--ion-color-base-rgb), 0.3)}:host(.ion-color) .buffer-circles{background-image:radial-gradient(ellipse at center, rgba(var(--ion-color-base-rgb), 0.3) 0%, rgba(var(--ion-color-base-rgb), 0.3) 30%, transparent 30%)}:host(.ion-color) .progress,:host(.ion-color) .progress-indeterminate{background:var(--ion-color-base)}@-webkit-keyframes primary-indeterminate-translate{0%{-webkit-transform:translateX(0);transform:translateX(0)}20%{-webkit-animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);-webkit-transform:translateX(0);transform:translateX(0)}59.15%{-webkit-animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);-webkit-transform:translateX(83.67142%);transform:translateX(83.67142%)}100%{-webkit-transform:translateX(200.611057%);transform:translateX(200.611057%)}}@keyframes primary-indeterminate-translate{0%{-webkit-transform:translateX(0);transform:translateX(0)}20%{-webkit-animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);-webkit-transform:translateX(0);transform:translateX(0)}59.15%{-webkit-animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);-webkit-transform:translateX(83.67142%);transform:translateX(83.67142%)}100%{-webkit-transform:translateX(200.611057%);transform:translateX(200.611057%)}}@-webkit-keyframes primary-indeterminate-scale{0%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}36.65%{-webkit-animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}69.15%{-webkit-animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);-webkit-transform:scaleX(0.661479);transform:scaleX(0.661479)}100%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}}@keyframes primary-indeterminate-scale{0%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}36.65%{-webkit-animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}69.15%{-webkit-animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);-webkit-transform:scaleX(0.661479);transform:scaleX(0.661479)}100%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}}@-webkit-keyframes secondary-indeterminate-translate{0%{-webkit-animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);-webkit-transform:translateX(0);transform:translateX(0)}25%{-webkit-animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);-webkit-transform:translateX(37.651913%);transform:translateX(37.651913%)}48.35%{-webkit-animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);-webkit-transform:translateX(84.386165%);transform:translateX(84.386165%)}100%{-webkit-transform:translateX(160.277782%);transform:translateX(160.277782%)}}@keyframes secondary-indeterminate-translate{0%{-webkit-animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);-webkit-transform:translateX(0);transform:translateX(0)}25%{-webkit-animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);-webkit-transform:translateX(37.651913%);transform:translateX(37.651913%)}48.35%{-webkit-animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);-webkit-transform:translateX(84.386165%);transform:translateX(84.386165%)}100%{-webkit-transform:translateX(160.277782%);transform:translateX(160.277782%)}}@-webkit-keyframes secondary-indeterminate-scale{0%{-webkit-animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}19.15%{-webkit-animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);-webkit-transform:scaleX(0.457104);transform:scaleX(0.457104)}44.15%{-webkit-animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);-webkit-transform:scaleX(0.72796);transform:scaleX(0.72796)}100%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}}@keyframes secondary-indeterminate-scale{0%{-webkit-animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}19.15%{-webkit-animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);-webkit-transform:scaleX(0.457104);transform:scaleX(0.457104)}44.15%{-webkit-animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);-webkit-transform:scaleX(0.72796);transform:scaleX(0.72796)}100%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}}@-webkit-keyframes buffering{to{-webkit-transform:translateX(-10px);transform:translateX(-10px)}}@keyframes buffering{to{-webkit-transform:translateX(-10px);transform:translateX(-10px)}}:host{height:3px}";
const IonProgressBarIosStyle0 = progressBarIosCss;
const progressBarMdCss = ":host{--background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.3);--progress-background:var(--ion-color-primary, #3880ff);--buffer-background:var(--background);display:block;position:relative;width:100%;contain:strict;direction:ltr;overflow:hidden}.progress,.progress-indeterminate,.indeterminate-bar-primary,.indeterminate-bar-secondary,.progress-buffer-bar{left:0;right:0;top:0;bottom:0;position:absolute;width:100%;height:100%}.buffer-circles-container,.buffer-circles{left:0;right:0;top:0;bottom:0;position:absolute}.buffer-circles{right:-10px;left:-10px;}.progress,.progress-buffer-bar,.buffer-circles-container{-webkit-transform-origin:left top;transform-origin:left top;-webkit-transition:-webkit-transform 150ms linear;transition:-webkit-transform 150ms linear;transition:transform 150ms linear;transition:transform 150ms linear, -webkit-transform 150ms linear}.progress,.progress-indeterminate{background:var(--progress-background);z-index:2}.progress-buffer-bar{background:var(--buffer-background);z-index:1}.buffer-circles-container{overflow:hidden}.indeterminate-bar-primary{top:0;right:0;bottom:0;left:-145.166611%;-webkit-animation:primary-indeterminate-translate 2s infinite linear;animation:primary-indeterminate-translate 2s infinite linear}.indeterminate-bar-primary .progress-indeterminate{-webkit-animation:primary-indeterminate-scale 2s infinite linear;animation:primary-indeterminate-scale 2s infinite linear;-webkit-animation-play-state:inherit;animation-play-state:inherit}.indeterminate-bar-secondary{top:0;right:0;bottom:0;left:-54.888891%;-webkit-animation:secondary-indeterminate-translate 2s infinite linear;animation:secondary-indeterminate-translate 2s infinite linear}.indeterminate-bar-secondary .progress-indeterminate{-webkit-animation:secondary-indeterminate-scale 2s infinite linear;animation:secondary-indeterminate-scale 2s infinite linear;-webkit-animation-play-state:inherit;animation-play-state:inherit}.buffer-circles{background-image:radial-gradient(ellipse at center, var(--buffer-background) 0%, var(--buffer-background) 30%, transparent 30%);background-repeat:repeat-x;background-position:5px center;background-size:10px 10px;z-index:0;-webkit-animation:buffering 450ms infinite linear;animation:buffering 450ms infinite linear}:host(.progress-bar-reversed){-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.progress-paused) .indeterminate-bar-secondary,:host(.progress-paused) .indeterminate-bar-primary,:host(.progress-paused) .buffer-circles{-webkit-animation-play-state:paused;animation-play-state:paused}:host(.ion-color) .progress-buffer-bar{background:rgba(var(--ion-color-base-rgb), 0.3)}:host(.ion-color) .buffer-circles{background-image:radial-gradient(ellipse at center, rgba(var(--ion-color-base-rgb), 0.3) 0%, rgba(var(--ion-color-base-rgb), 0.3) 30%, transparent 30%)}:host(.ion-color) .progress,:host(.ion-color) .progress-indeterminate{background:var(--ion-color-base)}@-webkit-keyframes primary-indeterminate-translate{0%{-webkit-transform:translateX(0);transform:translateX(0)}20%{-webkit-animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);-webkit-transform:translateX(0);transform:translateX(0)}59.15%{-webkit-animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);-webkit-transform:translateX(83.67142%);transform:translateX(83.67142%)}100%{-webkit-transform:translateX(200.611057%);transform:translateX(200.611057%)}}@keyframes primary-indeterminate-translate{0%{-webkit-transform:translateX(0);transform:translateX(0)}20%{-webkit-animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);-webkit-transform:translateX(0);transform:translateX(0)}59.15%{-webkit-animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);-webkit-transform:translateX(83.67142%);transform:translateX(83.67142%)}100%{-webkit-transform:translateX(200.611057%);transform:translateX(200.611057%)}}@-webkit-keyframes primary-indeterminate-scale{0%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}36.65%{-webkit-animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}69.15%{-webkit-animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);-webkit-transform:scaleX(0.661479);transform:scaleX(0.661479)}100%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}}@keyframes primary-indeterminate-scale{0%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}36.65%{-webkit-animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}69.15%{-webkit-animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);-webkit-transform:scaleX(0.661479);transform:scaleX(0.661479)}100%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}}@-webkit-keyframes secondary-indeterminate-translate{0%{-webkit-animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);-webkit-transform:translateX(0);transform:translateX(0)}25%{-webkit-animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);-webkit-transform:translateX(37.651913%);transform:translateX(37.651913%)}48.35%{-webkit-animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);-webkit-transform:translateX(84.386165%);transform:translateX(84.386165%)}100%{-webkit-transform:translateX(160.277782%);transform:translateX(160.277782%)}}@keyframes secondary-indeterminate-translate{0%{-webkit-animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);-webkit-transform:translateX(0);transform:translateX(0)}25%{-webkit-animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);-webkit-transform:translateX(37.651913%);transform:translateX(37.651913%)}48.35%{-webkit-animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);-webkit-transform:translateX(84.386165%);transform:translateX(84.386165%)}100%{-webkit-transform:translateX(160.277782%);transform:translateX(160.277782%)}}@-webkit-keyframes secondary-indeterminate-scale{0%{-webkit-animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}19.15%{-webkit-animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);-webkit-transform:scaleX(0.457104);transform:scaleX(0.457104)}44.15%{-webkit-animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);-webkit-transform:scaleX(0.72796);transform:scaleX(0.72796)}100%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}}@keyframes secondary-indeterminate-scale{0%{-webkit-animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}19.15%{-webkit-animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);-webkit-transform:scaleX(0.457104);transform:scaleX(0.457104)}44.15%{-webkit-animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);-webkit-transform:scaleX(0.72796);transform:scaleX(0.72796)}100%{-webkit-transform:scaleX(0.08);transform:scaleX(0.08)}}@-webkit-keyframes buffering{to{-webkit-transform:translateX(-10px);transform:translateX(-10px)}}@keyframes buffering{to{-webkit-transform:translateX(-10px);transform:translateX(-10px)}}:host{height:4px}";
const IonProgressBarMdStyle0 = progressBarMdCss;
const ProgressBar = /* @__PURE__ */ proxyCustomElement(class ProgressBar2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.type = "determinate";
    this.reversed = false;
    this.value = 0;
    this.buffer = 1;
    this.color = void 0;
  }
  render() {
    const { color, type, reversed, value, buffer } = this;
    const paused = config$1.getBoolean("_testing");
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "384d09558f91dc8119e689c3a8923e67c54c7eb2", role: "progressbar", "aria-valuenow": type === "determinate" ? value : null, "aria-valuemin": "0", "aria-valuemax": "1", class: createColorClasses$2(color, {
      [mode]: true,
      [`progress-bar-${type}`]: true,
      "progress-paused": paused,
      "progress-bar-reversed": document.dir === "rtl" ? !reversed : reversed
    }) }, type === "indeterminate" ? renderIndeterminate() : renderProgress(value, buffer));
  }
  static get style() {
    return {
      ios: IonProgressBarIosStyle0,
      md: IonProgressBarMdStyle0
    };
  }
}, [33, "ion-progress-bar", {
  "type": [1],
  "reversed": [4],
  "value": [2],
  "buffer": [2],
  "color": [513]
}]);
const renderIndeterminate = () => {
  return h$1("div", { part: "track", class: "progress-buffer-bar" }, h$1("div", { class: "indeterminate-bar-primary" }, h$1("span", { part: "progress", class: "progress-indeterminate" })), h$1("div", { class: "indeterminate-bar-secondary" }, h$1("span", { part: "progress", class: "progress-indeterminate" })));
};
const renderProgress = (value, buffer) => {
  const finalValue = clamp(0, value, 1);
  const finalBuffer = clamp(0, buffer, 1);
  return [
    h$1("div", { part: "progress", class: "progress", style: { transform: `scaleX(${finalValue})` } }),
    /**
     * Buffer circles with two container to move
     * the circles behind the buffer progress
     * with respecting the animation.
     * When finalBuffer === 1, we use display: none
     * instead of removing the element to avoid flickering.
     */
    h$1("div", { class: { "buffer-circles-container": true, "ion-hide": finalBuffer === 1 }, style: { transform: `translateX(${finalBuffer * 100}%)` } }, h$1("div", { class: "buffer-circles-container", style: { transform: `translateX(-${finalBuffer * 100}%)` } }, h$1("div", { part: "stream", class: "buffer-circles" }))),
    h$1("div", { part: "track", class: "progress-buffer-bar", style: { transform: `scaleX(${finalBuffer})` } })
  ];
};
function defineCustomElement$1$d() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-progress-bar"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-progress-bar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ProgressBar);
        }
        break;
    }
  });
}
const defineCustomElement$i = defineCustomElement$1$d;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const rowCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}";
const IonRowStyle0 = rowCss;
const Row = /* @__PURE__ */ proxyCustomElement(class Row2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return h$1(Host, { key: "de94b93c001a93b2a88bcb8e959f421fd5ad4a65", class: getIonMode$2(this) }, h$1("slot", { key: "41fa951758d3644bb77d80002caf6e25a79393ce" }));
  }
  static get style() {
    return IonRowStyle0;
  }
}, [1, "ion-row"]);
function defineCustomElement$1$c() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-row"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-row":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Row);
        }
        break;
    }
  });
}
const defineCustomElement$h = defineCustomElement$1$c;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const searchbarIosCss = ".sc-ion-searchbar-ios-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:0.6;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-searchbar-ios-h{color:var(--ion-color-contrast)}.ion-color.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{background:var(--ion-color-base)}.ion-color.sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios,.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.ion-color.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{color:inherit}.searchbar-search-icon.sc-ion-searchbar-ios{color:var(--icon-color);pointer-events:none}.searchbar-input-container.sc-ion-searchbar-ios{display:block;position:relative;-ms-flex-negative:1;flex-shrink:1;width:100%}.searchbar-input.sc-ion-searchbar-ios{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);display:block;width:100%;min-height:inherit;border:0;outline:none;background:var(--background);font-family:inherit;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-input.sc-ion-searchbar-ios::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-webkit-search-cancel-button,.searchbar-input.sc-ion-searchbar-ios::-ms-clear{display:none}.searchbar-cancel-button.sc-ion-searchbar-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:none;height:100%;border:0;outline:none;color:var(--cancel-button-color);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-cancel-button.sc-ion-searchbar-ios>div.sc-ion-searchbar-ios{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.searchbar-clear-button.sc-ion-searchbar-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:none;min-height:0;outline:none;color:var(--clear-button-color);-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-clear-button.sc-ion-searchbar-ios:focus{opacity:0.5}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios{display:block}.searchbar-disabled.sc-ion-searchbar-ios-h{cursor:default;opacity:0.4;pointer-events:none}.sc-ion-searchbar-ios-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.07);--border-radius:10px;--box-shadow:none;--cancel-button-color:var(--ion-color-primary, #3880ff);--clear-button-color:var(--ion-color-step-600, #666666);--color:var(--ion-text-color, #000);--icon-color:var(--ion-color-step-600, #666666);-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:12px;padding-bottom:12px;min-height:60px;contain:content}.searchbar-input-container.sc-ion-searchbar-ios{min-height:36px}.searchbar-search-icon.sc-ion-searchbar-ios{-webkit-margin-start:calc(50% - 60px);margin-inline-start:calc(50% - 60px);top:0;position:absolute;width:1.375rem;height:100%;contain:strict}@supports (inset-inline-start: 0){.searchbar-search-icon.sc-ion-searchbar-ios{inset-inline-start:5px}}@supports not (inset-inline-start: 0){.searchbar-search-icon.sc-ion-searchbar-ios{left:5px}[dir=rtl].sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,[dir=rtl] .sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{left:unset;right:unset;right:5px}[dir=rtl].sc-ion-searchbar-ios .searchbar-search-icon.sc-ion-searchbar-ios{left:unset;right:unset;right:5px}@supports selector(:dir(rtl)){.searchbar-search-icon.sc-ion-searchbar-ios:dir(rtl){left:unset;right:unset;right:5px}}}.searchbar-input.sc-ion-searchbar-ios{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:6px;padding-bottom:6px;height:100%;font-size:1.0625rem;font-weight:400;contain:strict}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{-webkit-padding-start:1.75rem;padding-inline-start:1.75rem;-webkit-padding-end:1.75rem;padding-inline-end:1.75rem}.searchbar-clear-button.sc-ion-searchbar-ios{top:0;background-position:center;position:absolute;width:1.875rem;height:100%;border:0;background-color:transparent}@supports (inset-inline-start: 0){.searchbar-clear-button.sc-ion-searchbar-ios{inset-inline-end:0}}@supports not (inset-inline-start: 0){.searchbar-clear-button.sc-ion-searchbar-ios{right:0}[dir=rtl].sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios,[dir=rtl] .sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios{left:unset;right:unset;left:0}[dir=rtl].sc-ion-searchbar-ios .searchbar-clear-button.sc-ion-searchbar-ios{left:unset;right:unset;left:0}@supports selector(:dir(rtl)){.searchbar-clear-button.sc-ion-searchbar-ios:dir(rtl){left:unset;right:unset;left:0}}}.searchbar-clear-icon.sc-ion-searchbar-ios{width:1.125rem;height:100%}.searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:0;padding-inline-end:0;padding-top:0;padding-bottom:0;-ms-flex-negative:0;flex-shrink:0;background-color:transparent;font-size:16px}.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{-webkit-margin-start:0;margin-inline-start:0}.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{-webkit-padding-start:1.875rem;padding-inline-start:1.875rem}.searchbar-has-focus.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-should-show-cancel.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{display:block}.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{-webkit-transition:all 300ms ease;transition:all 300ms ease}.searchbar-animated.searchbar-has-focus.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-animated.searchbar-should-show-cancel.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{opacity:1;pointer-events:auto}.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-margin-end:-100%;margin-inline-end:-100%;-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0);-webkit-transition:all 300ms ease;transition:all 300ms ease;opacity:0;pointer-events:none}.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios,.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-transition-duration:0ms;transition-duration:0ms}.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{color:var(--ion-color-base)}@media (any-hover: hover){.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios:hover{color:var(--ion-color-tint)}}ion-toolbar.sc-ion-searchbar-ios-h,ion-toolbar .sc-ion-searchbar-ios-h{padding-top:1px;padding-bottom:15px;min-height:52px}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color),ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color){color:inherit}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-cancel-button.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-cancel-button.sc-ion-searchbar-ios{color:currentColor}ion-toolbar.ion-color.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{color:currentColor;opacity:0.5}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-input.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-input.sc-ion-searchbar-ios{background:rgba(var(--ion-color-contrast-rgb), 0.07);color:currentColor}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-clear-button.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-clear-button.sc-ion-searchbar-ios{color:currentColor;opacity:0.5}";
const IonSearchbarIosStyle0 = searchbarIosCss;
const searchbarMdCss = ".sc-ion-searchbar-md-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:0.6;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-searchbar-md-h{color:var(--ion-color-contrast)}.ion-color.sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md{background:var(--ion-color-base)}.ion-color.sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md,.ion-color.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,.ion-color.sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{color:inherit}.searchbar-search-icon.sc-ion-searchbar-md{color:var(--icon-color);pointer-events:none}.searchbar-input-container.sc-ion-searchbar-md{display:block;position:relative;-ms-flex-negative:1;flex-shrink:1;width:100%}.searchbar-input.sc-ion-searchbar-md{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);display:block;width:100%;min-height:inherit;border:0;outline:none;background:var(--background);font-family:inherit;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-input.sc-ion-searchbar-md::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-webkit-search-cancel-button,.searchbar-input.sc-ion-searchbar-md::-ms-clear{display:none}.searchbar-cancel-button.sc-ion-searchbar-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:none;height:100%;border:0;outline:none;color:var(--cancel-button-color);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-cancel-button.sc-ion-searchbar-md>div.sc-ion-searchbar-md{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.searchbar-clear-button.sc-ion-searchbar-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:none;min-height:0;outline:none;color:var(--clear-button-color);-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-clear-button.sc-ion-searchbar-md:focus{opacity:0.5}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md{display:block}.searchbar-disabled.sc-ion-searchbar-md-h{cursor:default;opacity:0.4;pointer-events:none}.sc-ion-searchbar-md-h{--background:var(--ion-background-color, #fff);--border-radius:2px;--box-shadow:0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);--cancel-button-color:var(--ion-color-step-900, #1a1a1a);--clear-button-color:initial;--color:var(--ion-color-step-850, #262626);--icon-color:var(--ion-color-step-600, #666666);-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;background:inherit}.searchbar-search-icon.sc-ion-searchbar-md{top:11px;width:1.3125rem;height:1.3125rem}@supports (inset-inline-start: 0){.searchbar-search-icon.sc-ion-searchbar-md{inset-inline-start:16px}}@supports not (inset-inline-start: 0){.searchbar-search-icon.sc-ion-searchbar-md{left:16px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{left:unset;right:unset;right:16px}[dir=rtl].sc-ion-searchbar-md .searchbar-search-icon.sc-ion-searchbar-md{left:unset;right:unset;right:16px}@supports selector(:dir(rtl)){.searchbar-search-icon.sc-ion-searchbar-md:dir(rtl){left:unset;right:unset;right:16px}}}.searchbar-cancel-button.sc-ion-searchbar-md{top:0;background-color:transparent;font-size:1.5em}@supports (inset-inline-start: 0){.searchbar-cancel-button.sc-ion-searchbar-md{inset-inline-start:9px}}@supports not (inset-inline-start: 0){.searchbar-cancel-button.sc-ion-searchbar-md{left:9px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md{left:unset;right:unset;right:9px}[dir=rtl].sc-ion-searchbar-md .searchbar-cancel-button.sc-ion-searchbar-md{left:unset;right:unset;right:9px}@supports selector(:dir(rtl)){.searchbar-cancel-button.sc-ion-searchbar-md:dir(rtl){left:unset;right:unset;right:9px}}}.searchbar-search-icon.sc-ion-searchbar-md,.searchbar-cancel-button.sc-ion-searchbar-md{position:absolute}.searchbar-search-icon.ion-activated.sc-ion-searchbar-md,.searchbar-cancel-button.ion-activated.sc-ion-searchbar-md{background-color:transparent}.searchbar-input.sc-ion-searchbar-md{-webkit-padding-start:3.4375rem;padding-inline-start:3.4375rem;-webkit-padding-end:3.4375rem;padding-inline-end:3.4375rem;padding-top:0.375rem;padding-bottom:0.375rem;background-position:left 8px center;height:auto;font-size:1rem;font-weight:400;line-height:30px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md{background-position:right 8px center}[dir=rtl].sc-ion-searchbar-md .searchbar-input.sc-ion-searchbar-md{background-position:right 8px center}@supports selector(:dir(rtl)){.searchbar-input.sc-ion-searchbar-md:dir(rtl){background-position:right 8px center}}.searchbar-clear-button.sc-ion-searchbar-md{top:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;position:absolute;height:100%;border:0;background-color:transparent}@supports (inset-inline-start: 0){.searchbar-clear-button.sc-ion-searchbar-md{inset-inline-end:13px}}@supports not (inset-inline-start: 0){.searchbar-clear-button.sc-ion-searchbar-md{right:13px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md{left:unset;right:unset;left:13px}[dir=rtl].sc-ion-searchbar-md .searchbar-clear-button.sc-ion-searchbar-md{left:unset;right:unset;left:13px}@supports selector(:dir(rtl)){.searchbar-clear-button.sc-ion-searchbar-md:dir(rtl){left:unset;right:unset;left:13px}}}.searchbar-clear-button.ion-activated.sc-ion-searchbar-md{background-color:transparent}.searchbar-clear-icon.sc-ion-searchbar-md{width:1.375rem;height:100%}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{display:block}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,.searchbar-should-show-cancel.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md{display:block}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md+.searchbar-search-icon.sc-ion-searchbar-md,.searchbar-should-show-cancel.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md+.searchbar-search-icon.sc-ion-searchbar-md{display:none}ion-toolbar.sc-ion-searchbar-md-h,ion-toolbar .sc-ion-searchbar-md-h{-webkit-padding-start:7px;padding-inline-start:7px;-webkit-padding-end:7px;padding-inline-end:7px;padding-top:3px;padding-bottom:3px}";
const IonSearchbarMdStyle0 = searchbarMdCss;
const Searchbar = /* @__PURE__ */ proxyCustomElement(class Searchbar2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.ionInput = createEvent(this, "ionInput", 7);
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionCancel = createEvent(this, "ionCancel", 7);
    this.ionClear = createEvent(this, "ionClear", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.isCancelVisible = false;
    this.shouldAlignLeft = true;
    this.inputId = `ion-searchbar-${searchbarIds++}`;
    this.onClearInput = async (shouldFocus) => {
      this.ionClear.emit();
      return new Promise((resolve2) => {
        setTimeout(() => {
          const value = this.getValue();
          if (value !== "") {
            this.value = "";
            this.emitInputChange();
            if (shouldFocus && !this.focused) {
              this.setFocus();
              this.focusedValue = value;
            }
          }
          resolve2();
        }, 16 * 4);
      });
    };
    this.onCancelSearchbar = async (ev) => {
      if (ev) {
        ev.preventDefault();
        ev.stopPropagation();
      }
      this.ionCancel.emit();
      const value = this.getValue();
      const focused = this.focused;
      await this.onClearInput();
      if (value && !focused) {
        this.emitValueChange(ev);
      }
      if (this.nativeInput) {
        this.nativeInput.blur();
      }
    };
    this.onInput = (ev) => {
      const input = ev.target;
      if (input) {
        this.value = input.value;
      }
      this.emitInputChange(ev);
    };
    this.onChange = (ev) => {
      this.emitValueChange(ev);
    };
    this.onBlur = (ev) => {
      this.focused = false;
      this.ionBlur.emit();
      this.positionElements();
      if (this.focusedValue !== this.value) {
        this.emitValueChange(ev);
      }
      this.focusedValue = void 0;
    };
    this.onFocus = () => {
      this.focused = true;
      this.focusedValue = this.value;
      this.ionFocus.emit();
      this.positionElements();
    };
    this.focused = false;
    this.noAnimate = true;
    this.color = void 0;
    this.animated = false;
    this.autocomplete = "off";
    this.autocorrect = "off";
    this.cancelButtonIcon = config$1.get("backButtonIcon", arrowBackSharp);
    this.cancelButtonText = "Cancel";
    this.clearIcon = void 0;
    this.debounce = void 0;
    this.disabled = false;
    this.inputmode = void 0;
    this.enterkeyhint = void 0;
    this.name = this.inputId;
    this.placeholder = "Search";
    this.searchIcon = void 0;
    this.showCancelButton = "never";
    this.showClearButton = "always";
    this.spellcheck = false;
    this.type = "search";
    this.value = "";
  }
  debounceChanged() {
    const { ionInput, debounce: debounce2, originalIonInput } = this;
    this.ionInput = debounce2 === void 0 ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce2);
  }
  valueChanged() {
    const inputEl = this.nativeInput;
    const value = this.getValue();
    if (inputEl && inputEl.value !== value) {
      inputEl.value = value;
    }
  }
  showCancelButtonChanged() {
    requestAnimationFrame(() => {
      this.positionElements();
      forceUpdate(this);
    });
  }
  connectedCallback() {
    this.emitStyle();
  }
  componentDidLoad() {
    this.originalIonInput = this.ionInput;
    this.positionElements();
    this.debounceChanged();
    setTimeout(() => {
      this.noAnimate = false;
    }, 300);
  }
  emitStyle() {
    this.ionStyle.emit({
      searchbar: true
    });
  }
  /**
   * Sets focus on the native `input` in `ion-searchbar`. Use this method instead of the global
   * `input.focus()`.
   *
   * Developers who wish to focus an input when a page enters
   * should call `setFocus()` in the `ionViewDidEnter()` lifecycle method.
   *
   * Developers who wish to focus an input when an overlay is presented
   * should call `setFocus` after `didPresent` has resolved.
   *
   * See [managing focus](/docs/developing/managing-focus) for more information.
   */
  async setFocus() {
    if (this.nativeInput) {
      this.nativeInput.focus();
    }
  }
  /**
   * Returns the native `<input>` element used under the hood.
   */
  async getInputElement() {
    if (!this.nativeInput) {
      await new Promise((resolve2) => componentOnReady(this.el, resolve2));
    }
    return Promise.resolve(this.nativeInput);
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.focusedValue = newValue;
    this.ionChange.emit({ value: newValue, event });
  }
  /**
   * Emits an `ionInput` event.
   */
  emitInputChange(event) {
    const { value } = this;
    this.ionInput.emit({ value, event });
  }
  /**
   * Positions the input search icon, placeholder, and the cancel button
   * based on the input value and if it is focused. (ios only)
   */
  positionElements() {
    const value = this.getValue();
    const prevAlignLeft = this.shouldAlignLeft;
    const mode = getIonMode$2(this);
    const shouldAlignLeft = !this.animated || value.trim() !== "" || !!this.focused;
    this.shouldAlignLeft = shouldAlignLeft;
    if (mode !== "ios") {
      return;
    }
    if (prevAlignLeft !== shouldAlignLeft) {
      this.positionPlaceholder();
    }
    if (this.animated) {
      this.positionCancelButton();
    }
  }
  /**
   * Positions the input placeholder
   */
  positionPlaceholder() {
    const inputEl = this.nativeInput;
    if (!inputEl) {
      return;
    }
    const rtl = isRTL$1(this.el);
    const iconEl = (this.el.shadowRoot || this.el).querySelector(".searchbar-search-icon");
    if (this.shouldAlignLeft) {
      inputEl.removeAttribute("style");
      iconEl.removeAttribute("style");
    } else {
      const doc2 = document;
      const tempSpan = doc2.createElement("span");
      tempSpan.innerText = this.placeholder || "";
      doc2.body.appendChild(tempSpan);
      raf(() => {
        const textWidth = tempSpan.offsetWidth;
        tempSpan.remove();
        const inputLeft = "calc(50% - " + textWidth / 2 + "px)";
        const iconLeft = "calc(50% - " + (textWidth / 2 + iconEl.clientWidth + 8) + "px)";
        if (rtl) {
          inputEl.style.paddingRight = inputLeft;
          iconEl.style.marginRight = iconLeft;
        } else {
          inputEl.style.paddingLeft = inputLeft;
          iconEl.style.marginLeft = iconLeft;
        }
      });
    }
  }
  /**
   * Show the iOS Cancel button on focus, hide it offscreen otherwise
   */
  positionCancelButton() {
    const rtl = isRTL$1(this.el);
    const cancelButton = (this.el.shadowRoot || this.el).querySelector(".searchbar-cancel-button");
    const shouldShowCancel = this.shouldShowCancelButton();
    if (cancelButton !== null && shouldShowCancel !== this.isCancelVisible) {
      const cancelStyle = cancelButton.style;
      this.isCancelVisible = shouldShowCancel;
      if (shouldShowCancel) {
        if (rtl) {
          cancelStyle.marginLeft = "0";
        } else {
          cancelStyle.marginRight = "0";
        }
      } else {
        const offset = cancelButton.offsetWidth;
        if (offset > 0) {
          if (rtl) {
            cancelStyle.marginLeft = -offset + "px";
          } else {
            cancelStyle.marginRight = -offset + "px";
          }
        }
      }
    }
  }
  getValue() {
    return this.value || "";
  }
  hasValue() {
    return this.getValue() !== "";
  }
  /**
   * Determines whether or not the cancel button should be visible onscreen.
   * Cancel button should be shown if one of two conditions applies:
   * 1. `showCancelButton` is set to `always`.
   * 2. `showCancelButton` is set to `focus`, and the searchbar has been focused.
   */
  shouldShowCancelButton() {
    if (this.showCancelButton === "never" || this.showCancelButton === "focus" && !this.focused) {
      return false;
    }
    return true;
  }
  /**
   * Determines whether or not the clear button should be visible onscreen.
   * Clear button should be shown if one of two conditions applies:
   * 1. `showClearButton` is set to `always`.
   * 2. `showClearButton` is set to `focus`, and the searchbar has been focused.
   */
  shouldShowClearButton() {
    if (this.showClearButton === "never" || this.showClearButton === "focus" && !this.focused) {
      return false;
    }
    return true;
  }
  render() {
    const { cancelButtonText } = this;
    const animated = this.animated && config$1.getBoolean("animated", true);
    const mode = getIonMode$2(this);
    const clearIcon = this.clearIcon || (mode === "ios" ? closeCircle : closeSharp);
    const searchIcon = this.searchIcon || (mode === "ios" ? searchOutline : searchSharp);
    const shouldShowCancelButton = this.shouldShowCancelButton();
    const cancelButton = this.showCancelButton !== "never" && h$1("button", { key: "1de9b9bc6bad708bafcf4d31fa82838355120486", "aria-label": cancelButtonText, "aria-hidden": shouldShowCancelButton ? void 0 : "true", type: "button", tabIndex: mode === "ios" && !shouldShowCancelButton ? -1 : void 0, onMouseDown: this.onCancelSearchbar, onTouchStart: this.onCancelSearchbar, class: "searchbar-cancel-button" }, h$1("div", { key: "e5178016e17104a80732edbae73c0dfc264bfe52", "aria-hidden": "true" }, mode === "md" ? h$1("ion-icon", { "aria-hidden": "true", mode, icon: this.cancelButtonIcon, lazy: false }) : cancelButtonText));
    return h$1(Host, { key: "2c88a7b6ec7f33ada7dae560881210d7a8800f76", role: "search", "aria-disabled": this.disabled ? "true" : null, class: createColorClasses$2(this.color, {
      [mode]: true,
      "searchbar-animated": animated,
      "searchbar-disabled": this.disabled,
      "searchbar-no-animate": animated && this.noAnimate,
      "searchbar-has-value": this.hasValue(),
      "searchbar-left-aligned": this.shouldAlignLeft,
      "searchbar-has-focus": this.focused,
      "searchbar-should-show-clear": this.shouldShowClearButton(),
      "searchbar-should-show-cancel": this.shouldShowCancelButton()
    }) }, h$1("div", { key: "8e914264a99453748a2bf370943e4047a0a587fb", class: "searchbar-input-container" }, h$1("input", { key: "d772f3e8d42301e50fbd6c9deb332fbdf3c435ac", "aria-label": "search text", disabled: this.disabled, ref: (el2) => this.nativeInput = el2, class: "searchbar-input", inputMode: this.inputmode, enterKeyHint: this.enterkeyhint, name: this.name, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, placeholder: this.placeholder, type: this.type, value: this.getValue(), autoComplete: this.autocomplete, autoCorrect: this.autocorrect, spellcheck: this.spellcheck }), mode === "md" && cancelButton, h$1("ion-icon", { key: "8d9b461c2c34729b1bb562c227868cf817a353bc", "aria-hidden": "true", mode, icon: searchIcon, lazy: false, class: "searchbar-search-icon" }), h$1("button", { key: "bcc39be721f4b825af31aae4dfb3058722d889a8", "aria-label": "reset", type: "button", "no-blur": true, class: "searchbar-clear-button", onPointerDown: (ev) => {
      ev.preventDefault();
    }, onClick: () => this.onClearInput(true) }, h$1("ion-icon", { key: "9a6478e1f1482aa6e62c88bd96cd19cacbfb8d60", "aria-hidden": "true", mode, icon: clearIcon, lazy: false, class: "searchbar-clear-icon" }))), mode === "ios" && cancelButton);
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "debounce": ["debounceChanged"],
      "value": ["valueChanged"],
      "showCancelButton": ["showCancelButtonChanged"]
    };
  }
  static get style() {
    return {
      ios: IonSearchbarIosStyle0,
      md: IonSearchbarMdStyle0
    };
  }
}, [34, "ion-searchbar", {
  "color": [513],
  "animated": [4],
  "autocomplete": [1],
  "autocorrect": [1],
  "cancelButtonIcon": [1, "cancel-button-icon"],
  "cancelButtonText": [1, "cancel-button-text"],
  "clearIcon": [1, "clear-icon"],
  "debounce": [2],
  "disabled": [4],
  "inputmode": [1],
  "enterkeyhint": [1],
  "name": [1],
  "placeholder": [1],
  "searchIcon": [1, "search-icon"],
  "showCancelButton": [1, "show-cancel-button"],
  "showClearButton": [1, "show-clear-button"],
  "spellcheck": [4],
  "type": [1],
  "value": [1025],
  "focused": [32],
  "noAnimate": [32],
  "setFocus": [64],
  "getInputElement": [64]
}, void 0, {
  "debounce": ["debounceChanged"],
  "value": ["valueChanged"],
  "showCancelButton": ["showCancelButtonChanged"]
}]);
let searchbarIds = 0;
function defineCustomElement$1$b() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-searchbar", "ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-searchbar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Searchbar);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$A();
        }
        break;
    }
  });
}
const defineCustomElement$g = defineCustomElement$1$b;
const segmentIosCss = ":host{--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:grid;grid-auto-columns:1fr;position:relative;-ms-flex-align:stretch;align-items:stretch;-ms-flex-pack:center;justify-content:center;width:100%;background:var(--background);font-family:var(--ion-font-family, inherit);text-align:center;contain:paint;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.segment-scrollable){-ms-flex-pack:start;justify-content:start;width:auto;overflow-x:auto;grid-auto-columns:minmax(-webkit-min-content, 1fr);grid-auto-columns:minmax(min-content, 1fr)}:host(.segment-scrollable::-webkit-scrollbar){display:none}:host{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.065);border-radius:8px;overflow:hidden;z-index:0}:host(.ion-color){background:rgba(var(--ion-color-base-rgb), 0.065)}:host(.in-toolbar){-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;width:auto}:host(.in-toolbar:not(.ion-color)){background:var(--ion-toolbar-segment-background, var(--background))}:host(.in-toolbar-color:not(.ion-color)){background:rgba(var(--ion-color-contrast-rgb), 0.11)}";
const IonSegmentIosStyle0 = segmentIosCss;
const segmentMdCss = ":host{--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:grid;grid-auto-columns:1fr;position:relative;-ms-flex-align:stretch;align-items:stretch;-ms-flex-pack:center;justify-content:center;width:100%;background:var(--background);font-family:var(--ion-font-family, inherit);text-align:center;contain:paint;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.segment-scrollable){-ms-flex-pack:start;justify-content:start;width:auto;overflow-x:auto;grid-auto-columns:minmax(-webkit-min-content, 1fr);grid-auto-columns:minmax(min-content, 1fr)}:host(.segment-scrollable::-webkit-scrollbar){display:none}:host{--background:transparent;grid-auto-columns:minmax(auto, 360px)}:host(.in-toolbar){min-height:var(--min-height)}:host(.segment-scrollable) ::slotted(ion-segment-button){min-width:auto}";
const IonSegmentMdStyle0 = segmentMdCss;
const Segment = /* @__PURE__ */ proxyCustomElement(class Segment2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionSelect = createEvent(this, "ionSelect", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.onClick = (ev) => {
      const current = ev.target;
      const previous = this.checked;
      if (current.tagName === "ION-SEGMENT") {
        return;
      }
      this.value = current.value;
      if (current !== previous) {
        this.emitValueChange();
      }
      if (this.scrollable || !this.swipeGesture) {
        if (previous) {
          this.checkButton(previous, current);
        } else {
          this.setCheckedClasses();
        }
      }
    };
    this.getSegmentButton = (selector) => {
      var _a, _b;
      const buttons = this.getButtons().filter((button) => !button.disabled);
      const currIndex = buttons.findIndex((button) => button === document.activeElement);
      switch (selector) {
        case "first":
          return buttons[0];
        case "last":
          return buttons[buttons.length - 1];
        case "next":
          return (_a = buttons[currIndex + 1]) !== null && _a !== void 0 ? _a : buttons[0];
        case "previous":
          return (_b = buttons[currIndex - 1]) !== null && _b !== void 0 ? _b : buttons[buttons.length - 1];
        default:
          return null;
      }
    };
    this.activated = false;
    this.color = void 0;
    this.disabled = false;
    this.scrollable = false;
    this.swipeGesture = true;
    this.value = void 0;
    this.selectOnFocus = false;
  }
  colorChanged(value, oldValue) {
    if (oldValue === void 0 && value !== void 0 || oldValue !== void 0 && value === void 0) {
      this.emitStyle();
    }
  }
  swipeGestureChanged() {
    this.gestureChanged();
  }
  valueChanged(value) {
    this.ionSelect.emit({ value });
    this.scrollActiveButtonIntoView();
  }
  disabledChanged() {
    this.gestureChanged();
    const buttons = this.getButtons();
    for (const button of buttons) {
      button.disabled = this.disabled;
    }
  }
  gestureChanged() {
    if (this.gesture) {
      this.gesture.enable(!this.scrollable && !this.disabled && this.swipeGesture);
    }
  }
  connectedCallback() {
    this.emitStyle();
  }
  componentWillLoad() {
    this.emitStyle();
  }
  async componentDidLoad() {
    this.setCheckedClasses();
    this.ionSelect.emit({ value: this.value });
    raf(() => {
      this.scrollActiveButtonIntoView(false);
    });
    this.gesture = (await __vitePreload(() => Promise.resolve().then(() => index3), true ? void 0 : void 0, import.meta.url)).createGesture({
      el: this.el,
      gestureName: "segment",
      gesturePriority: 100,
      threshold: 0,
      passive: false,
      onStart: (ev) => this.onStart(ev),
      onMove: (ev) => this.onMove(ev),
      onEnd: (ev) => this.onEnd(ev)
    });
    this.gestureChanged();
    if (this.disabled) {
      this.disabledChanged();
    }
  }
  onStart(detail) {
    this.valueBeforeGesture = this.value;
    this.activate(detail);
  }
  onMove(detail) {
    this.setNextIndex(detail);
  }
  onEnd(detail) {
    this.setActivated(false);
    this.setNextIndex(detail, true);
    detail.event.stopImmediatePropagation();
    const value = this.value;
    if (value !== void 0) {
      if (this.valueBeforeGesture !== value) {
        this.emitValueChange();
      }
    }
    this.valueBeforeGesture = void 0;
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange() {
    const { value } = this;
    this.ionChange.emit({ value });
  }
  getButtons() {
    return Array.from(this.el.querySelectorAll("ion-segment-button"));
  }
  get checked() {
    return this.getButtons().find((button) => button.value === this.value);
  }
  /*
   * Activate both the segment and the buttons
   * due to a bug with ::slotted in Safari
   */
  setActivated(activated) {
    const buttons = this.getButtons();
    buttons.forEach((button) => {
      if (activated) {
        button.classList.add("segment-button-activated");
      } else {
        button.classList.remove("segment-button-activated");
      }
    });
    this.activated = activated;
  }
  activate(detail) {
    const clicked = detail.event.target;
    const buttons = this.getButtons();
    const checked2 = buttons.find((button) => button.value === this.value);
    if (clicked.tagName !== "ION-SEGMENT-BUTTON") {
      return;
    }
    if (!checked2) {
      this.value = clicked.value;
      this.setCheckedClasses();
    }
    if (this.value === clicked.value) {
      this.setActivated(true);
    }
  }
  getIndicator(button) {
    const root = button.shadowRoot || button;
    return root.querySelector(".segment-button-indicator");
  }
  checkButton(previous, current) {
    const previousIndicator = this.getIndicator(previous);
    const currentIndicator = this.getIndicator(current);
    if (previousIndicator === null || currentIndicator === null) {
      return;
    }
    const previousClientRect = previousIndicator.getBoundingClientRect();
    const currentClientRect = currentIndicator.getBoundingClientRect();
    const widthDelta = previousClientRect.width / currentClientRect.width;
    const xPosition = previousClientRect.left - currentClientRect.left;
    const transform = `translate3d(${xPosition}px, 0, 0) scaleX(${widthDelta})`;
    writeTask(() => {
      currentIndicator.classList.remove("segment-button-indicator-animated");
      currentIndicator.style.setProperty("transform", transform);
      currentIndicator.getBoundingClientRect();
      currentIndicator.classList.add("segment-button-indicator-animated");
      currentIndicator.style.setProperty("transform", "");
    });
    this.value = current.value;
    this.setCheckedClasses();
  }
  setCheckedClasses() {
    const buttons = this.getButtons();
    const index = buttons.findIndex((button) => button.value === this.value);
    const next = index + 1;
    for (const button of buttons) {
      button.classList.remove("segment-button-after-checked");
    }
    if (next < buttons.length) {
      buttons[next].classList.add("segment-button-after-checked");
    }
  }
  scrollActiveButtonIntoView(smoothScroll = true) {
    const { scrollable, value, el: el2 } = this;
    if (scrollable) {
      const buttons = this.getButtons();
      const activeButton = buttons.find((button) => button.value === value);
      if (activeButton !== void 0) {
        const scrollContainerBox = el2.getBoundingClientRect();
        const activeButtonBox = activeButton.getBoundingClientRect();
        const activeButtonLeft = activeButtonBox.x - scrollContainerBox.x;
        const centeredX = activeButtonLeft - scrollContainerBox.width / 2 + activeButtonBox.width / 2;
        el2.scrollBy({
          top: 0,
          left: centeredX,
          behavior: smoothScroll ? "smooth" : "instant"
        });
      }
    }
  }
  setNextIndex(detail, isEnd = false) {
    const rtl = isRTL$1(this.el);
    const activated = this.activated;
    const buttons = this.getButtons();
    const index = buttons.findIndex((button) => button.value === this.value);
    const previous = buttons[index];
    let current;
    let nextIndex;
    if (index === -1) {
      return;
    }
    const rect = previous.getBoundingClientRect();
    const left = rect.left;
    const width = rect.width;
    const currentX = detail.currentX;
    const previousY = rect.top + rect.height / 2;
    const root = this.el.getRootNode();
    const nextEl = root.elementFromPoint(currentX, previousY);
    const decreaseIndex = rtl ? currentX > left + width : currentX < left;
    const increaseIndex = rtl ? currentX < left : currentX > left + width;
    if (activated && !isEnd) {
      if (decreaseIndex) {
        const newIndex = index - 1;
        if (newIndex >= 0) {
          nextIndex = newIndex;
        }
      } else if (increaseIndex) {
        if (activated && !isEnd) {
          const newIndex = index + 1;
          if (newIndex < buttons.length) {
            nextIndex = newIndex;
          }
        }
      }
      if (nextIndex !== void 0 && !buttons[nextIndex].disabled) {
        current = buttons[nextIndex];
      }
    }
    if (!activated && isEnd) {
      current = nextEl;
    }
    if (current != null) {
      if (current.tagName === "ION-SEGMENT") {
        return false;
      }
      if (previous !== current) {
        this.checkButton(previous, current);
      }
    }
    return true;
  }
  emitStyle() {
    this.ionStyle.emit({
      segment: true
    });
  }
  onKeyDown(ev) {
    const rtl = isRTL$1(this.el);
    let keyDownSelectsButton = this.selectOnFocus;
    let current;
    switch (ev.key) {
      case "ArrowRight":
        ev.preventDefault();
        current = rtl ? this.getSegmentButton("previous") : this.getSegmentButton("next");
        break;
      case "ArrowLeft":
        ev.preventDefault();
        current = rtl ? this.getSegmentButton("next") : this.getSegmentButton("previous");
        break;
      case "Home":
        ev.preventDefault();
        current = this.getSegmentButton("first");
        break;
      case "End":
        ev.preventDefault();
        current = this.getSegmentButton("last");
        break;
      case " ":
      case "Enter":
        ev.preventDefault();
        current = document.activeElement;
        keyDownSelectsButton = true;
    }
    if (!current) {
      return;
    }
    if (keyDownSelectsButton) {
      const previous = this.checked;
      this.checkButton(previous || current, current);
      if (current !== previous) {
        this.emitValueChange();
      }
    }
    current.setFocus();
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "971e62fdaef3b6380aa1bf214605a5bfde662abf", role: "tablist", onClick: this.onClick, class: createColorClasses$2(this.color, {
      [mode]: true,
      "in-toolbar": hostContext("ion-toolbar", this.el),
      "in-toolbar-color": hostContext("ion-toolbar[color]", this.el),
      "segment-activated": this.activated,
      "segment-disabled": this.disabled,
      "segment-scrollable": this.scrollable
    }) }, h$1("slot", { key: "eaa7a8a3d5237c8bbc03f57690fd0aa7e4c124e3" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "color": ["colorChanged"],
      "swipeGesture": ["swipeGestureChanged"],
      "value": ["valueChanged"],
      "disabled": ["disabledChanged"]
    };
  }
  static get style() {
    return {
      ios: IonSegmentIosStyle0,
      md: IonSegmentMdStyle0
    };
  }
}, [33, "ion-segment", {
  "color": [513],
  "disabled": [4],
  "scrollable": [4],
  "swipeGesture": [4, "swipe-gesture"],
  "value": [1032],
  "selectOnFocus": [4, "select-on-focus"],
  "activated": [32]
}, [[0, "keydown", "onKeyDown"]], {
  "color": ["colorChanged"],
  "swipeGesture": ["swipeGestureChanged"],
  "value": ["valueChanged"],
  "disabled": ["disabledChanged"]
}]);
function defineCustomElement$1$a() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-segment"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-segment":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Segment);
        }
        break;
    }
  });
}
const defineCustomElement$f = defineCustomElement$1$a;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const segmentButtonIosCss = ':host{--color:initial;--color-hover:var(--color);--color-checked:var(--color);--color-disabled:var(--color);--padding-start:0;--padding-end:0;--padding-top:0;--padding-bottom:0;border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:column;flex-direction:column;height:auto;background:var(--background);color:var(--color);text-decoration:none;text-overflow:ellipsis;white-space:nowrap;cursor:pointer;grid-row:1;-webkit-font-kerning:none;font-kerning:none}.button-native{border-radius:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;min-width:inherit;max-width:inherit;height:auto;min-height:inherit;max-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border:none;outline:none;background:transparent;contain:content;pointer-events:none;overflow:hidden;z-index:2}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}:host(.segment-button-checked){background:var(--background-checked);color:var(--color-checked)}:host(.segment-button-disabled){cursor:default;pointer-events:none}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(:focus){outline:none}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.segment-button-checked:hover) .button-native{color:var(--color-checked)}}::slotted(ion-icon){-ms-flex-negative:0;flex-shrink:0;-ms-flex-order:-1;order:-1;pointer-events:none}::slotted(ion-label){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;line-height:22px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.segment-button-layout-icon-top) .button-native{-ms-flex-direction:column;flex-direction:column}:host(.segment-button-layout-icon-start) .button-native{-ms-flex-direction:row;flex-direction:row}:host(.segment-button-layout-icon-end) .button-native{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.segment-button-layout-icon-bottom) .button-native{-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.segment-button-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.segment-button-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color, var(--color-checked))}.segment-button-indicator{-webkit-transform-origin:left;transform-origin:left;position:absolute;opacity:0;-webkit-box-sizing:border-box;box-sizing:border-box;will-change:transform, opacity;pointer-events:none}.segment-button-indicator-background{width:100%;height:var(--indicator-height);-webkit-transform:var(--indicator-transform);transform:var(--indicator-transform);-webkit-box-shadow:var(--indicator-box-shadow);box-shadow:var(--indicator-box-shadow);pointer-events:none}.segment-button-indicator-animated{-webkit-transition:var(--indicator-transition);transition:var(--indicator-transition)}:host(.segment-button-checked) .segment-button-indicator{opacity:1}@media (prefers-reduced-motion: reduce){.segment-button-indicator-background{-webkit-transform:none;transform:none}.segment-button-indicator-animated{-webkit-transition:none;transition:none}}:host{--background:none;--background-checked:none;--background-hover:none;--background-hover-opacity:0;--background-focused:none;--background-focused-opacity:0;--border-radius:7px;--border-width:1px;--border-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.12);--border-style:solid;--indicator-box-shadow:0 0 5px rgba(0, 0, 0, 0.16);--indicator-color:var(--ion-color-step-350, var(--ion-background-color, #fff));--indicator-height:100%;--indicator-transition:transform 260ms cubic-bezier(0.4, 0, 0.2, 1);--indicator-transform:none;--transition:100ms all linear;--padding-top:0;--padding-end:13px;--padding-bottom:0;--padding-start:13px;margin-top:2px;margin-bottom:2px;position:relative;-ms-flex-direction:row;flex-direction:row;min-width:70px;min-height:28px;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);font-size:13px;font-weight:450;line-height:37px}:host::before{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px;-webkit-transition:160ms opacity ease-in-out;transition:160ms opacity ease-in-out;-webkit-transition-delay:100ms;transition-delay:100ms;border-left:var(--border-width) var(--border-style) var(--border-color);content:"";opacity:1;will-change:opacity}:host(:first-of-type)::before{border-left-color:transparent}:host(.segment-button-disabled){opacity:0.3}::slotted(ion-icon){font-size:24px}:host(.segment-button-layout-icon-start) ::slotted(ion-label){-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:0;margin-inline-end:0}:host(.segment-button-layout-icon-end) ::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:2px;margin-inline-end:2px}.segment-button-indicator{-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px;left:0;right:0;top:0;bottom:0}.segment-button-indicator-background{border-radius:var(--border-radius);background:var(--indicator-color)}.segment-button-indicator-background{-webkit-transition:var(--indicator-transition);transition:var(--indicator-transition)}:host(.segment-button-checked)::before,:host(.segment-button-after-checked)::before{opacity:0}:host(.segment-button-checked){z-index:-1}:host(.segment-button-activated){--indicator-transform:scale(0.95)}:host(.ion-focused) .button-native{opacity:0.7}@media (any-hover: hover){:host(:hover) .button-native{opacity:0.5}:host(.segment-button-checked:hover) .button-native{opacity:1}}:host(.in-segment-color){background:none;color:var(--ion-text-color, #000)}:host(.in-segment-color) .segment-button-indicator-background{background:var(--ion-color-step-350, var(--ion-background-color, #fff))}@media (any-hover: hover){:host(.in-segment-color:hover) .button-native,:host(.in-segment-color.segment-button-checked:hover) .button-native{color:var(--ion-text-color, #000)}}:host(.in-toolbar:not(.in-segment-color)){--background-checked:var(--ion-toolbar-segment-background-checked, none);--color:var(--ion-toolbar-segment-color, var(--ion-toolbar-color), initial);--color-checked:var(--ion-toolbar-segment-color-checked, var(--ion-toolbar-color), initial);--indicator-color:var(--ion-toolbar-segment-indicator-color, var(--ion-color-step-350, var(--ion-background-color, #fff)))}:host(.in-toolbar-color) .segment-button-indicator-background{background:var(--ion-color-contrast)}:host(.in-toolbar-color:not(.in-segment-color)) .button-native{color:var(--ion-color-contrast)}:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color)) .button-native{color:var(--ion-color-base)}@media (any-hover: hover){:host(.in-toolbar-color:not(.in-segment-color):hover) .button-native{color:var(--ion-color-contrast)}:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color):hover) .button-native{color:var(--ion-color-base)}}';
const IonSegmentButtonIosStyle0 = segmentButtonIosCss;
const segmentButtonMdCss = ':host{--color:initial;--color-hover:var(--color);--color-checked:var(--color);--color-disabled:var(--color);--padding-start:0;--padding-end:0;--padding-top:0;--padding-bottom:0;border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:column;flex-direction:column;height:auto;background:var(--background);color:var(--color);text-decoration:none;text-overflow:ellipsis;white-space:nowrap;cursor:pointer;grid-row:1;-webkit-font-kerning:none;font-kerning:none}.button-native{border-radius:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;min-width:inherit;max-width:inherit;height:auto;min-height:inherit;max-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border:none;outline:none;background:transparent;contain:content;pointer-events:none;overflow:hidden;z-index:2}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}:host(.segment-button-checked){background:var(--background-checked);color:var(--color-checked)}:host(.segment-button-disabled){cursor:default;pointer-events:none}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(:focus){outline:none}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.segment-button-checked:hover) .button-native{color:var(--color-checked)}}::slotted(ion-icon){-ms-flex-negative:0;flex-shrink:0;-ms-flex-order:-1;order:-1;pointer-events:none}::slotted(ion-label){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;line-height:22px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.segment-button-layout-icon-top) .button-native{-ms-flex-direction:column;flex-direction:column}:host(.segment-button-layout-icon-start) .button-native{-ms-flex-direction:row;flex-direction:row}:host(.segment-button-layout-icon-end) .button-native{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.segment-button-layout-icon-bottom) .button-native{-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.segment-button-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.segment-button-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color, var(--color-checked))}.segment-button-indicator{-webkit-transform-origin:left;transform-origin:left;position:absolute;opacity:0;-webkit-box-sizing:border-box;box-sizing:border-box;will-change:transform, opacity;pointer-events:none}.segment-button-indicator-background{width:100%;height:var(--indicator-height);-webkit-transform:var(--indicator-transform);transform:var(--indicator-transform);-webkit-box-shadow:var(--indicator-box-shadow);box-shadow:var(--indicator-box-shadow);pointer-events:none}.segment-button-indicator-animated{-webkit-transition:var(--indicator-transition);transition:var(--indicator-transition)}:host(.segment-button-checked) .segment-button-indicator{opacity:1}@media (prefers-reduced-motion: reduce){.segment-button-indicator-background{-webkit-transform:none;transform:none}.segment-button-indicator-animated{-webkit-transition:none;transition:none}}:host{--background:none;--background-checked:none;--background-hover:var(--color-checked);--background-focused:var(--color-checked);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04;--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6);--color-checked:var(--ion-color-primary, #3880ff);--indicator-box-shadow:none;--indicator-color:var(--color-checked);--indicator-height:2px;--indicator-transition:transform 250ms cubic-bezier(0.4, 0, 0.2, 1);--indicator-transform:none;--padding-top:0;--padding-end:16px;--padding-bottom:0;--padding-start:16px;--transition:color 0.15s linear 0s, opacity 0.15s linear 0s;min-width:90px;min-height:48px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);font-size:14px;font-weight:500;letter-spacing:0.06em;line-height:40px;text-transform:uppercase}:host(.segment-button-disabled){opacity:0.3}:host(.in-segment-color){background:none;color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6)}:host(.in-segment-color) ion-ripple-effect{color:var(--ion-color-base)}:host(.in-segment-color) .segment-button-indicator-background{background:var(--ion-color-base)}:host(.in-segment-color.segment-button-checked) .button-native{color:var(--ion-color-base)}:host(.in-segment-color.ion-focused) .button-native::after{background:var(--ion-color-base)}@media (any-hover: hover){:host(.in-segment-color:hover) .button-native{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6)}:host(.in-segment-color:hover) .button-native::after{background:var(--ion-color-base)}:host(.in-segment-color.segment-button-checked:hover) .button-native{color:var(--ion-color-base)}}:host(.in-toolbar:not(.in-segment-color)){--background:var(--ion-toolbar-segment-background, none);--background-checked:var(--ion-toolbar-segment-background-checked, none);--color:var(--ion-toolbar-segment-color, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6));--color-checked:var(--ion-toolbar-segment-color-checked, var(--ion-color-primary, #3880ff));--indicator-color:var(--ion-toolbar-segment-color-checked, var(--color-checked))}:host(.in-toolbar-color:not(.in-segment-color)) .button-native{color:rgba(var(--ion-color-contrast-rgb), 0.6)}:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color)) .button-native{color:var(--ion-color-contrast)}@media (any-hover: hover){:host(.in-toolbar-color:not(.in-segment-color)) .button-native::after{background:var(--ion-color-contrast)}}::slotted(ion-icon){margin-top:12px;margin-bottom:12px;font-size:24px}::slotted(ion-label){margin-top:12px;margin-bottom:12px}:host(.segment-button-layout-icon-top) ::slotted(ion-label),:host(.segment-button-layout-icon-bottom) ::slotted(ion-icon){margin-top:0}:host(.segment-button-layout-icon-top) ::slotted(ion-icon),:host(.segment-button-layout-icon-bottom) ::slotted(ion-label){margin-bottom:0}:host(.segment-button-layout-icon-start) ::slotted(ion-label){-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:0;margin-inline-end:0}:host(.segment-button-layout-icon-end) ::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}:host(.segment-button-has-icon-only) ::slotted(ion-icon){margin-top:12px;margin-bottom:12px}:host(.segment-button-has-label-only) ::slotted(ion-label){margin-top:12px;margin-bottom:12px}.segment-button-indicator{left:0;right:0;bottom:0}.segment-button-indicator-background{background:var(--indicator-color)}:host(.in-toolbar:not(.in-segment-color)) .segment-button-indicator-background{background:var(--ion-toolbar-segment-indicator-color, var(--indicator-color))}:host(.in-toolbar-color:not(.in-segment-color)) .segment-button-indicator-background{background:var(--ion-color-contrast)}';
const IonSegmentButtonMdStyle0 = segmentButtonMdCss;
let ids$1 = 0;
const SegmentButton = /* @__PURE__ */ proxyCustomElement(class SegmentButton2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.segmentEl = null;
    this.inheritedAttributes = {};
    this.updateStyle = () => {
      forceUpdate(this);
    };
    this.updateState = () => {
      const { segmentEl } = this;
      if (segmentEl) {
        this.checked = segmentEl.value === this.value;
        if (segmentEl.disabled) {
          this.disabled = true;
        }
      }
    };
    this.checked = false;
    this.disabled = false;
    this.layout = "icon-top";
    this.type = "button";
    this.value = "ion-sb-" + ids$1++;
  }
  valueChanged() {
    this.updateState();
  }
  connectedCallback() {
    const segmentEl = this.segmentEl = this.el.closest("ion-segment");
    if (segmentEl) {
      this.updateState();
      addEventListener$1(segmentEl, "ionSelect", this.updateState);
      addEventListener$1(segmentEl, "ionStyle", this.updateStyle);
    }
  }
  disconnectedCallback() {
    const segmentEl = this.segmentEl;
    if (segmentEl) {
      removeEventListener(segmentEl, "ionSelect", this.updateState);
      removeEventListener(segmentEl, "ionStyle", this.updateStyle);
      this.segmentEl = null;
    }
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign({}, inheritAttributes$2(this.el, ["aria-label"]));
  }
  get hasLabel() {
    return !!this.el.querySelector("ion-label");
  }
  get hasIcon() {
    return !!this.el.querySelector("ion-icon");
  }
  /**
   * @internal
   * Focuses the native <button> element
   * inside of ion-segment-button.
   */
  async setFocus() {
    const { nativeEl } = this;
    if (nativeEl !== void 0) {
      nativeEl.focus();
    }
  }
  render() {
    const { checked: checked2, type, disabled, hasIcon, hasLabel, layout, segmentEl } = this;
    const mode = getIonMode$2(this);
    const hasSegmentColor = () => (segmentEl === null || segmentEl === void 0 ? void 0 : segmentEl.color) !== void 0;
    return h$1(Host, { key: "b50b375ed817b47720b743078202f38c737a4034", class: {
      [mode]: true,
      "in-toolbar": hostContext("ion-toolbar", this.el),
      "in-toolbar-color": hostContext("ion-toolbar[color]", this.el),
      "in-segment": hostContext("ion-segment", this.el),
      "in-segment-color": hasSegmentColor(),
      "segment-button-has-label": hasLabel,
      "segment-button-has-icon": hasIcon,
      "segment-button-has-label-only": hasLabel && !hasIcon,
      "segment-button-has-icon-only": hasIcon && !hasLabel,
      "segment-button-disabled": disabled,
      "segment-button-checked": checked2,
      [`segment-button-layout-${layout}`]: true,
      "ion-activatable": true,
      "ion-activatable-instant": true,
      "ion-focusable": true
    } }, h$1("button", Object.assign({ key: "402f6467ec9ce97aa1df2c72382d07242b51c114", "aria-selected": checked2 ? "true" : "false", role: "tab", ref: (el2) => this.nativeEl = el2, type, class: "button-native", part: "native", disabled }, this.inheritedAttributes), h$1("span", { key: "4f5a1988296c4e59e64255feff264bbbe2ccc312", class: "button-inner" }, h$1("slot", { key: "35b2a26cca8c76a111e447fa8cae464c504fcb97" })), mode === "md" && h$1("ion-ripple-effect", null)), h$1("div", { key: "adca0f1e0efcf18b575013d4fb2f22814c81c147", part: "indicator", class: {
      "segment-button-indicator": true,
      "segment-button-indicator-animated": true
    } }, h$1("div", { key: "8a23ffe49dc115ee0603e298bb6a39834b910b67", part: "indicator-background", class: "segment-button-indicator-background" })));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "value": ["valueChanged"]
    };
  }
  static get style() {
    return {
      ios: IonSegmentButtonIosStyle0,
      md: IonSegmentButtonMdStyle0
    };
  }
}, [33, "ion-segment-button", {
  "disabled": [1028],
  "layout": [1],
  "type": [1],
  "value": [8],
  "checked": [32],
  "setFocus": [64]
}, void 0, {
  "value": ["valueChanged"]
}]);
function defineCustomElement$1$9() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-segment-button", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-segment-button":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, SegmentButton);
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$w();
        }
        break;
    }
  });
}
const defineCustomElement$e = defineCustomElement$1$9;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const createButtonActiveGesture = (el2, isButton) => {
  let currentTouchedButton;
  let initialTouchedButton;
  const activateButtonAtPoint = (x2, y2, hapticFeedbackFn) => {
    if (typeof document === "undefined") {
      return;
    }
    const target = document.elementFromPoint(x2, y2);
    if (!target || !isButton(target)) {
      clearActiveButton();
      return;
    }
    if (target !== currentTouchedButton) {
      clearActiveButton();
      setActiveButton(target, hapticFeedbackFn);
    }
  };
  const setActiveButton = (button, hapticFeedbackFn) => {
    currentTouchedButton = button;
    if (!initialTouchedButton) {
      initialTouchedButton = currentTouchedButton;
    }
    const buttonToModify = currentTouchedButton;
    writeTask(() => buttonToModify.classList.add("ion-activated"));
    hapticFeedbackFn();
  };
  const clearActiveButton = (dispatchClick = false) => {
    if (!currentTouchedButton) {
      return;
    }
    const buttonToModify = currentTouchedButton;
    writeTask(() => buttonToModify.classList.remove("ion-activated"));
    if (dispatchClick && initialTouchedButton !== currentTouchedButton) {
      currentTouchedButton.click();
    }
    currentTouchedButton = void 0;
  };
  return createGesture({
    el: el2,
    gestureName: "buttonActiveDrag",
    threshold: 0,
    onStart: (ev) => activateButtonAtPoint(ev.currentX, ev.currentY, hapticSelectionStart),
    onMove: (ev) => activateButtonAtPoint(ev.currentX, ev.currentY, hapticSelectionChanged),
    onEnd: () => {
      clearActiveButton(true);
      hapticSelectionEnd();
      initialTouchedButton = void 0;
    }
  });
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const iosEnterAnimation$1 = (baseEl) => {
  const baseAnimation = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(baseEl.querySelector(".alert-wrapper")).keyframes([
    { offset: 0, opacity: "0.01", transform: "scale(1.1)" },
    { offset: 1, opacity: "1", transform: "scale(1)" }
  ]);
  return baseAnimation.addElement(baseEl).easing("ease-in-out").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const iosLeaveAnimation$1 = (baseEl) => {
  const baseAnimation = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(baseEl.querySelector(".alert-wrapper")).keyframes([
    { offset: 0, opacity: 0.99, transform: "scale(1)" },
    { offset: 1, opacity: 0, transform: "scale(0.9)" }
  ]);
  return baseAnimation.addElement(baseEl).easing("ease-in-out").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const mdEnterAnimation$1 = (baseEl) => {
  const baseAnimation = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(baseEl.querySelector(".alert-wrapper")).keyframes([
    { offset: 0, opacity: "0.01", transform: "scale(0.9)" },
    { offset: 1, opacity: "1", transform: "scale(1)" }
  ]);
  return baseAnimation.addElement(baseEl).easing("ease-in-out").duration(150).addAnimation([backdropAnimation, wrapperAnimation]);
};
const mdLeaveAnimation$1 = (baseEl) => {
  const baseAnimation = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(baseEl.querySelector(".alert-wrapper")).fromTo("opacity", 0.99, 0);
  return baseAnimation.addElement(baseEl).easing("ease-in-out").duration(150).addAnimation([backdropAnimation, wrapperAnimation]);
};
const alertIosCss = ".sc-ion-alert-ios-h{--min-width:250px;--width:auto;--min-height:auto;--height:auto;--max-height:90%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-alert-ios-h{display:none}.alert-top.sc-ion-alert-ios-h{padding-top:50px;-ms-flex-align:start;align-items:flex-start}.alert-wrapper.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:content;opacity:0;z-index:10}.alert-title.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-sub-title.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-weight:normal}.alert-message.sc-ion-alert-ios,.alert-input-group.sc-ion-alert-ios{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow-y:auto;overscroll-behavior-y:contain}.alert-checkbox-label.sc-ion-alert-ios,.alert-radio-label.sc-ion-alert-ios{overflow-wrap:anywhere}@media (any-pointer: coarse){.alert-checkbox-group.sc-ion-alert-ios::-webkit-scrollbar,.alert-radio-group.sc-ion-alert-ios::-webkit-scrollbar,.alert-message.sc-ion-alert-ios::-webkit-scrollbar{display:none}}.alert-input.sc-ion-alert-ios{padding-left:0;padding-right:0;padding-top:10px;padding-bottom:10px;width:100%;border:0;background:inherit;font:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.alert-button-group.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;width:100%}.alert-button-group-vertical.sc-ion-alert-ios{-ms-flex-direction:column;flex-direction:column;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.alert-button.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;border:0;font-size:0.875rem;line-height:1.25rem;z-index:0}.alert-button.ion-focused.sc-ion-alert-ios,.alert-tappable.ion-focused.sc-ion-alert-ios{background:var(--ion-color-step-100, #e6e6e6)}.alert-button-inner.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;min-height:inherit}.alert-input-disabled.sc-ion-alert-ios,.alert-checkbox-button-disabled.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios,.alert-radio-button-disabled.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios{cursor:default;opacity:0.5;pointer-events:none}.alert-tappable.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;width:100%;border:0;background:transparent;font-size:inherit;line-height:initial;text-align:start;-webkit-appearance:none;-moz-appearance:none;appearance:none;contain:content}.alert-button.sc-ion-alert-ios,.alert-checkbox.sc-ion-alert-ios,.alert-input.sc-ion-alert-ios,.alert-radio.sc-ion-alert-ios{outline:none}.alert-radio-icon.sc-ion-alert-ios,.alert-checkbox-icon.sc-ion-alert-ios,.alert-checkbox-inner.sc-ion-alert-ios{-webkit-box-sizing:border-box;box-sizing:border-box}textarea.alert-input.sc-ion-alert-ios{min-height:37px;resize:none}.sc-ion-alert-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--max-width:clamp(270px, 16.875rem, 324px);--backdrop-opacity:var(--ion-backdrop-opacity, 0.3);font-size:max(14px, 0.875rem)}.alert-wrapper.sc-ion-alert-ios{border-radius:13px;-webkit-box-shadow:none;box-shadow:none;overflow:hidden}.alert-button.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios{pointer-events:none}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.alert-translucent.sc-ion-alert-ios-h .alert-wrapper.sc-ion-alert-ios{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.9);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}.alert-head.sc-ion-alert-ios{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:12px;padding-bottom:7px;text-align:center}.alert-title.sc-ion-alert-ios{margin-top:8px;color:var(--ion-text-color, #000);font-size:max(17px, 1.0625rem);font-weight:600}.alert-sub-title.sc-ion-alert-ios{color:var(--ion-color-step-600, #666666);font-size:max(14px, 0.875rem)}.alert-message.sc-ion-alert-ios,.alert-input-group.sc-ion-alert-ios{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0;padding-bottom:21px;color:var(--ion-text-color, #000);font-size:max(13px, 0.8125rem);text-align:center}.alert-message.sc-ion-alert-ios{max-height:240px}.alert-message.sc-ion-alert-ios:empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:12px}.alert-input.sc-ion-alert-ios{border-radius:4px;margin-top:10px;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px;padding-top:6px;padding-bottom:6px;border:0.55px solid var(--ion-color-step-250, #bfbfbf);background-color:var(--ion-background-color, #fff);-webkit-appearance:none;-moz-appearance:none;appearance:none}.alert-input.sc-ion-alert-ios::-webkit-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-moz-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios:-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-ms-clear{display:none}.alert-input.sc-ion-alert-ios::-webkit-date-and-time-value{height:18px}.alert-radio-group.sc-ion-alert-ios,.alert-checkbox-group.sc-ion-alert-ios{-ms-scroll-chaining:none;overscroll-behavior:contain;max-height:240px;border-top:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);overflow-y:auto;-webkit-overflow-scrolling:touch}.alert-tappable.sc-ion-alert-ios{min-height:44px}.alert-radio-label.sc-ion-alert-ios{-webkit-padding-start:13px;padding-inline-start:13px;-webkit-padding-end:13px;padding-inline-end:13px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;-ms-flex-order:0;order:0;color:var(--ion-text-color, #000)}[aria-checked=true].sc-ion-alert-ios .alert-radio-label.sc-ion-alert-ios{color:var(--ion-color-primary, #3880ff)}.alert-radio-icon.sc-ion-alert-ios{position:relative;-ms-flex-order:1;order:1;min-width:30px}[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{top:-7px;position:absolute;width:6px;height:12px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-color-primary, #3880ff)}@supports (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{inset-inline-start:7px}}@supports not (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:7px}[dir=rtl].sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios,[dir=rtl] .sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:unset;right:unset;right:7px}[dir=rtl].sc-ion-alert-ios [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:unset;right:unset;right:7px}@supports selector(:dir(rtl)){[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios:dir(rtl){left:unset;right:unset;right:7px}}}.alert-checkbox-label.sc-ion-alert-ios{-webkit-padding-start:13px;padding-inline-start:13px;-webkit-padding-end:13px;padding-inline-end:13px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;color:var(--ion-text-color, #000)}.alert-checkbox-icon.sc-ion-alert-ios{border-radius:50%;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:6px;margin-inline-end:6px;margin-top:10px;margin-bottom:10px;position:relative;width:min(1.5rem, 66px);height:min(1.5rem, 66px);border-width:0.0625rem;border-style:solid;border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));background-color:var(--ion-item-background, var(--ion-background-color, #fff));contain:strict}[aria-checked=true].sc-ion-alert-ios .alert-checkbox-icon.sc-ion-alert-ios{border-color:var(--ion-color-primary, #3880ff);background-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{top:calc(min(1.5rem, 66px) / 6);position:absolute;width:calc(min(1.5rem, 66px) / 6 + 1px);height:calc(min(1.5rem, 66px) * 0.5);-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:0.0625rem;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-background-color, #fff)}@supports (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{inset-inline-start:calc(min(1.5rem, 66px) / 3 + 1px)}}@supports not (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:calc(min(1.5rem, 66px) / 3 + 1px)}[dir=rtl].sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios,[dir=rtl] .sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:unset;right:unset;right:calc(min(1.5rem, 66px) / 3 + 1px)}[dir=rtl].sc-ion-alert-ios [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:unset;right:unset;right:calc(min(1.5rem, 66px) / 3 + 1px)}@supports selector(:dir(rtl)){[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios:dir(rtl){left:unset;right:unset;right:calc(min(1.5rem, 66px) / 3 + 1px)}}}.alert-button-group.sc-ion-alert-ios{-webkit-margin-end:-0.55px;margin-inline-end:-0.55px;-ms-flex-wrap:wrap;flex-wrap:wrap}.alert-button-group-vertical.sc-ion-alert-ios .alert-button.sc-ion-alert-ios{border-right:none}[dir=rtl].sc-ion-alert-ios-h .alert-button-group-vertical.sc-ion-alert-ios .alert-button.sc-ion-alert-ios:last-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button-group-vertical.sc-ion-alert-ios .alert-button.sc-ion-alert-ios:last-child{border-right:none}[dir=rtl].sc-ion-alert-ios .alert-button-group-vertical.sc-ion-alert-ios .alert-button.sc-ion-alert-ios:last-child{border-right:none}@supports selector(:dir(rtl)){.alert-button-group-vertical.sc-ion-alert-ios .alert-button.sc-ion-alert-ios:last-child:dir(rtl){border-right:none}}.alert-button.sc-ion-alert-ios{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:0;-ms-flex:1 1 auto;flex:1 1 auto;min-width:50%;height:max(44px, 2.75rem);border-top:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);background-color:transparent;color:var(--ion-color-primary, #3880ff);font-size:max(17px, 1.0625rem);overflow:hidden}[dir=rtl].sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:first-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:first-child{border-right:0}[dir=rtl].sc-ion-alert-ios .alert-button.sc-ion-alert-ios:first-child{border-right:0}@supports selector(:dir(rtl)){.alert-button.sc-ion-alert-ios:first-child:dir(rtl){border-right:0}}.alert-button.sc-ion-alert-ios:last-child{border-right:0;font-weight:bold}[dir=rtl].sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:last-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:last-child{border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}[dir=rtl].sc-ion-alert-ios .alert-button.sc-ion-alert-ios:last-child{border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}@supports selector(:dir(rtl)){.alert-button.sc-ion-alert-ios:last-child:dir(rtl){border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}}.alert-button.ion-activated.sc-ion-alert-ios{background-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1)}.alert-button-role-destructive.sc-ion-alert-ios,.alert-button-role-destructive.ion-activated.sc-ion-alert-ios,.alert-button-role-destructive.ion-focused.sc-ion-alert-ios{color:var(--ion-color-danger, #eb445a)}";
const IonAlertIosStyle0 = alertIosCss;
const alertMdCss = ".sc-ion-alert-md-h{--min-width:250px;--width:auto;--min-height:auto;--height:auto;--max-height:90%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-alert-md-h{display:none}.alert-top.sc-ion-alert-md-h{padding-top:50px;-ms-flex-align:start;align-items:flex-start}.alert-wrapper.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:content;opacity:0;z-index:10}.alert-title.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-sub-title.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-weight:normal}.alert-message.sc-ion-alert-md,.alert-input-group.sc-ion-alert-md{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow-y:auto;overscroll-behavior-y:contain}.alert-checkbox-label.sc-ion-alert-md,.alert-radio-label.sc-ion-alert-md{overflow-wrap:anywhere}@media (any-pointer: coarse){.alert-checkbox-group.sc-ion-alert-md::-webkit-scrollbar,.alert-radio-group.sc-ion-alert-md::-webkit-scrollbar,.alert-message.sc-ion-alert-md::-webkit-scrollbar{display:none}}.alert-input.sc-ion-alert-md{padding-left:0;padding-right:0;padding-top:10px;padding-bottom:10px;width:100%;border:0;background:inherit;font:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.alert-button-group.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;width:100%}.alert-button-group-vertical.sc-ion-alert-md{-ms-flex-direction:column;flex-direction:column;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.alert-button.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;border:0;font-size:0.875rem;line-height:1.25rem;z-index:0}.alert-button.ion-focused.sc-ion-alert-md,.alert-tappable.ion-focused.sc-ion-alert-md{background:var(--ion-color-step-100, #e6e6e6)}.alert-button-inner.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;min-height:inherit}.alert-input-disabled.sc-ion-alert-md,.alert-checkbox-button-disabled.sc-ion-alert-md .alert-button-inner.sc-ion-alert-md,.alert-radio-button-disabled.sc-ion-alert-md .alert-button-inner.sc-ion-alert-md{cursor:default;opacity:0.5;pointer-events:none}.alert-tappable.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;width:100%;border:0;background:transparent;font-size:inherit;line-height:initial;text-align:start;-webkit-appearance:none;-moz-appearance:none;appearance:none;contain:content}.alert-button.sc-ion-alert-md,.alert-checkbox.sc-ion-alert-md,.alert-input.sc-ion-alert-md,.alert-radio.sc-ion-alert-md{outline:none}.alert-radio-icon.sc-ion-alert-md,.alert-checkbox-icon.sc-ion-alert-md,.alert-checkbox-inner.sc-ion-alert-md{-webkit-box-sizing:border-box;box-sizing:border-box}textarea.alert-input.sc-ion-alert-md{min-height:37px;resize:none}.sc-ion-alert-md-h{--background:var(--ion-overlay-background-color, var(--ion-background-color, #fff));--max-width:280px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);font-size:0.875rem}.alert-wrapper.sc-ion-alert-md{border-radius:4px;-webkit-box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12);box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12)}.alert-head.sc-ion-alert-md{-webkit-padding-start:23px;padding-inline-start:23px;-webkit-padding-end:23px;padding-inline-end:23px;padding-top:20px;padding-bottom:15px;text-align:start}.alert-title.sc-ion-alert-md{color:var(--ion-text-color, #000);font-size:1.25rem;font-weight:500}.alert-sub-title.sc-ion-alert-md{color:var(--ion-text-color, #000);font-size:1rem}.alert-message.sc-ion-alert-md,.alert-input-group.sc-ion-alert-md{-webkit-padding-start:24px;padding-inline-start:24px;-webkit-padding-end:24px;padding-inline-end:24px;padding-top:20px;padding-bottom:20px;color:var(--ion-color-step-550, #737373)}.alert-message.sc-ion-alert-md{font-size:1rem}@media screen and (max-width: 767px){.alert-message.sc-ion-alert-md{max-height:266px}}.alert-message.sc-ion-alert-md:empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-head.sc-ion-alert-md+.alert-message.sc-ion-alert-md{padding-top:0}.alert-input.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px;border-bottom:1px solid var(--ion-color-step-150, #d9d9d9);color:var(--ion-text-color, #000)}.alert-input.sc-ion-alert-md::-webkit-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-moz-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md:-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-ms-clear{display:none}.alert-input.sc-ion-alert-md:focus{margin-bottom:4px;border-bottom:2px solid var(--ion-color-primary, #3880ff)}.alert-radio-group.sc-ion-alert-md,.alert-checkbox-group.sc-ion-alert-md{position:relative;border-top:1px solid var(--ion-color-step-150, #d9d9d9);border-bottom:1px solid var(--ion-color-step-150, #d9d9d9);overflow:auto}@media screen and (max-width: 767px){.alert-radio-group.sc-ion-alert-md,.alert-checkbox-group.sc-ion-alert-md{max-height:266px}}.alert-tappable.sc-ion-alert-md{position:relative;min-height:48px}.alert-radio-label.sc-ion-alert-md{-webkit-padding-start:52px;padding-inline-start:52px;-webkit-padding-end:26px;padding-inline-end:26px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;color:var(--ion-color-step-850, #262626);font-size:1rem}.alert-radio-icon.sc-ion-alert-md{top:0;border-radius:50%;display:block;position:relative;width:20px;height:20px;border-width:2px;border-style:solid;border-color:var(--ion-color-step-550, #737373)}@supports (inset-inline-start: 0){.alert-radio-icon.sc-ion-alert-md{inset-inline-start:26px}}@supports not (inset-inline-start: 0){.alert-radio-icon.sc-ion-alert-md{left:26px}[dir=rtl].sc-ion-alert-md-h .alert-radio-icon.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-radio-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}[dir=rtl].sc-ion-alert-md .alert-radio-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}@supports selector(:dir(rtl)){.alert-radio-icon.sc-ion-alert-md:dir(rtl){left:unset;right:unset;right:26px}}}.alert-radio-inner.sc-ion-alert-md{top:3px;border-radius:50%;position:absolute;width:10px;height:10px;-webkit-transform:scale3d(0, 0, 0);transform:scale3d(0, 0, 0);-webkit-transition:-webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:-webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--ion-color-primary, #3880ff)}@supports (inset-inline-start: 0){.alert-radio-inner.sc-ion-alert-md{inset-inline-start:3px}}@supports not (inset-inline-start: 0){.alert-radio-inner.sc-ion-alert-md{left:3px}[dir=rtl].sc-ion-alert-md-h .alert-radio-inner.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-radio-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}[dir=rtl].sc-ion-alert-md .alert-radio-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}@supports selector(:dir(rtl)){.alert-radio-inner.sc-ion-alert-md:dir(rtl){left:unset;right:unset;right:3px}}}[aria-checked=true].sc-ion-alert-md .alert-radio-label.sc-ion-alert-md{color:var(--ion-color-step-850, #262626)}[aria-checked=true].sc-ion-alert-md .alert-radio-icon.sc-ion-alert-md{border-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-md .alert-radio-inner.sc-ion-alert-md{-webkit-transform:scale3d(1, 1, 1);transform:scale3d(1, 1, 1)}.alert-checkbox-label.sc-ion-alert-md{-webkit-padding-start:53px;padding-inline-start:53px;-webkit-padding-end:26px;padding-inline-end:26px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;width:calc(100% - 53px);color:var(--ion-color-step-850, #262626);font-size:1rem}.alert-checkbox-icon.sc-ion-alert-md{top:0;border-radius:2px;position:relative;width:16px;height:16px;border-width:2px;border-style:solid;border-color:var(--ion-color-step-550, #737373);contain:strict}@supports (inset-inline-start: 0){.alert-checkbox-icon.sc-ion-alert-md{inset-inline-start:26px}}@supports not (inset-inline-start: 0){.alert-checkbox-icon.sc-ion-alert-md{left:26px}[dir=rtl].sc-ion-alert-md-h .alert-checkbox-icon.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-checkbox-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}[dir=rtl].sc-ion-alert-md .alert-checkbox-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}@supports selector(:dir(rtl)){.alert-checkbox-icon.sc-ion-alert-md:dir(rtl){left:unset;right:unset;right:26px}}}[aria-checked=true].sc-ion-alert-md .alert-checkbox-icon.sc-ion-alert-md{border-color:var(--ion-color-primary, #3880ff);background-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{top:0;position:absolute;width:6px;height:10px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-color-primary-contrast, #fff)}@supports (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{inset-inline-start:3px}}@supports not (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:3px}[dir=rtl].sc-ion-alert-md-h [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}[dir=rtl].sc-ion-alert-md [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}@supports selector(:dir(rtl)){[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md:dir(rtl){left:unset;right:unset;right:3px}}}.alert-button-group.sc-ion-alert-md{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;-webkit-box-sizing:border-box;box-sizing:border-box;-ms-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;-ms-flex-pack:end;justify-content:flex-end}.alert-button.sc-ion-alert-md{border-radius:2px;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:0;margin-bottom:0;-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px;padding-top:10px;padding-bottom:10px;position:relative;background-color:transparent;color:var(--ion-color-primary, #3880ff);font-weight:500;text-align:end;text-transform:uppercase;overflow:hidden}.alert-button-inner.sc-ion-alert-md{-ms-flex-pack:end;justify-content:flex-end}@media screen and (min-width: 768px){.sc-ion-alert-md-h{--max-width:min(100vw - 96px, 560px);--max-height:min(100vh - 96px, 560px)}}";
const IonAlertMdStyle0 = alertMdCss;
const Alert = /* @__PURE__ */ proxyCustomElement(class Alert2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.didPresent = createEvent(this, "ionAlertDidPresent", 7);
    this.willPresent = createEvent(this, "ionAlertWillPresent", 7);
    this.willDismiss = createEvent(this, "ionAlertWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionAlertDidDismiss", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.delegateController = createDelegateController(this);
    this.lockController = createLockController();
    this.triggerController = createTriggerController();
    this.customHTMLEnabled = config$1.get("innerHTMLTemplatesEnabled", ENABLE_HTML_CONTENT_DEFAULT);
    this.processedInputs = [];
    this.processedButtons = [];
    this.presented = false;
    this.onBackdropTap = () => {
      this.dismiss(void 0, BACKDROP);
    };
    this.dispatchCancelHandler = (ev) => {
      const role = ev.detail.role;
      if (isCancel(role)) {
        const cancelButton = this.processedButtons.find((b2) => b2.role === "cancel");
        this.callButtonHandler(cancelButton);
      }
    };
    this.overlayIndex = void 0;
    this.delegate = void 0;
    this.hasController = false;
    this.keyboardClose = true;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.cssClass = void 0;
    this.header = void 0;
    this.subHeader = void 0;
    this.message = void 0;
    this.buttons = [];
    this.inputs = [];
    this.backdropDismiss = true;
    this.translucent = false;
    this.animated = true;
    this.htmlAttributes = void 0;
    this.isOpen = false;
    this.trigger = void 0;
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  triggerChanged() {
    const { trigger, el: el2, triggerController } = this;
    if (trigger) {
      triggerController.addClickListener(el2, trigger);
    }
  }
  onKeydown(ev) {
    const inputTypes = new Set(this.processedInputs.map((i) => i.type));
    if (inputTypes.has("checkbox") && ev.key === "Enter") {
      ev.preventDefault();
      return;
    }
    if (!inputTypes.has("radio") || ev.target && !this.el.contains(ev.target) || ev.target.classList.contains("alert-button")) {
      return;
    }
    const query = this.el.querySelectorAll(".alert-radio");
    const radios = Array.from(query).filter((radio) => !radio.disabled);
    const index = radios.findIndex((radio) => radio.id === ev.target.id);
    let nextEl;
    if (["ArrowDown", "ArrowRight"].includes(ev.key)) {
      nextEl = index === radios.length - 1 ? radios[0] : radios[index + 1];
    }
    if (["ArrowUp", "ArrowLeft"].includes(ev.key)) {
      nextEl = index === 0 ? radios[radios.length - 1] : radios[index - 1];
    }
    if (nextEl && radios.includes(nextEl)) {
      const nextProcessed = this.processedInputs.find((input) => input.id === (nextEl === null || nextEl === void 0 ? void 0 : nextEl.id));
      if (nextProcessed) {
        this.rbClick(nextProcessed);
        nextEl.focus();
      }
    }
  }
  buttonsChanged() {
    const buttons = this.buttons;
    this.processedButtons = buttons.map((btn) => {
      return typeof btn === "string" ? { text: btn, role: btn.toLowerCase() === "cancel" ? "cancel" : void 0 } : btn;
    });
  }
  inputsChanged() {
    const inputs = this.inputs;
    const first = inputs.find((input) => !input.disabled);
    const checked2 = inputs.find((input) => input.checked && !input.disabled);
    const focusable = checked2 || first;
    const inputTypes = new Set(inputs.map((i) => i.type));
    if (inputTypes.has("checkbox") && inputTypes.has("radio")) {
      console.warn(`Alert cannot mix input types: ${Array.from(inputTypes.values()).join("/")}. Please see alert docs for more info.`);
    }
    this.inputType = inputTypes.values().next().value;
    this.processedInputs = inputs.map((i, index) => {
      var _a;
      return {
        type: i.type || "text",
        name: i.name || `${index}`,
        placeholder: i.placeholder || "",
        value: i.value,
        label: i.label,
        checked: !!i.checked,
        disabled: !!i.disabled,
        id: i.id || `alert-input-${this.overlayIndex}-${index}`,
        handler: i.handler,
        min: i.min,
        max: i.max,
        cssClass: (_a = i.cssClass) !== null && _a !== void 0 ? _a : "",
        attributes: i.attributes || {},
        tabindex: i.type === "radio" && i !== focusable ? -1 : 0
      };
    });
  }
  connectedCallback() {
    prepareOverlay(this.el);
    this.triggerChanged();
  }
  componentWillLoad() {
    setOverlayId(this.el);
    this.inputsChanged();
    this.buttonsChanged();
  }
  disconnectedCallback() {
    this.triggerController.removeClickListener();
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
  }
  componentDidLoad() {
    if (!this.gesture && getIonMode$2(this) === "ios" && this.wrapperEl) {
      this.gesture = createButtonActiveGesture(this.wrapperEl, (refEl) => refEl.classList.contains("alert-button"));
      this.gesture.enable(true);
    }
    if (this.isOpen === true) {
      raf(() => this.present());
    }
    this.triggerChanged();
  }
  /**
   * Present the alert overlay after it has been created.
   */
  async present() {
    const unlock = await this.lockController.lock();
    await this.delegateController.attachViewToDom();
    await present(this, "alertEnter", iosEnterAnimation$1, mdEnterAnimation$1);
    unlock();
  }
  /**
   * Dismiss the alert overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the alert.
   * This can be useful in a button handler for determining which button was
   * clicked to dismiss the alert.
   * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
   *
   * This is a no-op if the overlay has not been presented yet. If you want
   * to remove an overlay from the DOM that was never presented, use the
   * [remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.
   */
  async dismiss(data, role) {
    const unlock = await this.lockController.lock();
    const dismissed = await dismiss(this, data, role, "alertLeave", iosLeaveAnimation$1, mdLeaveAnimation$1);
    if (dismissed) {
      this.delegateController.removeViewFromDom();
    }
    unlock();
    return dismissed;
  }
  /**
   * Returns a promise that resolves when the alert did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionAlertDidDismiss");
  }
  /**
   * Returns a promise that resolves when the alert will dismiss.
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionAlertWillDismiss");
  }
  rbClick(selectedInput) {
    for (const input of this.processedInputs) {
      input.checked = input === selectedInput;
      input.tabindex = input === selectedInput ? 0 : -1;
    }
    this.activeId = selectedInput.id;
    safeCall(selectedInput.handler, selectedInput);
    forceUpdate(this);
  }
  cbClick(selectedInput) {
    selectedInput.checked = !selectedInput.checked;
    safeCall(selectedInput.handler, selectedInput);
    forceUpdate(this);
  }
  async buttonClick(button) {
    const role = button.role;
    const values = this.getValues();
    if (isCancel(role)) {
      return this.dismiss({ values }, role);
    }
    const returnData = await this.callButtonHandler(button, values);
    if (returnData !== false) {
      return this.dismiss(Object.assign({ values }, returnData), button.role);
    }
    return false;
  }
  async callButtonHandler(button, data) {
    if (button === null || button === void 0 ? void 0 : button.handler) {
      const returnData = await safeCall(button.handler, data);
      if (returnData === false) {
        return false;
      }
      if (typeof returnData === "object") {
        return returnData;
      }
    }
    return {};
  }
  getValues() {
    if (this.processedInputs.length === 0) {
      return void 0;
    }
    if (this.inputType === "radio") {
      const checkedInput = this.processedInputs.find((i) => !!i.checked);
      return checkedInput ? checkedInput.value : void 0;
    }
    if (this.inputType === "checkbox") {
      return this.processedInputs.filter((i) => i.checked).map((i) => i.value);
    }
    const values = {};
    this.processedInputs.forEach((i) => {
      values[i.name] = i.value || "";
    });
    return values;
  }
  renderAlertInputs() {
    switch (this.inputType) {
      case "checkbox":
        return this.renderCheckbox();
      case "radio":
        return this.renderRadio();
      default:
        return this.renderInput();
    }
  }
  renderCheckbox() {
    const inputs = this.processedInputs;
    const mode = getIonMode$2(this);
    if (inputs.length === 0) {
      return null;
    }
    return h$1("div", { class: "alert-checkbox-group" }, inputs.map((i) => h$1("button", { type: "button", onClick: () => this.cbClick(i), "aria-checked": `${i.checked}`, id: i.id, disabled: i.disabled, tabIndex: i.tabindex, role: "checkbox", class: Object.assign(Object.assign({}, getClassMap(i.cssClass)), { "alert-tappable": true, "alert-checkbox": true, "alert-checkbox-button": true, "ion-focusable": true, "alert-checkbox-button-disabled": i.disabled || false }) }, h$1("div", { class: "alert-button-inner" }, h$1("div", { class: "alert-checkbox-icon" }, h$1("div", { class: "alert-checkbox-inner" })), h$1("div", { class: "alert-checkbox-label" }, i.label)), mode === "md" && h$1("ion-ripple-effect", null))));
  }
  renderRadio() {
    const inputs = this.processedInputs;
    if (inputs.length === 0) {
      return null;
    }
    return h$1("div", { class: "alert-radio-group", role: "radiogroup", "aria-activedescendant": this.activeId }, inputs.map((i) => h$1("button", { type: "button", onClick: () => this.rbClick(i), "aria-checked": `${i.checked}`, disabled: i.disabled, id: i.id, tabIndex: i.tabindex, class: Object.assign(Object.assign({}, getClassMap(i.cssClass)), { "alert-radio-button": true, "alert-tappable": true, "alert-radio": true, "ion-focusable": true, "alert-radio-button-disabled": i.disabled || false }), role: "radio" }, h$1("div", { class: "alert-button-inner" }, h$1("div", { class: "alert-radio-icon" }, h$1("div", { class: "alert-radio-inner" })), h$1("div", { class: "alert-radio-label" }, i.label)))));
  }
  renderInput() {
    const inputs = this.processedInputs;
    if (inputs.length === 0) {
      return null;
    }
    return h$1("div", { class: "alert-input-group" }, inputs.map((i) => {
      var _a, _b, _c, _d;
      if (i.type === "textarea") {
        return h$1("div", { class: "alert-input-wrapper" }, h$1("textarea", Object.assign({ placeholder: i.placeholder, value: i.value, id: i.id, tabIndex: i.tabindex }, i.attributes, { disabled: (_b = (_a = i.attributes) === null || _a === void 0 ? void 0 : _a.disabled) !== null && _b !== void 0 ? _b : i.disabled, class: inputClass(i), onInput: (e2) => {
          var _a2;
          i.value = e2.target.value;
          if ((_a2 = i.attributes) === null || _a2 === void 0 ? void 0 : _a2.onInput) {
            i.attributes.onInput(e2);
          }
        } })));
      } else {
        return h$1("div", { class: "alert-input-wrapper" }, h$1("input", Object.assign({ placeholder: i.placeholder, type: i.type, min: i.min, max: i.max, value: i.value, id: i.id, tabIndex: i.tabindex }, i.attributes, { disabled: (_d = (_c = i.attributes) === null || _c === void 0 ? void 0 : _c.disabled) !== null && _d !== void 0 ? _d : i.disabled, class: inputClass(i), onInput: (e2) => {
          var _a2;
          i.value = e2.target.value;
          if ((_a2 = i.attributes) === null || _a2 === void 0 ? void 0 : _a2.onInput) {
            i.attributes.onInput(e2);
          }
        } })));
      }
    }));
  }
  renderAlertButtons() {
    const buttons = this.processedButtons;
    const mode = getIonMode$2(this);
    const alertButtonGroupClass = {
      "alert-button-group": true,
      "alert-button-group-vertical": buttons.length > 2
    };
    return h$1("div", { class: alertButtonGroupClass }, buttons.map((button) => h$1("button", Object.assign({}, button.htmlAttributes, { type: "button", id: button.id, class: buttonClass(button), tabIndex: 0, onClick: () => this.buttonClick(button) }), h$1("span", { class: "alert-button-inner" }, button.text), mode === "md" && h$1("ion-ripple-effect", null))));
  }
  renderAlertMessage(msgId) {
    const { customHTMLEnabled, message } = this;
    if (customHTMLEnabled) {
      return h$1("div", { id: msgId, class: "alert-message", innerHTML: sanitizeDOMString(message) });
    }
    return h$1("div", { id: msgId, class: "alert-message" }, message);
  }
  render() {
    const { overlayIndex, header, subHeader, message, htmlAttributes } = this;
    const mode = getIonMode$2(this);
    const hdrId = `alert-${overlayIndex}-hdr`;
    const subHdrId = `alert-${overlayIndex}-sub-hdr`;
    const msgId = `alert-${overlayIndex}-msg`;
    const role = this.inputs.length > 0 || this.buttons.length > 0 ? "alertdialog" : "alert";
    const ariaLabelledBy = header ? hdrId : subHeader ? subHdrId : null;
    return h$1(Host, Object.assign({ key: "4b7f7880dc5f39aa9b61981af0a821ac0350af7f", role, "aria-modal": "true", "aria-labelledby": ariaLabelledBy, "aria-describedby": message !== void 0 ? msgId : null, tabindex: "-1" }, htmlAttributes, { style: {
      zIndex: `${2e4 + overlayIndex}`
    }, class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), { [mode]: true, "overlay-hidden": true, "alert-translucent": this.translucent }), onIonAlertWillDismiss: this.dispatchCancelHandler, onIonBackdropTap: this.onBackdropTap }), h$1("ion-backdrop", { key: "961a2684013ac61d59882914fd8d759ddb542fe7", tappable: this.backdropDismiss }), h$1("div", { key: "2ec08c3719b3cd8a4cae09d2c6ac778ffad5f940", tabindex: "0" }), h$1("div", { key: "ee543683d20693c9a9497aca4d41f032aa580c9c", class: "alert-wrapper ion-overlay-wrapper", ref: (el2) => this.wrapperEl = el2 }, h$1("div", { key: "55015102b67d080249a8859fc8788f3a82d5ead9", class: "alert-head" }, header && h$1("h2", { id: hdrId, class: "alert-title" }, header), subHeader && h$1("h2", { id: subHdrId, class: "alert-sub-title" }, subHeader)), this.renderAlertMessage(msgId), this.renderAlertInputs(), this.renderAlertButtons()), h$1("div", { key: "df7bcfb0cb41965f169de05edd631a050d5ce648", tabindex: "0" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["triggerChanged"],
      "buttons": ["buttonsChanged"],
      "inputs": ["inputsChanged"]
    };
  }
  static get style() {
    return {
      ios: IonAlertIosStyle0,
      md: IonAlertMdStyle0
    };
  }
}, [34, "ion-alert", {
  "overlayIndex": [2, "overlay-index"],
  "delegate": [16],
  "hasController": [4, "has-controller"],
  "keyboardClose": [4, "keyboard-close"],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "cssClass": [1, "css-class"],
  "header": [1],
  "subHeader": [1, "sub-header"],
  "message": [1],
  "buttons": [16],
  "inputs": [1040],
  "backdropDismiss": [4, "backdrop-dismiss"],
  "translucent": [4],
  "animated": [4],
  "htmlAttributes": [16],
  "isOpen": [4, "is-open"],
  "trigger": [1],
  "present": [64],
  "dismiss": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64]
}, [[4, "keydown", "onKeydown"]], {
  "isOpen": ["onIsOpenChange"],
  "trigger": ["triggerChanged"],
  "buttons": ["buttonsChanged"],
  "inputs": ["inputsChanged"]
}]);
const inputClass = (input) => {
  var _a, _b, _c;
  return Object.assign(Object.assign({ "alert-input": true, "alert-input-disabled": ((_b = (_a = input.attributes) === null || _a === void 0 ? void 0 : _a.disabled) !== null && _b !== void 0 ? _b : input.disabled) || false }, getClassMap(input.cssClass)), getClassMap(input.attributes ? (_c = input.attributes.class) === null || _c === void 0 ? void 0 : _c.toString() : ""));
};
const buttonClass = (button) => {
  return Object.assign({ "alert-button": true, "ion-focusable": true, "ion-activatable": true, [`alert-button-role-${button.role}`]: button.role !== void 0 }, getClassMap(button.cssClass));
};
function defineCustomElement$d() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-alert", "ion-backdrop", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-alert":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Alert);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$z();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$w();
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$c = defineCustomElement$o;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const titleIosCss = ":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{top:0;-webkit-padding-start:90px;padding-inline-start:90px;-webkit-padding-end:90px;padding-inline-end:90px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);position:absolute;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0);font-size:min(1.0625rem, 20.4px);font-weight:600;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}@supports (inset-inline-start: 0){:host{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host{left:0}:host-context([dir=rtl]){left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(:dir(rtl)){left:unset;right:unset;right:0}}}:host(.title-small){-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px;padding-top:6px;padding-bottom:16px;position:relative;font-size:min(0.8125rem, 23.4px);font-weight:normal}:host(.title-large){-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:2px;padding-bottom:4px;-webkit-transform-origin:left center;transform-origin:left center;position:static;-ms-flex-align:end;align-items:flex-end;min-width:100%;font-size:min(2.125rem, 61.2px);font-weight:700;text-align:start}:host(.title-large.title-rtl){-webkit-transform-origin:right center;transform-origin:right center}:host(.title-large.ion-cloned-element){--color:var(--ion-text-color, #000);font-family:var(--ion-font-family)}:host(.title-large) .toolbar-title{-webkit-transform-origin:inherit;transform-origin:inherit;width:auto}:host-context([dir=rtl]):host(.title-large) .toolbar-title,:host-context([dir=rtl]).title-large .toolbar-title{-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}@supports selector(:dir(rtl)){:host(.title-large:dir(rtl)) .toolbar-title{-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}}";
const IonTitleIosStyle0 = titleIosCss;
const titleMdCss = ":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px;padding-top:0;padding-bottom:0;font-size:1.25rem;font-weight:500;letter-spacing:0.0125em}:host(.title-small){width:100%;height:100%;font-size:0.9375rem;font-weight:normal}";
const IonTitleMdStyle0 = titleMdCss;
const ToolbarTitle = /* @__PURE__ */ proxyCustomElement(class ToolbarTitle2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.color = void 0;
    this.size = void 0;
  }
  sizeChanged() {
    this.emitStyle();
  }
  connectedCallback() {
    this.emitStyle();
  }
  emitStyle() {
    const size = this.getSize();
    this.ionStyle.emit({
      [`title-${size}`]: true
    });
  }
  getSize() {
    return this.size !== void 0 ? this.size : "default";
  }
  render() {
    const mode = getIonMode$2(this);
    const size = this.getSize();
    return h$1(Host, { key: "b68a272a33ec81d282629a569676f64d3215a0c7", class: createColorClasses$2(this.color, {
      [mode]: true,
      [`title-${size}`]: true,
      "title-rtl": document.dir === "rtl"
    }) }, h$1("div", { key: "9069816a14e6e358695c5bd465787cf297c761bc", class: "toolbar-title" }, h$1("slot", { key: "8894bd04f2292b54050ee864abb5396deadf9874" })));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "size": ["sizeChanged"]
    };
  }
  static get style() {
    return {
      ios: IonTitleIosStyle0,
      md: IonTitleMdStyle0
    };
  }
}, [33, "ion-title", {
  "color": [513],
  "size": [1]
}, void 0, {
  "size": ["sizeChanged"]
}]);
function defineCustomElement$1$8() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-title"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-title":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ToolbarTitle);
        }
        break;
    }
  });
}
const defineCustomElement$b = defineCustomElement$1$8;
const toggleIosCss = ":host{-webkit-box-sizing:content-box !important;box-sizing:content-box !important;display:inline-block;position:relative;max-width:100%;outline:none;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.in-item:not(.legacy-toggle)){width:100%;height:100%}:host([slot=start]:not(.legacy-toggle)),:host([slot=end]:not(.legacy-toggle)){width:auto}:host(.legacy-toggle){contain:content;-ms-touch-action:none;touch-action:none}:host(.ion-focused) input{border:2px solid #5e9ed6}:host(.toggle-disabled){pointer-events:none}:host(.legacy-toggle) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0;pointer-events:none}@supports (inset-inline-start: 0){:host(.legacy-toggle) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-toggle) label{left:0}:host-context([dir=rtl]):host(.legacy-toggle) label,:host-context([dir=rtl]).legacy-toggle label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-toggle:dir(rtl)) label{left:unset;right:unset;right:0}}}:host(.legacy-toggle) label::-moz-focus-inner{border:0}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.toggle-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;cursor:inherit}.label-text-wrapper{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}:host(.in-item:not(.legacy-toggle)) .label-text-wrapper{margin-top:10px;margin-bottom:10px}:host(.in-item.toggle-label-placement-stacked) .label-text-wrapper{margin-top:10px;margin-bottom:16px}:host(.in-item.toggle-label-placement-stacked) .native-wrapper{margin-bottom:10px}.label-text-wrapper-hidden{display:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host(.toggle-justify-space-between) .toggle-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.toggle-justify-start) .toggle-wrapper{-ms-flex-pack:start;justify-content:start}:host(.toggle-justify-end) .toggle-wrapper{-ms-flex-pack:end;justify-content:end}:host(.toggle-alignment-start) .toggle-wrapper{-ms-flex-align:start;align-items:start}:host(.toggle-alignment-center) .toggle-wrapper{-ms-flex-align:center;align-items:center}:host(.toggle-label-placement-start) .toggle-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.toggle-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}:host(.toggle-label-placement-end) .toggle-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.toggle-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}:host(.toggle-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}:host(.toggle-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host(.toggle-label-placement-stacked) .toggle-wrapper{-ms-flex-direction:column;flex-direction:column}:host(.toggle-label-placement-stacked) .label-text-wrapper{-webkit-transform:scale(0.75);transform:scale(0.75);margin-left:0;margin-right:0;margin-bottom:16px;max-width:calc(100% / 0.75)}:host(.toggle-label-placement-stacked.toggle-alignment-start) .label-text-wrapper{-webkit-transform-origin:left top;transform-origin:left top}:host-context([dir=rtl]):host(.toggle-label-placement-stacked.toggle-alignment-start) .label-text-wrapper,:host-context([dir=rtl]).toggle-label-placement-stacked.toggle-alignment-start .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){:host(.toggle-label-placement-stacked.toggle-alignment-start:dir(rtl)) .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}}:host(.toggle-label-placement-stacked.toggle-alignment-center) .label-text-wrapper{-webkit-transform-origin:center top;transform-origin:center top}:host-context([dir=rtl]):host(.toggle-label-placement-stacked.toggle-alignment-center) .label-text-wrapper,:host-context([dir=rtl]).toggle-label-placement-stacked.toggle-alignment-center .label-text-wrapper{-webkit-transform-origin:calc(100% - center) top;transform-origin:calc(100% - center) top}@supports selector(:dir(rtl)){:host(.toggle-label-placement-stacked.toggle-alignment-center:dir(rtl)) .label-text-wrapper{-webkit-transform-origin:calc(100% - center) top;transform-origin:calc(100% - center) top}}.toggle-icon-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;height:100%;-webkit-transition:var(--handle-transition);transition:var(--handle-transition);will-change:transform}.toggle-icon{border-radius:var(--border-radius);display:block;position:relative;width:100%;height:100%;background:var(--track-background);overflow:inherit}:host(.toggle-checked) .toggle-icon{background:var(--track-background-checked)}.toggle-inner{border-radius:var(--handle-border-radius);position:absolute;left:var(--handle-spacing);width:var(--handle-width);height:var(--handle-height);max-height:var(--handle-max-height);-webkit-transition:var(--handle-transition);transition:var(--handle-transition);background:var(--handle-background);-webkit-box-shadow:var(--handle-box-shadow);box-shadow:var(--handle-box-shadow);contain:strict}:host(.toggle-ltr) .toggle-inner{left:var(--handle-spacing)}:host(.toggle-rtl) .toggle-inner{right:var(--handle-spacing)}:host(.toggle-ltr.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(100% - var(--handle-width)), 0, 0);transform:translate3d(calc(100% - var(--handle-width)), 0, 0)}:host(.toggle-rtl.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(-100% + var(--handle-width)), 0, 0);transform:translate3d(calc(-100% + var(--handle-width)), 0, 0)}:host(.toggle-checked) .toggle-inner{background:var(--handle-background-checked)}:host(.toggle-ltr.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0);transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0)}:host(.toggle-rtl.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0);transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0)}:host{--track-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.088);--track-background-checked:var(--ion-color-primary, #3880ff);--border-radius:16px;--handle-background:#ffffff;--handle-background-checked:#ffffff;--handle-border-radius:25.5px;--handle-box-shadow:0 3px 12px rgba(0, 0, 0, 0.16), 0 3px 1px rgba(0, 0, 0, 0.1);--handle-height:calc(32px - (2px * 2));--handle-max-height:calc(100% - var(--handle-spacing) * 2);--handle-width:calc(32px - (2px * 2));--handle-spacing:2px;--handle-transition:transform 300ms, width 120ms ease-in-out 80ms, left 110ms ease-in-out 80ms, right 110ms ease-in-out 80ms}:host(.legacy-toggle){width:51px;height:32px;contain:strict;overflow:hidden}.native-wrapper .toggle-icon{width:51px;height:32px;overflow:hidden}:host(.ion-color.toggle-checked) .toggle-icon{background:var(--ion-color-base)}:host(.toggle-activated) .toggle-switch-icon{opacity:0}.toggle-icon{-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);-webkit-transition:background-color 300ms;transition:background-color 300ms}.toggle-inner{will-change:transform}.toggle-switch-icon{position:absolute;top:50%;width:11px;height:11px;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-transition:opacity 300ms, color 300ms;transition:opacity 300ms, color 300ms}.toggle-switch-icon{position:absolute;color:var(--ion-color-dark)}:host(.toggle-ltr) .toggle-switch-icon{right:6px}:host(.toggle-rtl) .toggle-switch-icon{right:initial;left:6px;}:host(.toggle-checked) .toggle-switch-icon.toggle-switch-icon-checked{color:var(--ion-color-contrast, #fff)}:host(.toggle-checked) .toggle-switch-icon:not(.toggle-switch-icon-checked){opacity:0}.toggle-switch-icon-checked{position:absolute;width:15px;height:15px;-webkit-transform:translateY(-50%) rotate(90deg);transform:translateY(-50%) rotate(90deg)}:host(.toggle-ltr) .toggle-switch-icon-checked{right:initial;left:4px;}:host(.toggle-rtl) .toggle-switch-icon-checked{right:4px}:host(.toggle-activated) .toggle-icon::before,:host(.toggle-checked) .toggle-icon::before{-webkit-transform:scale3d(0, 0, 0);transform:scale3d(0, 0, 0)}:host(.toggle-activated.toggle-checked) .toggle-inner::before{-webkit-transform:scale3d(0, 0, 0);transform:scale3d(0, 0, 0)}:host(.toggle-activated) .toggle-inner{width:calc(var(--handle-width) + 6px)}:host(.toggle-ltr.toggle-activated.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(100% - var(--handle-width) - 6px), 0, 0);transform:translate3d(calc(100% - var(--handle-width) - 6px), 0, 0)}:host(.toggle-rtl.toggle-activated.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(-100% + var(--handle-width) + 6px), 0, 0);transform:translate3d(calc(-100% + var(--handle-width) + 6px), 0, 0)}:host(.toggle-disabled){opacity:0.3}:host(.in-item.legacy-toggle){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:0;padding-inline-end:0;padding-top:6px;padding-bottom:5px}:host(.in-item.legacy-toggle[slot=start]){-webkit-padding-start:0;padding-inline-start:0;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:6px;padding-bottom:5px}";
const IonToggleIosStyle0 = toggleIosCss;
const toggleMdCss = ":host{-webkit-box-sizing:content-box !important;box-sizing:content-box !important;display:inline-block;position:relative;max-width:100%;outline:none;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.in-item:not(.legacy-toggle)){width:100%;height:100%}:host([slot=start]:not(.legacy-toggle)),:host([slot=end]:not(.legacy-toggle)){width:auto}:host(.legacy-toggle){contain:content;-ms-touch-action:none;touch-action:none}:host(.ion-focused) input{border:2px solid #5e9ed6}:host(.toggle-disabled){pointer-events:none}:host(.legacy-toggle) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0;pointer-events:none}@supports (inset-inline-start: 0){:host(.legacy-toggle) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-toggle) label{left:0}:host-context([dir=rtl]):host(.legacy-toggle) label,:host-context([dir=rtl]).legacy-toggle label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-toggle:dir(rtl)) label{left:unset;right:unset;right:0}}}:host(.legacy-toggle) label::-moz-focus-inner{border:0}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.toggle-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;cursor:inherit}.label-text-wrapper{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}:host(.in-item:not(.legacy-toggle)) .label-text-wrapper{margin-top:10px;margin-bottom:10px}:host(.in-item.toggle-label-placement-stacked) .label-text-wrapper{margin-top:10px;margin-bottom:16px}:host(.in-item.toggle-label-placement-stacked) .native-wrapper{margin-bottom:10px}.label-text-wrapper-hidden{display:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host(.toggle-justify-space-between) .toggle-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.toggle-justify-start) .toggle-wrapper{-ms-flex-pack:start;justify-content:start}:host(.toggle-justify-end) .toggle-wrapper{-ms-flex-pack:end;justify-content:end}:host(.toggle-alignment-start) .toggle-wrapper{-ms-flex-align:start;align-items:start}:host(.toggle-alignment-center) .toggle-wrapper{-ms-flex-align:center;align-items:center}:host(.toggle-label-placement-start) .toggle-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.toggle-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}:host(.toggle-label-placement-end) .toggle-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.toggle-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}:host(.toggle-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}:host(.toggle-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host(.toggle-label-placement-stacked) .toggle-wrapper{-ms-flex-direction:column;flex-direction:column}:host(.toggle-label-placement-stacked) .label-text-wrapper{-webkit-transform:scale(0.75);transform:scale(0.75);margin-left:0;margin-right:0;margin-bottom:16px;max-width:calc(100% / 0.75)}:host(.toggle-label-placement-stacked.toggle-alignment-start) .label-text-wrapper{-webkit-transform-origin:left top;transform-origin:left top}:host-context([dir=rtl]):host(.toggle-label-placement-stacked.toggle-alignment-start) .label-text-wrapper,:host-context([dir=rtl]).toggle-label-placement-stacked.toggle-alignment-start .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){:host(.toggle-label-placement-stacked.toggle-alignment-start:dir(rtl)) .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}}:host(.toggle-label-placement-stacked.toggle-alignment-center) .label-text-wrapper{-webkit-transform-origin:center top;transform-origin:center top}:host-context([dir=rtl]):host(.toggle-label-placement-stacked.toggle-alignment-center) .label-text-wrapper,:host-context([dir=rtl]).toggle-label-placement-stacked.toggle-alignment-center .label-text-wrapper{-webkit-transform-origin:calc(100% - center) top;transform-origin:calc(100% - center) top}@supports selector(:dir(rtl)){:host(.toggle-label-placement-stacked.toggle-alignment-center:dir(rtl)) .label-text-wrapper{-webkit-transform-origin:calc(100% - center) top;transform-origin:calc(100% - center) top}}.toggle-icon-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;height:100%;-webkit-transition:var(--handle-transition);transition:var(--handle-transition);will-change:transform}.toggle-icon{border-radius:var(--border-radius);display:block;position:relative;width:100%;height:100%;background:var(--track-background);overflow:inherit}:host(.toggle-checked) .toggle-icon{background:var(--track-background-checked)}.toggle-inner{border-radius:var(--handle-border-radius);position:absolute;left:var(--handle-spacing);width:var(--handle-width);height:var(--handle-height);max-height:var(--handle-max-height);-webkit-transition:var(--handle-transition);transition:var(--handle-transition);background:var(--handle-background);-webkit-box-shadow:var(--handle-box-shadow);box-shadow:var(--handle-box-shadow);contain:strict}:host(.toggle-ltr) .toggle-inner{left:var(--handle-spacing)}:host(.toggle-rtl) .toggle-inner{right:var(--handle-spacing)}:host(.toggle-ltr.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(100% - var(--handle-width)), 0, 0);transform:translate3d(calc(100% - var(--handle-width)), 0, 0)}:host(.toggle-rtl.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(-100% + var(--handle-width)), 0, 0);transform:translate3d(calc(-100% + var(--handle-width)), 0, 0)}:host(.toggle-checked) .toggle-inner{background:var(--handle-background-checked)}:host(.toggle-ltr.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0);transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0)}:host(.toggle-rtl.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0);transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0)}:host{--track-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.39);--track-background-checked:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.5);--border-radius:14px;--handle-background:#ffffff;--handle-background-checked:var(--ion-color-primary, #3880ff);--handle-border-radius:50%;--handle-box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);--handle-width:20px;--handle-height:20px;--handle-max-height:calc(100% + 6px);--handle-spacing:0;--handle-transition:transform 160ms cubic-bezier(0.4, 0, 0.2, 1), background-color 160ms cubic-bezier(0.4, 0, 0.2, 1)}:host(.legacy-toggle){-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:12px;padding-bottom:12px;width:36px;height:14px;contain:strict}.native-wrapper .toggle-icon{width:36px;height:14px}:host(.ion-color.toggle-checked) .toggle-icon{background:rgba(var(--ion-color-base-rgb), 0.5)}:host(.ion-color.toggle-checked) .toggle-inner{background:var(--ion-color-base)}:host(.toggle-checked) .toggle-inner{color:var(--ion-color-contrast, #fff)}.toggle-icon{-webkit-transition:background-color 160ms;transition:background-color 160ms}.toggle-inner{will-change:background-color, transform;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;color:#000}.toggle-inner .toggle-switch-icon{-webkit-padding-start:1px;padding-inline-start:1px;-webkit-padding-end:1px;padding-inline-end:1px;padding-top:1px;padding-bottom:1px;width:100%;height:100%}:host(.toggle-disabled){opacity:0.38}:host(.in-item.legacy-toggle){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:0;padding-inline-end:0;padding-top:12px;padding-bottom:12px;cursor:pointer}:host(.in-item.legacy-toggle[slot=start]){-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:18px;padding-inline-end:18px;padding-top:12px;padding-bottom:12px}";
const IonToggleMdStyle0 = toggleMdCss;
const Toggle = /* @__PURE__ */ proxyCustomElement(class Toggle2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.inputId = `ion-tg-${toggleIds++}`;
    this.lastDrag = 0;
    this.inheritedAttributes = {};
    this.didLoad = false;
    this.hasLoggedDeprecationWarning = false;
    this.setupGesture = async () => {
      const { toggleTrack } = this;
      if (toggleTrack) {
        this.gesture = (await __vitePreload(() => Promise.resolve().then(() => index3), true ? void 0 : void 0, import.meta.url)).createGesture({
          el: toggleTrack,
          gestureName: "toggle",
          gesturePriority: 100,
          threshold: 5,
          passive: false,
          onStart: () => this.onStart(),
          onMove: (ev) => this.onMove(ev),
          onEnd: (ev) => this.onEnd(ev)
        });
        this.disabledChanged();
      }
    };
    this.onClick = (ev) => {
      if (this.disabled) {
        return;
      }
      ev.preventDefault();
      if (this.lastDrag + 300 < Date.now()) {
        this.toggleChecked();
      }
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.getSwitchLabelIcon = (mode, checked2) => {
      if (mode === "md") {
        return checked2 ? checkmarkOutline : removeOutline;
      }
      return checked2 ? removeOutline : ellipseOutline;
    };
    this.activated = false;
    this.color = void 0;
    this.name = this.inputId;
    this.checked = false;
    this.disabled = false;
    this.value = "on";
    this.enableOnOffLabels = config$1.get("toggleOnOffLabels");
    this.labelPlacement = "start";
    this.legacy = void 0;
    this.justify = "space-between";
    this.alignment = "center";
  }
  disabledChanged() {
    this.emitStyle();
    if (this.gesture) {
      this.gesture.enable(!this.disabled);
    }
  }
  toggleChecked() {
    const { checked: checked2, value } = this;
    const isNowChecked = !checked2;
    this.checked = isNowChecked;
    this.ionChange.emit({
      checked: isNowChecked,
      value
    });
  }
  async connectedCallback() {
    this.legacyFormController = createLegacyFormController(this.el);
    if (this.didLoad) {
      this.setupGesture();
    }
  }
  componentDidLoad() {
    this.setupGesture();
    this.didLoad = true;
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
  }
  componentWillLoad() {
    this.emitStyle();
    if (!this.legacyFormController.hasLegacyControl()) {
      this.inheritedAttributes = Object.assign({}, inheritAriaAttributes(this.el));
    }
  }
  emitStyle() {
    if (this.legacyFormController.hasLegacyControl()) {
      this.ionStyle.emit({
        "interactive-disabled": this.disabled,
        // TODO(FW-2990): remove this
        legacy: !!this.legacy
      });
    }
  }
  onStart() {
    this.activated = true;
    this.setFocus();
  }
  onMove(detail) {
    if (shouldToggle(isRTL$1(this.el), this.checked, detail.deltaX, -10)) {
      this.toggleChecked();
      hapticSelection();
    }
  }
  onEnd(ev) {
    this.activated = false;
    this.lastDrag = Date.now();
    ev.event.preventDefault();
    ev.event.stopImmediatePropagation();
  }
  getValue() {
    return this.value || "";
  }
  setFocus() {
    if (this.focusEl) {
      this.focusEl.focus();
    }
  }
  renderOnOffSwitchLabels(mode, checked2) {
    const icon = this.getSwitchLabelIcon(mode, checked2);
    return h$1("ion-icon", { class: {
      "toggle-switch-icon": true,
      "toggle-switch-icon-checked": checked2
    }, icon, "aria-hidden": "true" });
  }
  renderToggleControl() {
    const mode = getIonMode$2(this);
    const { enableOnOffLabels, checked: checked2 } = this;
    return h$1("div", { class: "toggle-icon", part: "track", ref: (el2) => this.toggleTrack = el2 }, enableOnOffLabels && mode === "ios" && [this.renderOnOffSwitchLabels(mode, true), this.renderOnOffSwitchLabels(mode, false)], h$1("div", { class: "toggle-icon-wrapper" }, h$1("div", { class: "toggle-inner", part: "handle" }, enableOnOffLabels && mode === "md" && this.renderOnOffSwitchLabels(mode, checked2))));
  }
  get hasLabel() {
    return this.el.textContent !== "";
  }
  render() {
    const { legacyFormController } = this;
    return legacyFormController.hasLegacyControl() ? this.renderLegacyToggle() : this.renderToggle();
  }
  renderToggle() {
    const { activated, color, checked: checked2, disabled, el: el2, justify, labelPlacement, inputId, name, alignment } = this;
    const mode = getIonMode$2(this);
    const value = this.getValue();
    const rtl = isRTL$1(el2) ? "rtl" : "ltr";
    renderHiddenInput(true, el2, name, checked2 ? value : "", disabled);
    return h$1(Host, { onClick: this.onClick, class: createColorClasses$2(color, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "toggle-activated": activated,
      "toggle-checked": checked2,
      "toggle-disabled": disabled,
      [`toggle-justify-${justify}`]: true,
      [`toggle-alignment-${alignment}`]: true,
      [`toggle-label-placement-${labelPlacement}`]: true,
      [`toggle-${rtl}`]: true
    }) }, h$1("label", { class: "toggle-wrapper" }, h$1("input", Object.assign({ type: "checkbox", role: "switch", "aria-checked": `${checked2}`, checked: checked2, disabled, id: inputId, onFocus: () => this.onFocus(), onBlur: () => this.onBlur(), ref: (focusEl) => this.focusEl = focusEl }, this.inheritedAttributes)), h$1("div", { class: {
      "label-text-wrapper": true,
      "label-text-wrapper-hidden": !this.hasLabel
    }, part: "label" }, h$1("slot", null)), h$1("div", { class: "native-wrapper" }, this.renderToggleControl())));
  }
  renderLegacyToggle() {
    if (!this.hasLoggedDeprecationWarning) {
      printIonWarning(`ion-toggle now requires providing a label with either the default slot or the "aria-label" attribute. To migrate, remove any usage of "ion-label" and pass the label text to either the component or the "aria-label" attribute.

Example: <ion-toggle>Email</ion-toggle>
Example with aria-label: <ion-toggle aria-label="Email"></ion-toggle>

Developers can use the "legacy" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);
      if (this.legacy) {
        printIonWarning(`ion-toggle is being used with the "legacy" property enabled which will forcibly enable the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.

Developers can dismiss this warning by removing their usage of the "legacy" property and using the new toggle syntax.`, this.el);
      }
      this.hasLoggedDeprecationWarning = true;
    }
    const { activated, color, checked: checked2, disabled, el: el2, inputId, name } = this;
    const mode = getIonMode$2(this);
    const { label, labelId, labelText } = getAriaLabel(el2, inputId);
    const value = this.getValue();
    const rtl = isRTL$1(el2) ? "rtl" : "ltr";
    renderHiddenInput(true, el2, name, checked2 ? value : "", disabled);
    return h$1(Host, { onClick: this.onClick, "aria-labelledby": label ? labelId : null, "aria-checked": `${checked2}`, "aria-hidden": disabled ? "true" : null, role: "switch", class: createColorClasses$2(color, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "toggle-activated": activated,
      "toggle-checked": checked2,
      "toggle-disabled": disabled,
      "legacy-toggle": true,
      interactive: true,
      [`toggle-${rtl}`]: true
    }) }, this.renderToggleControl(), h$1("label", { htmlFor: inputId }, labelText), h$1("input", { type: "checkbox", role: "switch", "aria-checked": `${checked2}`, disabled, id: inputId, onFocus: () => this.onFocus(), onBlur: () => this.onBlur(), ref: (focusEl) => this.focusEl = focusEl }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "disabled": ["disabledChanged"]
    };
  }
  static get style() {
    return {
      ios: IonToggleIosStyle0,
      md: IonToggleMdStyle0
    };
  }
}, [33, "ion-toggle", {
  "color": [513],
  "name": [1],
  "checked": [1028],
  "disabled": [4],
  "value": [1],
  "enableOnOffLabels": [4, "enable-on-off-labels"],
  "labelPlacement": [1, "label-placement"],
  "legacy": [4],
  "justify": [1],
  "alignment": [1],
  "activated": [32]
}, void 0, {
  "disabled": ["disabledChanged"]
}]);
const shouldToggle = (rtl, checked2, deltaX, margin) => {
  if (checked2) {
    return !rtl && margin > deltaX || rtl && -margin < deltaX;
  } else {
    return !rtl && -margin < deltaX || rtl && margin > deltaX;
  }
};
let toggleIds = 0;
function defineCustomElement$1$7() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-toggle", "ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-toggle":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Toggle);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$A();
        }
        break;
    }
  });
}
const defineCustomElement$a = defineCustomElement$1$7;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const toolbarIosCss = ":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;width:100%;padding-right:var(--ion-safe-area-right);padding-left:var(--ion-safe-area-left);color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-color-step-50, #f7f7f7));--color:var(--ion-toolbar-color, var(--ion-text-color, #000));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--padding-top:3px;--padding-bottom:3px;--padding-start:4px;--padding-end:4px;--min-height:44px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:4;order:4;min-width:0}:host(.toolbar-segment) .toolbar-content{display:-ms-inline-flexbox;display:inline-flex}:host(.toolbar-searchbar) .toolbar-container{padding-top:0;padding-bottom:0}:host(.toolbar-searchbar) ::slotted(*){-ms-flex-item-align:start;align-self:start}:host(.toolbar-searchbar) ::slotted(ion-chip){margin-top:3px}::slotted(ion-buttons){min-height:38px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:3;order:3}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}:host(.toolbar-title-large) .toolbar-container{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:start;align-items:flex-start}:host(.toolbar-title-large) .toolbar-content ion-title{-ms-flex:1;flex:1;-ms-flex-order:8;order:8;min-width:100%}";
const IonToolbarIosStyle0 = toolbarIosCss;
const toolbarMdCss = ":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;width:100%;padding-right:var(--ion-safe-area-right);padding-left:var(--ion-safe-area-left);color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-background-color, #fff));--color:var(--ion-toolbar-color, var(--ion-text-color, #424242));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, #c1c4cd)));--padding-top:0;--padding-bottom:0;--padding-start:0;--padding-end:0;--min-height:56px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:3;order:3;min-width:0;max-width:100%}::slotted(.buttons-first-slot){-webkit-margin-start:4px;margin-inline-start:4px}::slotted(.buttons-last-slot){-webkit-margin-end:4px;margin-inline-end:4px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:4;order:4}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}";
const IonToolbarMdStyle0 = toolbarMdCss;
const Toolbar = /* @__PURE__ */ proxyCustomElement(class Toolbar2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.childrenStyles = /* @__PURE__ */ new Map();
    this.color = void 0;
  }
  componentWillLoad() {
    const buttons = Array.from(this.el.querySelectorAll("ion-buttons"));
    const firstButtons = buttons.find((button) => {
      return button.slot === "start";
    });
    if (firstButtons) {
      firstButtons.classList.add("buttons-first-slot");
    }
    const buttonsReversed = buttons.reverse();
    const lastButtons = buttonsReversed.find((button) => button.slot === "end") || buttonsReversed.find((button) => button.slot === "primary") || buttonsReversed.find((button) => button.slot === "secondary");
    if (lastButtons) {
      lastButtons.classList.add("buttons-last-slot");
    }
  }
  childrenStyle(ev) {
    ev.stopPropagation();
    const tagName = ev.target.tagName;
    const updatedStyles = ev.detail;
    const newStyles = {};
    const childStyles = this.childrenStyles.get(tagName) || {};
    let hasStyleChange = false;
    Object.keys(updatedStyles).forEach((key) => {
      const childKey = `toolbar-${key}`;
      const newValue = updatedStyles[key];
      if (newValue !== childStyles[childKey]) {
        hasStyleChange = true;
      }
      if (newValue) {
        newStyles[childKey] = true;
      }
    });
    if (hasStyleChange) {
      this.childrenStyles.set(tagName, newStyles);
      forceUpdate(this);
    }
  }
  render() {
    const mode = getIonMode$2(this);
    const childStyles = {};
    this.childrenStyles.forEach((value) => {
      Object.assign(childStyles, value);
    });
    return h$1(Host, { key: "afac0f08f3981483c072984ce047df5dc9cc1e99", class: Object.assign(Object.assign({}, childStyles), createColorClasses$2(this.color, {
      [mode]: true,
      "in-toolbar": hostContext("ion-toolbar", this.el)
    })) }, h$1("div", { key: "30d4f1d0ec01cc646398301b5f7d469391eb35d2", class: "toolbar-background" }), h$1("div", { key: "175d1f283e670b57a9bf8fd2a8c5e7d0da749aa8", class: "toolbar-container" }, h$1("slot", { key: "4853b18092737b32b5995457536fa5a7fc2816ef", name: "start" }), h$1("slot", { key: "6eb4921200aad02d7977d134edad6cff2aad91ad", name: "secondary" }), h$1("div", { key: "024e0339c74c4b9a886d49e96723243719643dc2", class: "toolbar-content" }, h$1("slot", { key: "b6452c84692fedd6efe33ac67907d01253b76f8f" })), h$1("slot", { key: "636e56eeaa318ce45a9c3854a30b8eb2819a33e0", name: "primary" }), h$1("slot", { key: "a45c19b93dca3719d75bd4d99acc49de87137a7d", name: "end" })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonToolbarIosStyle0,
      md: IonToolbarMdStyle0
    };
  }
}, [33, "ion-toolbar", {
  "color": [513]
}, [[0, "ionStyle", "childrenStyle"]]]);
function defineCustomElement$1$6() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-toolbar"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-toolbar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Toolbar);
        }
        break;
    }
  });
}
const defineCustomElement$9 = defineCustomElement$1$6;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const IonButton$1 = Button;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const IonItem$1 = Item$1;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$8 = defineCustomElement$d;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const KEYBOARD_DID_OPEN = "ionKeyboardDidShow";
const KEYBOARD_DID_CLOSE = "ionKeyboardDidHide";
const KEYBOARD_THRESHOLD = 150;
let previousVisualViewport = {};
let currentVisualViewport = {};
let keyboardOpen = false;
const resetKeyboardAssist = () => {
  previousVisualViewport = {};
  currentVisualViewport = {};
  keyboardOpen = false;
};
const startKeyboardAssist = (win2) => {
  const nativeEngine = Keyboard.getEngine();
  if (nativeEngine) {
    startNativeListeners(win2);
  } else {
    if (!win2.visualViewport) {
      return;
    }
    currentVisualViewport = copyVisualViewport(win2.visualViewport);
    win2.visualViewport.onresize = () => {
      trackViewportChanges(win2);
      if (keyboardDidOpen() || keyboardDidResize(win2)) {
        setKeyboardOpen(win2);
      } else if (keyboardDidClose(win2)) {
        setKeyboardClose(win2);
      }
    };
  }
};
const startNativeListeners = (win2) => {
  win2.addEventListener("keyboardDidShow", (ev) => setKeyboardOpen(win2, ev));
  win2.addEventListener("keyboardDidHide", () => setKeyboardClose(win2));
};
const setKeyboardOpen = (win2, ev) => {
  fireKeyboardOpenEvent(win2, ev);
  keyboardOpen = true;
};
const setKeyboardClose = (win2) => {
  fireKeyboardCloseEvent(win2);
  keyboardOpen = false;
};
const keyboardDidOpen = () => {
  const scaledHeightDifference = (previousVisualViewport.height - currentVisualViewport.height) * currentVisualViewport.scale;
  return !keyboardOpen && previousVisualViewport.width === currentVisualViewport.width && scaledHeightDifference > KEYBOARD_THRESHOLD;
};
const keyboardDidResize = (win2) => {
  return keyboardOpen && !keyboardDidClose(win2);
};
const keyboardDidClose = (win2) => {
  return keyboardOpen && currentVisualViewport.height === win2.innerHeight;
};
const fireKeyboardOpenEvent = (win2, nativeEv) => {
  const keyboardHeight = nativeEv ? nativeEv.keyboardHeight : win2.innerHeight - currentVisualViewport.height;
  const ev = new CustomEvent(KEYBOARD_DID_OPEN, {
    detail: { keyboardHeight }
  });
  win2.dispatchEvent(ev);
};
const fireKeyboardCloseEvent = (win2) => {
  const ev = new CustomEvent(KEYBOARD_DID_CLOSE);
  win2.dispatchEvent(ev);
};
const trackViewportChanges = (win2) => {
  previousVisualViewport = Object.assign({}, currentVisualViewport);
  currentVisualViewport = copyVisualViewport(win2.visualViewport);
};
const copyVisualViewport = (visualViewport) => {
  return {
    width: Math.round(visualViewport.width),
    height: Math.round(visualViewport.height),
    offsetTop: visualViewport.offsetTop,
    offsetLeft: visualViewport.offsetLeft,
    pageTop: visualViewport.pageTop,
    pageLeft: visualViewport.pageLeft,
    scale: visualViewport.scale
  };
};
const keyboard2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KEYBOARD_DID_CLOSE,
  KEYBOARD_DID_OPEN,
  copyVisualViewport,
  keyboardDidClose,
  keyboardDidOpen,
  keyboardDidResize,
  resetKeyboardAssist,
  setKeyboardClose,
  setKeyboardOpen,
  startKeyboardAssist,
  trackViewportChanges
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
var Style;
(function(Style2) {
  Style2["Dark"] = "DARK";
  Style2["Light"] = "LIGHT";
  Style2["Default"] = "DEFAULT";
})(Style || (Style = {}));
const StatusBar = {
  getEngine() {
    const capacitor = getCapacitor();
    if (capacitor === null || capacitor === void 0 ? void 0 : capacitor.isPluginAvailable("StatusBar")) {
      return capacitor.Plugins.StatusBar;
    }
    return void 0;
  },
  // TODO FW-4696 Remove supportDefaultStatusBarStyle in Ionic v8
  supportsDefaultStatusBarStyle() {
    const capacitor = getCapacitor();
    return !!(capacitor === null || capacitor === void 0 ? void 0 : capacitor.PluginHeaders);
  },
  setStyle(options) {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    engine.setStyle(options);
  },
  getStyle: async function() {
    const engine = this.getEngine();
    if (!engine) {
      return Style.Default;
    }
    const { style } = await engine.getInfo();
    return style;
  }
};
const getBackdropValueForSheet = (x2, backdropBreakpoint) => {
  if (backdropBreakpoint === 1) {
    return 0;
  }
  const slope = 1 / (1 - backdropBreakpoint);
  const b2 = -(backdropBreakpoint * slope);
  return x2 * slope + b2;
};
const setCardStatusBarDark = () => {
  if (!win$1 || win$1.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {
    return;
  }
  StatusBar.setStyle({ style: Style.Dark });
};
const setCardStatusBarDefault = (defaultStyle = Style.Default) => {
  if (!win$1 || win$1.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {
    return;
  }
  StatusBar.setStyle({ style: defaultStyle });
};
const handleCanDismiss = async (el2, animation2) => {
  if (typeof el2.canDismiss !== "function") {
    return;
  }
  const shouldDismiss = await el2.canDismiss(void 0, GESTURE);
  if (!shouldDismiss) {
    return;
  }
  if (animation2.isRunning()) {
    animation2.onFinish(() => {
      el2.dismiss(void 0, "handler");
    }, { oneTimeCallback: true });
  } else {
    el2.dismiss(void 0, "handler");
  }
};
const calculateSpringStep = (t2) => {
  return 255275e-8 * 2.71828 ** (-14.9619 * t2) - 1.00255 * 2.71828 ** (-0.0380968 * t2) + 1;
};
const SwipeToCloseDefaults = {
  MIN_PRESENTING_SCALE: 0.93
};
const createSwipeToCloseGesture = (el2, animation2, statusBarStyle, onDismiss) => {
  const DISMISS_THRESHOLD = 0.5;
  const height = el2.offsetHeight;
  let isOpen = false;
  let canDismissBlocksGesture = false;
  let contentEl = null;
  let scrollEl = null;
  const canDismissMaxStep = 0.2;
  let initialScrollY = true;
  let lastStep = 0;
  const getScrollY = () => {
    if (contentEl && isIonContent(contentEl)) {
      return contentEl.scrollY;
    } else {
      return true;
    }
  };
  const canStart = (detail) => {
    const target = detail.event.target;
    if (target === null || !target.closest) {
      return true;
    }
    contentEl = findClosestIonContent(target);
    if (contentEl) {
      if (isIonContent(contentEl)) {
        const root = getElementRoot(contentEl);
        scrollEl = root.querySelector(".inner-scroll");
      } else {
        scrollEl = contentEl;
      }
      const hasRefresherInContent = !!contentEl.querySelector("ion-refresher");
      return !hasRefresherInContent && scrollEl.scrollTop === 0;
    }
    const footer = target.closest("ion-footer");
    if (footer === null) {
      return true;
    }
    return false;
  };
  const onStart = (detail) => {
    const { deltaY } = detail;
    initialScrollY = getScrollY();
    canDismissBlocksGesture = el2.canDismiss !== void 0 && el2.canDismiss !== true;
    if (deltaY > 0 && contentEl) {
      disableContentScrollY(contentEl);
    }
    animation2.progressStart(true, isOpen ? 1 : 0);
  };
  const onMove = (detail) => {
    const { deltaY } = detail;
    if (deltaY > 0 && contentEl) {
      disableContentScrollY(contentEl);
    }
    const step = detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    const clampedStep = clamp(1e-4, processedStep, maxStep);
    animation2.progressStep(clampedStep);
    if (clampedStep >= DISMISS_THRESHOLD && lastStep < DISMISS_THRESHOLD) {
      setCardStatusBarDefault(statusBarStyle);
    } else if (clampedStep < DISMISS_THRESHOLD && lastStep >= DISMISS_THRESHOLD) {
      setCardStatusBarDark();
    }
    lastStep = clampedStep;
  };
  const onEnd = (detail) => {
    const velocity = detail.velocityY;
    const step = detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    const clampedStep = clamp(1e-4, processedStep, maxStep);
    const threshold = (detail.deltaY + velocity * 1e3) / height;
    const shouldComplete = !isAttemptingDismissWithCanDismiss && threshold >= DISMISS_THRESHOLD;
    let newStepValue = shouldComplete ? -1e-3 : 1e-3;
    if (!shouldComplete) {
      animation2.easing("cubic-bezier(1, 0, 0.68, 0.28)");
      newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], clampedStep)[0];
    } else {
      animation2.easing("cubic-bezier(0.32, 0.72, 0, 1)");
      newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], clampedStep)[0];
    }
    const duration = shouldComplete ? computeDuration(step * height, velocity) : computeDuration((1 - clampedStep) * height, velocity);
    isOpen = shouldComplete;
    gesture.enable(false);
    if (contentEl) {
      resetContentScrollY(contentEl, initialScrollY);
    }
    animation2.onFinish(() => {
      if (!shouldComplete) {
        gesture.enable(true);
      }
    }).progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);
    if (isAttemptingDismissWithCanDismiss && clampedStep > maxStep / 4) {
      handleCanDismiss(el2, animation2);
    } else if (shouldComplete) {
      onDismiss();
    }
  };
  const gesture = createGesture({
    el: el2,
    gestureName: "modalSwipeToClose",
    gesturePriority: OVERLAY_GESTURE_PRIORITY,
    direction: "y",
    threshold: 10,
    canStart,
    onStart,
    onMove,
    onEnd
  });
  return gesture;
};
const computeDuration = (remaining, velocity) => {
  return clamp(400, remaining / Math.abs(velocity * 1.1), 500);
};
const createSheetEnterAnimation = (opts) => {
  const { currentBreakpoint, backdropBreakpoint } = opts;
  const shouldShowBackdrop = backdropBreakpoint === void 0 || backdropBreakpoint < currentBreakpoint;
  const initialBackdrop = shouldShowBackdrop ? `calc(var(--backdrop-opacity) * ${currentBreakpoint})` : "0";
  const backdropAnimation = createAnimation("backdropAnimation").fromTo("opacity", 0, initialBackdrop);
  if (shouldShowBackdrop) {
    backdropAnimation.beforeStyles({
      "pointer-events": "none"
    }).afterClearStyles(["pointer-events"]);
  }
  const wrapperAnimation = createAnimation("wrapperAnimation").keyframes([
    { offset: 0, opacity: 1, transform: "translateY(100%)" },
    { offset: 1, opacity: 1, transform: `translateY(${100 - currentBreakpoint * 100}%)` }
  ]);
  return { wrapperAnimation, backdropAnimation };
};
const createSheetLeaveAnimation = (opts) => {
  const { currentBreakpoint, backdropBreakpoint } = opts;
  const backdropValue = `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint)})`;
  const defaultBackdrop = [
    { offset: 0, opacity: backdropValue },
    { offset: 1, opacity: 0 }
  ];
  const customBackdrop = [
    { offset: 0, opacity: backdropValue },
    { offset: backdropBreakpoint, opacity: 0 },
    { offset: 1, opacity: 0 }
  ];
  const backdropAnimation = createAnimation("backdropAnimation").keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);
  const wrapperAnimation = createAnimation("wrapperAnimation").keyframes([
    { offset: 0, opacity: 1, transform: `translateY(${100 - currentBreakpoint * 100}%)` },
    { offset: 1, opacity: 1, transform: `translateY(100%)` }
  ]);
  return { wrapperAnimation, backdropAnimation };
};
const createEnterAnimation$1 = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  const wrapperAnimation = createAnimation().fromTo("transform", "translateY(100vh)", "translateY(0vh)");
  return { backdropAnimation, wrapperAnimation };
};
const iosEnterAnimation = (baseEl, opts) => {
  const { presentingEl, currentBreakpoint } = opts;
  const root = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetEnterAnimation(opts) : createEnterAnimation$1();
  backdropAnimation.addElement(root.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root.querySelectorAll(".modal-wrapper, .modal-shadow")).beforeStyles({ opacity: 1 });
  const baseAnimation = createAnimation("entering-base").addElement(baseEl).easing("cubic-bezier(0.32,0.72,0,1)").duration(500).addAnimation(wrapperAnimation);
  if (presentingEl) {
    const isMobile2 = window.innerWidth < 768;
    const hasCardModal = presentingEl.tagName === "ION-MODAL" && presentingEl.presentingElement !== void 0;
    const presentingElRoot = getElementRoot(presentingEl);
    const presentingAnimation = createAnimation().beforeStyles({
      transform: "translateY(0)",
      "transform-origin": "top center",
      overflow: "hidden"
    });
    const bodyEl = document.body;
    if (isMobile2) {
      const transformOffset = !CSS.supports("width", "max(0px, 1px)") ? "30px" : "max(30px, var(--ion-safe-area-top))";
      const modalTransform = hasCardModal ? "-10px" : transformOffset;
      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;
      presentingAnimation.afterStyles({
        transform: finalTransform
      }).beforeAddWrite(() => bodyEl.style.setProperty("background-color", "black")).addElement(presentingEl).keyframes([
        { offset: 0, filter: "contrast(1)", transform: "translateY(0px) scale(1)", borderRadius: "0px" },
        { offset: 1, filter: "contrast(0.85)", transform: finalTransform, borderRadius: "10px 10px 0 0" }
      ]);
      baseAnimation.addAnimation(presentingAnimation);
    } else {
      baseAnimation.addAnimation(backdropAnimation);
      if (!hasCardModal) {
        wrapperAnimation.fromTo("opacity", "0", "1");
      } else {
        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
        const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;
        presentingAnimation.afterStyles({
          transform: finalTransform
        }).addElement(presentingElRoot.querySelector(".modal-wrapper")).keyframes([
          { offset: 0, filter: "contrast(1)", transform: "translateY(0) scale(1)" },
          { offset: 1, filter: "contrast(0.85)", transform: finalTransform }
        ]);
        const shadowAnimation = createAnimation().afterStyles({
          transform: finalTransform
        }).addElement(presentingElRoot.querySelector(".modal-shadow")).keyframes([
          { offset: 0, opacity: "1", transform: "translateY(0) scale(1)" },
          { offset: 1, opacity: "0", transform: finalTransform }
        ]);
        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation.addAnimation(backdropAnimation);
  }
  return baseAnimation;
};
const createLeaveAnimation$1 = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", "var(--backdrop-opacity)", 0);
  const wrapperAnimation = createAnimation().fromTo("transform", "translateY(0vh)", "translateY(100vh)");
  return { backdropAnimation, wrapperAnimation };
};
const iosLeaveAnimation = (baseEl, opts, duration = 500) => {
  const { presentingEl, currentBreakpoint } = opts;
  const root = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetLeaveAnimation(opts) : createLeaveAnimation$1();
  backdropAnimation.addElement(root.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root.querySelectorAll(".modal-wrapper, .modal-shadow")).beforeStyles({ opacity: 1 });
  const baseAnimation = createAnimation("leaving-base").addElement(baseEl).easing("cubic-bezier(0.32,0.72,0,1)").duration(duration).addAnimation(wrapperAnimation);
  if (presentingEl) {
    const isMobile2 = window.innerWidth < 768;
    const hasCardModal = presentingEl.tagName === "ION-MODAL" && presentingEl.presentingElement !== void 0;
    const presentingElRoot = getElementRoot(presentingEl);
    const presentingAnimation = createAnimation().beforeClearStyles(["transform"]).afterClearStyles(["transform"]).onFinish((currentStep) => {
      if (currentStep !== 1) {
        return;
      }
      presentingEl.style.setProperty("overflow", "");
      const numModals = Array.from(bodyEl.querySelectorAll("ion-modal:not(.overlay-hidden)")).filter((m2) => m2.presentingElement !== void 0).length;
      if (numModals <= 1) {
        bodyEl.style.setProperty("background-color", "");
      }
    });
    const bodyEl = document.body;
    if (isMobile2) {
      const transformOffset = !CSS.supports("width", "max(0px, 1px)") ? "30px" : "max(30px, var(--ion-safe-area-top))";
      const modalTransform = hasCardModal ? "-10px" : transformOffset;
      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;
      presentingAnimation.addElement(presentingEl).keyframes([
        { offset: 0, filter: "contrast(0.85)", transform: finalTransform, borderRadius: "10px 10px 0 0" },
        { offset: 1, filter: "contrast(1)", transform: "translateY(0px) scale(1)", borderRadius: "0px" }
      ]);
      baseAnimation.addAnimation(presentingAnimation);
    } else {
      baseAnimation.addAnimation(backdropAnimation);
      if (!hasCardModal) {
        wrapperAnimation.fromTo("opacity", "1", "0");
      } else {
        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
        const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;
        presentingAnimation.addElement(presentingElRoot.querySelector(".modal-wrapper")).afterStyles({
          transform: "translate3d(0, 0, 0)"
        }).keyframes([
          { offset: 0, filter: "contrast(0.85)", transform: finalTransform },
          { offset: 1, filter: "contrast(1)", transform: "translateY(0) scale(1)" }
        ]);
        const shadowAnimation = createAnimation().addElement(presentingElRoot.querySelector(".modal-shadow")).afterStyles({
          transform: "translateY(0) scale(1)"
        }).keyframes([
          { offset: 0, opacity: "0", transform: finalTransform },
          { offset: 1, opacity: "1", transform: "translateY(0) scale(1)" }
        ]);
        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation.addAnimation(backdropAnimation);
  }
  return baseAnimation;
};
const createEnterAnimation = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  const wrapperAnimation = createAnimation().keyframes([
    { offset: 0, opacity: 0.01, transform: "translateY(40px)" },
    { offset: 1, opacity: 1, transform: `translateY(0px)` }
  ]);
  return { backdropAnimation, wrapperAnimation };
};
const mdEnterAnimation = (baseEl, opts) => {
  const { currentBreakpoint } = opts;
  const root = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetEnterAnimation(opts) : createEnterAnimation();
  backdropAnimation.addElement(root.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root.querySelector(".modal-wrapper"));
  return createAnimation().addElement(baseEl).easing("cubic-bezier(0.36,0.66,0.04,1)").duration(280).addAnimation([backdropAnimation, wrapperAnimation]);
};
const createLeaveAnimation = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", "var(--backdrop-opacity)", 0);
  const wrapperAnimation = createAnimation().keyframes([
    { offset: 0, opacity: 0.99, transform: `translateY(0px)` },
    { offset: 1, opacity: 0, transform: "translateY(40px)" }
  ]);
  return { backdropAnimation, wrapperAnimation };
};
const mdLeaveAnimation = (baseEl, opts) => {
  const { currentBreakpoint } = opts;
  const root = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetLeaveAnimation(opts) : createLeaveAnimation();
  backdropAnimation.addElement(root.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root.querySelector(".modal-wrapper"));
  return createAnimation().easing("cubic-bezier(0.47,0,0.745,0.715)").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const createSheetGesture = (baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation2, breakpoints = [], getCurrentBreakpoint, onDismiss, onBreakpointChange) => {
  const defaultBackdrop = [
    { offset: 0, opacity: "var(--backdrop-opacity)" },
    { offset: 1, opacity: 0.01 }
  ];
  const customBackdrop = [
    { offset: 0, opacity: "var(--backdrop-opacity)" },
    { offset: 1 - backdropBreakpoint, opacity: 0 },
    { offset: 1, opacity: 0 }
  ];
  const SheetDefaults = {
    WRAPPER_KEYFRAMES: [
      { offset: 0, transform: "translateY(0%)" },
      { offset: 1, transform: "translateY(100%)" }
    ],
    BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop
  };
  const contentEl = baseEl.querySelector("ion-content");
  const height = wrapperEl.clientHeight;
  let currentBreakpoint = initialBreakpoint;
  let offset = 0;
  let canDismissBlocksGesture = false;
  const canDismissMaxStep = 0.95;
  const wrapperAnimation = animation2.childAnimations.find((ani) => ani.id === "wrapperAnimation");
  const backdropAnimation = animation2.childAnimations.find((ani) => ani.id === "backdropAnimation");
  const maxBreakpoint = breakpoints[breakpoints.length - 1];
  const minBreakpoint = breakpoints[0];
  const enableBackdrop = () => {
    baseEl.style.setProperty("pointer-events", "auto");
    backdropEl.style.setProperty("pointer-events", "auto");
    baseEl.classList.remove("ion-disable-focus-trap");
  };
  const disableBackdrop = () => {
    baseEl.style.setProperty("pointer-events", "none");
    backdropEl.style.setProperty("pointer-events", "none");
    baseEl.classList.add("ion-disable-focus-trap");
  };
  if (wrapperAnimation && backdropAnimation) {
    wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);
    backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);
    animation2.progressStart(true, 1 - currentBreakpoint);
    const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;
    if (shouldEnableBackdrop) {
      enableBackdrop();
    } else {
      disableBackdrop();
    }
  }
  if (contentEl && currentBreakpoint !== maxBreakpoint) {
    contentEl.scrollY = false;
  }
  const canStart = (detail) => {
    const content = detail.event.target.closest("ion-content");
    currentBreakpoint = getCurrentBreakpoint();
    if (currentBreakpoint === 1 && content) {
      return false;
    }
    return true;
  };
  const onStart = () => {
    canDismissBlocksGesture = baseEl.canDismiss !== void 0 && baseEl.canDismiss !== true && minBreakpoint === 0;
    if (contentEl) {
      contentEl.scrollY = false;
    }
    raf(() => {
      baseEl.focus();
    });
    animation2.progressStart(true, 1 - currentBreakpoint);
  };
  const onMove = (detail) => {
    const initialStep = 1 - currentBreakpoint;
    const secondToLastBreakpoint = breakpoints.length > 1 ? 1 - breakpoints[1] : void 0;
    const step = initialStep + detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = secondToLastBreakpoint !== void 0 && step >= secondToLastBreakpoint && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss && secondToLastBreakpoint !== void 0 ? secondToLastBreakpoint + calculateSpringStep((step - secondToLastBreakpoint) / (maxStep - secondToLastBreakpoint)) : step;
    offset = clamp(1e-4, processedStep, maxStep);
    animation2.progressStep(offset);
  };
  const onEnd = (detail) => {
    const velocity = detail.velocityY;
    const threshold = (detail.deltaY + velocity * 350) / height;
    const diff = currentBreakpoint - threshold;
    const closest = breakpoints.reduce((a2, b2) => {
      return Math.abs(b2 - diff) < Math.abs(a2 - diff) ? b2 : a2;
    });
    moveSheetToBreakpoint({
      breakpoint: closest,
      breakpointOffset: offset,
      canDismiss: canDismissBlocksGesture,
      /**
       * The swipe is user-driven, so we should
       * always animate when the gesture ends.
       */
      animated: true
    });
  };
  const moveSheetToBreakpoint = (options) => {
    const { breakpoint, canDismiss, breakpointOffset, animated } = options;
    const shouldPreventDismiss = canDismiss && breakpoint === 0;
    const snapToBreakpoint = shouldPreventDismiss ? currentBreakpoint : breakpoint;
    const shouldRemainOpen = snapToBreakpoint !== 0;
    currentBreakpoint = 0;
    if (wrapperAnimation && backdropAnimation) {
      wrapperAnimation.keyframes([
        { offset: 0, transform: `translateY(${breakpointOffset * 100}%)` },
        { offset: 1, transform: `translateY(${(1 - snapToBreakpoint) * 100}%)` }
      ]);
      backdropAnimation.keyframes([
        {
          offset: 0,
          opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(1 - breakpointOffset, backdropBreakpoint)})`
        },
        {
          offset: 1,
          opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(snapToBreakpoint, backdropBreakpoint)})`
        }
      ]);
      animation2.progressStep(0);
    }
    gesture.enable(false);
    if (shouldPreventDismiss) {
      handleCanDismiss(baseEl, animation2);
    } else if (!shouldRemainOpen) {
      onDismiss();
    }
    return new Promise((resolve2) => {
      animation2.onFinish(() => {
        if (shouldRemainOpen) {
          if (wrapperAnimation && backdropAnimation) {
            raf(() => {
              wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);
              backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);
              animation2.progressStart(true, 1 - snapToBreakpoint);
              currentBreakpoint = snapToBreakpoint;
              onBreakpointChange(currentBreakpoint);
              if (contentEl && currentBreakpoint === breakpoints[breakpoints.length - 1]) {
                contentEl.scrollY = true;
              }
              const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;
              if (shouldEnableBackdrop) {
                enableBackdrop();
              } else {
                disableBackdrop();
              }
              gesture.enable(true);
              resolve2();
            });
          } else {
            gesture.enable(true);
            resolve2();
          }
        } else {
          resolve2();
        }
      }, { oneTimeCallback: true }).progressEnd(1, 0, animated ? 500 : 0);
    });
  };
  const gesture = createGesture({
    el: wrapperEl,
    gestureName: "modalSheet",
    gesturePriority: 40,
    direction: "y",
    threshold: 10,
    canStart,
    onStart,
    onMove,
    onEnd
  });
  return {
    gesture,
    moveSheetToBreakpoint
  };
};
const modalIosCss = ':host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, #c0c0be);cursor:pointer;z-index:11}.modal-handle::before{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:""}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}:host(.modal-card),:host(.modal-sheet){--border-radius:10px}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:10px}}.modal-wrapper{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - 40px)}}:host(.modal-card) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-card) .modal-wrapper,:host-context([dir=rtl]).modal-card .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}@supports selector(:dir(rtl)){:host(.modal-card:dir(rtl)) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}}:host(.modal-card){--backdrop-opacity:0;--width:100%;-ms-flex-align:end;align-items:flex-end}:host(.modal-card) .modal-shadow{display:none}:host(.modal-card) ion-backdrop{pointer-events:none}}@media screen and (min-width: 768px){:host(.modal-card){--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px;--backdrop-opacity:0;--box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1);-webkit-transition:all 0.5s ease-in-out;transition:all 0.5s ease-in-out}:host(.modal-card) .modal-wrapper{-webkit-box-shadow:none;box-shadow:none}:host(.modal-card) .modal-shadow{-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}}:host(.modal-sheet) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-sheet) .modal-wrapper,:host-context([dir=rtl]).modal-sheet .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}@supports selector(:dir(rtl)){:host(.modal-sheet:dir(rtl)) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}}';
const IonModalIosStyle0 = modalIosCss;
const modalMdCss = ':host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, #c0c0be);cursor:pointer;z-index:11}.modal-handle::before{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:""}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:2px;--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper{-webkit-transform:translate3d(0,  40px,  0);transform:translate3d(0,  40px,  0);opacity:0.01}';
const IonModalMdStyle0 = modalMdCss;
const Modal = /* @__PURE__ */ proxyCustomElement(class Modal2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.didPresent = createEvent(this, "ionModalDidPresent", 7);
    this.willPresent = createEvent(this, "ionModalWillPresent", 7);
    this.willDismiss = createEvent(this, "ionModalWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionModalDidDismiss", 7);
    this.ionBreakpointDidChange = createEvent(this, "ionBreakpointDidChange", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.ionMount = createEvent(this, "ionMount", 7);
    this.lockController = createLockController();
    this.triggerController = createTriggerController();
    this.coreDelegate = CoreDelegate();
    this.isSheetModal = false;
    this.inheritedAttributes = {};
    this.inline = false;
    this.gestureAnimationDismissing = false;
    this.onHandleClick = () => {
      const { sheetTransition, handleBehavior } = this;
      if (handleBehavior !== "cycle" || sheetTransition !== void 0) {
        return;
      }
      this.moveToNextBreakpoint();
    };
    this.onBackdropTap = () => {
      const { sheetTransition } = this;
      if (sheetTransition !== void 0) {
        return;
      }
      this.dismiss(void 0, BACKDROP);
    };
    this.onLifecycle = (modalEvent) => {
      const el2 = this.usersElement;
      const name = LIFECYCLE_MAP[modalEvent.type];
      if (el2 && name) {
        const ev = new CustomEvent(name, {
          bubbles: false,
          cancelable: false,
          detail: modalEvent.detail
        });
        el2.dispatchEvent(ev);
      }
    };
    this.presented = false;
    this.hasController = false;
    this.overlayIndex = void 0;
    this.delegate = void 0;
    this.keyboardClose = true;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.breakpoints = void 0;
    this.initialBreakpoint = void 0;
    this.backdropBreakpoint = 0;
    this.handle = void 0;
    this.handleBehavior = "none";
    this.component = void 0;
    this.componentProps = void 0;
    this.cssClass = void 0;
    this.backdropDismiss = true;
    this.showBackdrop = true;
    this.animated = true;
    this.presentingElement = void 0;
    this.htmlAttributes = void 0;
    this.isOpen = false;
    this.trigger = void 0;
    this.keepContentsMounted = false;
    this.canDismiss = true;
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  triggerChanged() {
    const { trigger, el: el2, triggerController } = this;
    if (trigger) {
      triggerController.addClickListener(el2, trigger);
    }
  }
  breakpointsChanged(breakpoints) {
    if (breakpoints !== void 0) {
      this.sortedBreakpoints = breakpoints.sort((a2, b2) => a2 - b2);
    }
  }
  connectedCallback() {
    const { el: el2 } = this;
    prepareOverlay(el2);
    this.triggerChanged();
  }
  disconnectedCallback() {
    this.triggerController.removeClickListener();
  }
  componentWillLoad() {
    const { breakpoints, initialBreakpoint, el: el2 } = this;
    const isSheetModal = this.isSheetModal = breakpoints !== void 0 && initialBreakpoint !== void 0;
    this.inheritedAttributes = inheritAttributes$2(el2, ["aria-label", "role"]);
    if (isSheetModal) {
      this.currentBreakpoint = this.initialBreakpoint;
    }
    if (breakpoints !== void 0 && initialBreakpoint !== void 0 && !breakpoints.includes(initialBreakpoint)) {
      printIonWarning("Your breakpoints array must include the initialBreakpoint value.");
    }
    setOverlayId(el2);
  }
  componentDidLoad() {
    if (this.isOpen === true) {
      raf(() => this.present());
    }
    this.breakpointsChanged(this.breakpoints);
    this.triggerChanged();
  }
  /**
   * Determines whether or not an overlay
   * is being used inline or via a controller/JS
   * and returns the correct delegate.
   * By default, subsequent calls to getDelegate
   * will use a cached version of the delegate.
   * This is useful for calling dismiss after
   * present so that the correct delegate is given.
   */
  getDelegate(force = false) {
    if (this.workingDelegate && !force) {
      return {
        delegate: this.workingDelegate,
        inline: this.inline
      };
    }
    const parentEl = this.el.parentNode;
    const inline = this.inline = parentEl !== null && !this.hasController;
    const delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;
    return { inline, delegate };
  }
  /**
   * Determines whether or not the
   * modal is allowed to dismiss based
   * on the state of the canDismiss prop.
   */
  async checkCanDismiss(data, role) {
    const { canDismiss } = this;
    if (typeof canDismiss === "function") {
      return canDismiss(data, role);
    }
    return canDismiss;
  }
  /**
   * Present the modal overlay after it has been created.
   */
  async present() {
    const unlock = await this.lockController.lock();
    if (this.presented) {
      unlock();
      return;
    }
    const { presentingElement, el: el2 } = this;
    this.currentBreakpoint = this.initialBreakpoint;
    const { inline, delegate } = this.getDelegate(true);
    this.ionMount.emit();
    this.usersElement = await attachComponent(delegate, el2, this.component, ["ion-page"], this.componentProps, inline);
    if (hasLazyBuild(el2)) {
      await deepReady(this.usersElement);
    } else if (!this.keepContentsMounted) {
      await waitForMount();
    }
    writeTask(() => this.el.classList.add("show-modal"));
    const hasCardModal = presentingElement !== void 0;
    if (hasCardModal && getIonMode$2(this) === "ios") {
      this.statusBarStyle = await StatusBar.getStyle();
      setCardStatusBarDark();
    }
    await present(this, "modalEnter", iosEnterAnimation, mdEnterAnimation, {
      presentingEl: presentingElement,
      currentBreakpoint: this.initialBreakpoint,
      backdropBreakpoint: this.backdropBreakpoint
    });
    if (typeof window !== "undefined") {
      this.keyboardOpenCallback = () => {
        if (this.gesture) {
          this.gesture.enable(false);
          raf(() => {
            if (this.gesture) {
              this.gesture.enable(true);
            }
          });
        }
      };
      window.addEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);
    }
    if (this.isSheetModal) {
      this.initSheetGesture();
    } else if (hasCardModal) {
      this.initSwipeToClose();
    }
    unlock();
  }
  initSwipeToClose() {
    var _a;
    if (getIonMode$2(this) !== "ios") {
      return;
    }
    const { el: el2 } = this;
    const animationBuilder = this.leaveAnimation || config$1.get("modalLeave", iosLeaveAnimation);
    const ani = this.animation = animationBuilder(el2, { presentingEl: this.presentingElement });
    const contentEl = findIonContent(el2);
    if (!contentEl) {
      printIonContentErrorMsg(el2);
      return;
    }
    const statusBarStyle = (_a = this.statusBarStyle) !== null && _a !== void 0 ? _a : Style.Default;
    this.gesture = createSwipeToCloseGesture(el2, ani, statusBarStyle, () => {
      this.gestureAnimationDismissing = true;
      setCardStatusBarDefault(this.statusBarStyle);
      this.animation.onFinish(async () => {
        await this.dismiss(void 0, GESTURE);
        this.gestureAnimationDismissing = false;
      });
    });
    this.gesture.enable(true);
  }
  initSheetGesture() {
    const { wrapperEl, initialBreakpoint, backdropBreakpoint } = this;
    if (!wrapperEl || initialBreakpoint === void 0) {
      return;
    }
    const animationBuilder = this.enterAnimation || config$1.get("modalEnter", iosEnterAnimation);
    const ani = this.animation = animationBuilder(this.el, {
      presentingEl: this.presentingElement,
      currentBreakpoint: initialBreakpoint,
      backdropBreakpoint
    });
    ani.progressStart(true, 1);
    const { gesture, moveSheetToBreakpoint } = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, this.sortedBreakpoints, () => {
      var _a;
      return (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : 0;
    }, () => this.sheetOnDismiss(), (breakpoint) => {
      if (this.currentBreakpoint !== breakpoint) {
        this.currentBreakpoint = breakpoint;
        this.ionBreakpointDidChange.emit({ breakpoint });
      }
    });
    this.gesture = gesture;
    this.moveSheetToBreakpoint = moveSheetToBreakpoint;
    this.gesture.enable(true);
  }
  sheetOnDismiss() {
    this.gestureAnimationDismissing = true;
    this.animation.onFinish(async () => {
      this.currentBreakpoint = 0;
      this.ionBreakpointDidChange.emit({ breakpoint: this.currentBreakpoint });
      await this.dismiss(void 0, GESTURE);
      this.gestureAnimationDismissing = false;
    });
  }
  /**
   * Dismiss the modal overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.
   *
   * This is a no-op if the overlay has not been presented yet. If you want
   * to remove an overlay from the DOM that was never presented, use the
   * [remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.
   */
  async dismiss(data, role) {
    var _a;
    if (this.gestureAnimationDismissing && role !== GESTURE) {
      return false;
    }
    const unlock = await this.lockController.lock();
    if (role !== "handler" && !await this.checkCanDismiss(data, role)) {
      unlock();
      return false;
    }
    const { presentingElement } = this;
    const hasCardModal = presentingElement !== void 0;
    if (hasCardModal && getIonMode$2(this) === "ios") {
      setCardStatusBarDefault(this.statusBarStyle);
    }
    if (typeof window !== "undefined" && this.keyboardOpenCallback) {
      window.removeEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);
      this.keyboardOpenCallback = void 0;
    }
    const dismissed = await dismiss(this, data, role, "modalLeave", iosLeaveAnimation, mdLeaveAnimation, {
      presentingEl: presentingElement,
      currentBreakpoint: (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : this.initialBreakpoint,
      backdropBreakpoint: this.backdropBreakpoint
    });
    if (dismissed) {
      const { delegate } = this.getDelegate();
      await detachComponent(delegate, this.usersElement);
      writeTask(() => this.el.classList.remove("show-modal"));
      if (this.animation) {
        this.animation.destroy();
      }
      if (this.gesture) {
        this.gesture.destroy();
      }
    }
    this.currentBreakpoint = void 0;
    this.animation = void 0;
    unlock();
    return dismissed;
  }
  /**
   * Returns a promise that resolves when the modal did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionModalDidDismiss");
  }
  /**
   * Returns a promise that resolves when the modal will dismiss.
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionModalWillDismiss");
  }
  /**
   * Move a sheet style modal to a specific breakpoint. The breakpoint value must
   * be a value defined in your `breakpoints` array.
   */
  async setCurrentBreakpoint(breakpoint) {
    if (!this.isSheetModal) {
      printIonWarning("setCurrentBreakpoint is only supported on sheet modals.");
      return;
    }
    if (!this.breakpoints.includes(breakpoint)) {
      printIonWarning(`Attempted to set invalid breakpoint value ${breakpoint}. Please double check that the breakpoint value is part of your defined breakpoints.`);
      return;
    }
    const { currentBreakpoint, moveSheetToBreakpoint, canDismiss, breakpoints, animated } = this;
    if (currentBreakpoint === breakpoint) {
      return;
    }
    if (moveSheetToBreakpoint) {
      this.sheetTransition = moveSheetToBreakpoint({
        breakpoint,
        breakpointOffset: 1 - currentBreakpoint,
        canDismiss: canDismiss !== void 0 && canDismiss !== true && breakpoints[0] === 0,
        animated
      });
      await this.sheetTransition;
      this.sheetTransition = void 0;
    }
  }
  /**
   * Returns the current breakpoint of a sheet style modal
   */
  async getCurrentBreakpoint() {
    return this.currentBreakpoint;
  }
  async moveToNextBreakpoint() {
    const { breakpoints, currentBreakpoint } = this;
    if (!breakpoints || currentBreakpoint == null) {
      return false;
    }
    const allowedBreakpoints = breakpoints.filter((b2) => b2 !== 0);
    const currentBreakpointIndex = allowedBreakpoints.indexOf(currentBreakpoint);
    const nextBreakpointIndex = (currentBreakpointIndex + 1) % allowedBreakpoints.length;
    const nextBreakpoint = allowedBreakpoints[nextBreakpointIndex];
    await this.setCurrentBreakpoint(nextBreakpoint);
    return true;
  }
  render() {
    const { handle, isSheetModal, presentingElement, htmlAttributes, handleBehavior, inheritedAttributes } = this;
    const showHandle = handle !== false && isSheetModal;
    const mode = getIonMode$2(this);
    const isCardModal = presentingElement !== void 0 && mode === "ios";
    const isHandleCycle = handleBehavior === "cycle";
    return h$1(Host, Object.assign({ key: "0c2c4369ab2df4ef4660addea5e927c6a0232864", "no-router": true, tabindex: "-1" }, htmlAttributes, { style: {
      zIndex: `${2e4 + this.overlayIndex}`
    }, class: Object.assign({ [mode]: true, ["modal-default"]: !isCardModal && !isSheetModal, [`modal-card`]: isCardModal, [`modal-sheet`]: isSheetModal, "overlay-hidden": true }, getClassMap(this.cssClass)), onIonBackdropTap: this.onBackdropTap, onIonModalDidPresent: this.onLifecycle, onIonModalWillPresent: this.onLifecycle, onIonModalWillDismiss: this.onLifecycle, onIonModalDidDismiss: this.onLifecycle }), h$1("ion-backdrop", { key: "d044383a776c2ee1703f996caedaedca47f2948f", ref: (el2) => this.backdropEl = el2, visible: this.showBackdrop, tappable: this.backdropDismiss, part: "backdrop" }), mode === "ios" && h$1("div", { class: "modal-shadow" }), h$1("div", Object.assign({
      key: "8d23b6a3cc9069e4d46fa0645cde9db3e6f89507",
      /*
        role and aria-modal must be used on the
        same element. They must also be set inside the
        shadow DOM otherwise ion-button will not be highlighted
        when using VoiceOver: https://bugs.webkit.org/show_bug.cgi?id=247134
      */
      role: "dialog"
    }, inheritedAttributes, { "aria-modal": "true", class: "modal-wrapper ion-overlay-wrapper", part: "content", ref: (el2) => this.wrapperEl = el2 }), showHandle && h$1("button", {
      class: "modal-handle",
      // Prevents the handle from receiving keyboard focus when it does not cycle
      tabIndex: !isHandleCycle ? -1 : 0,
      "aria-label": "Activate to adjust the size of the dialog overlaying the screen",
      onClick: isHandleCycle ? this.onHandleClick : void 0,
      part: "handle"
    }), h$1("slot", { key: "3fbb689e4bf5575fbb26ad1000f6ac5993f3bf8f" })));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["triggerChanged"]
    };
  }
  static get style() {
    return {
      ios: IonModalIosStyle0,
      md: IonModalMdStyle0
    };
  }
}, [33, "ion-modal", {
  "hasController": [4, "has-controller"],
  "overlayIndex": [2, "overlay-index"],
  "delegate": [16],
  "keyboardClose": [4, "keyboard-close"],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "breakpoints": [16],
  "initialBreakpoint": [2, "initial-breakpoint"],
  "backdropBreakpoint": [2, "backdrop-breakpoint"],
  "handle": [4],
  "handleBehavior": [1, "handle-behavior"],
  "component": [1],
  "componentProps": [16],
  "cssClass": [1, "css-class"],
  "backdropDismiss": [4, "backdrop-dismiss"],
  "showBackdrop": [4, "show-backdrop"],
  "animated": [4],
  "presentingElement": [16],
  "htmlAttributes": [16],
  "isOpen": [4, "is-open"],
  "trigger": [1],
  "keepContentsMounted": [4, "keep-contents-mounted"],
  "canDismiss": [4, "can-dismiss"],
  "presented": [32],
  "present": [64],
  "dismiss": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64],
  "setCurrentBreakpoint": [64],
  "getCurrentBreakpoint": [64]
}, void 0, {
  "isOpen": ["onIsOpenChange"],
  "trigger": ["triggerChanged"]
}]);
const LIFECYCLE_MAP = {
  ionModalDidPresent: "ionViewDidEnter",
  ionModalWillPresent: "ionViewWillEnter",
  ionModalWillDismiss: "ionViewWillLeave",
  ionModalDidDismiss: "ionViewDidLeave"
};
function defineCustomElement$1$5() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-modal", "ion-backdrop"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-modal":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Modal);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$z();
        }
        break;
    }
  });
}
const defineCustomElement$7 = defineCustomElement$1$5;
const appCss = "html.plt-mobile ion-app{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html.plt-mobile ion-app [contenteditable]{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text}ion-app.force-statusbar-padding{--ion-safe-area-top:20px}";
const IonAppStyle0 = appCss;
const App$1 = /* @__PURE__ */ proxyCustomElement(class App extends H {
  constructor() {
    super();
    this.__registerHost();
  }
  componentDidLoad() {
    {
      rIC(async () => {
        const isHybrid2 = isPlatform(window, "hybrid");
        if (!config$1.getBoolean("_testing")) {
          __vitePreload(() => import("./index9-BaUeDCVJ.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((module) => module.startTapClick(config$1));
        }
        if (config$1.getBoolean("statusTap", isHybrid2)) {
          __vitePreload(() => import("./status-tap-Duwm_QMj.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((module) => module.startStatusTap());
        }
        if (config$1.getBoolean("inputShims", needInputShims())) {
          const platform2 = isPlatform(window, "ios") ? "ios" : "android";
          __vitePreload(() => import("./input-shims-VjftP1GT.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((module) => module.startInputShims(config$1, platform2));
        }
        const hardwareBackButtonModule = await __vitePreload(() => Promise.resolve().then(() => hardwareBackButton), true ? void 0 : void 0, import.meta.url);
        const supportsHardwareBackButtonEvents = isHybrid2 || shoudUseCloseWatcher();
        if (config$1.getBoolean("hardwareBackButton", supportsHardwareBackButtonEvents)) {
          hardwareBackButtonModule.startHardwareBackButton();
        } else {
          if (shoudUseCloseWatcher()) {
            printIonWarning("experimentalCloseWatcher was set to `true`, but hardwareBackButton was set to `false`. Both config options must be `true` for the Close Watcher API to be used.");
          }
          hardwareBackButtonModule.blockHardwareBackButton();
        }
        if (typeof window !== "undefined") {
          __vitePreload(() => Promise.resolve().then(() => keyboard2), true ? void 0 : void 0, import.meta.url).then((module) => module.startKeyboardAssist(window));
        }
        __vitePreload(() => import("./focus-visible-rDEGL05U.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((module) => this.focusVisible = module.startFocusVisible());
      });
    }
  }
  /**
   * @internal
   * Used to set focus on an element that uses `ion-focusable`.
   * Do not use this if focusing the element as a result of a keyboard
   * event as the focus utility should handle this for us. This method
   * should be used when we want to programmatically focus an element as
   * a result of another user action. (Ex: We focus the first element
   * inside of a popover when the user presents it, but the popover is not always
   * presented as a result of keyboard action.)
   */
  async setFocus(elements) {
    if (this.focusVisible) {
      this.focusVisible.setFocus(elements);
    }
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host, { key: "3535eb5c0dab78a78011e552524a98599b2b650f", class: {
      [mode]: true,
      "ion-page": true,
      "force-statusbar-padding": config$1.getBoolean("_forceStatusbarPadding")
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return IonAppStyle0;
  }
}, [0, "ion-app", {
  "setFocus": [64]
}]);
const needInputShims = () => {
  const needsShimsIOS = isPlatform(window, "ios") && isPlatform(window, "mobile");
  if (needsShimsIOS) {
    return true;
  }
  const isAndroidMobileWeb = isPlatform(window, "android") && isPlatform(window, "mobileweb");
  if (isAndroidMobileWeb) {
    return true;
  }
  return false;
};
const rIC = (callback) => {
  if ("requestIdleCallback" in window) {
    window.requestIdleCallback(callback);
  } else {
    setTimeout(callback, 32);
  }
};
function defineCustomElement$1$4() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-app"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-app":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, App$1);
        }
        break;
    }
  });
}
const defineCustomElement$6 = defineCustomElement$1$4;
const routerOutletCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;z-index:0}";
const IonRouterOutletStyle0 = routerOutletCss;
const RouterOutlet = /* @__PURE__ */ proxyCustomElement(class RouterOutlet2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionNavWillLoad = createEvent(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = createEvent(this, "ionNavWillChange", 3);
    this.ionNavDidChange = createEvent(this, "ionNavDidChange", 3);
    this.lockController = createLockController();
    this.gestureOrAnimationInProgress = false;
    this.mode = getIonMode$2(this);
    this.delegate = void 0;
    this.animated = true;
    this.animation = void 0;
    this.swipeHandler = void 0;
  }
  swipeHandlerChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeHandler !== void 0);
    }
  }
  async connectedCallback() {
    const onStart = () => {
      this.gestureOrAnimationInProgress = true;
      if (this.swipeHandler) {
        this.swipeHandler.onStart();
      }
    };
    this.gesture = (await __vitePreload(() => import("./swipe-back-DcwzW9An.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url)).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), (step) => {
      var _a;
      return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step);
    }, (shouldComplete, step, dur) => {
      if (this.ani) {
        this.ani.onFinish(() => {
          this.gestureOrAnimationInProgress = false;
          if (this.swipeHandler) {
            this.swipeHandler.onEnd(shouldComplete);
          }
        }, { oneTimeCallback: true });
        let newStepValue = shouldComplete ? -1e-3 : 1e-3;
        if (!shouldComplete) {
          this.ani.easing("cubic-bezier(1, 0, 0.68, 0.28)");
          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
        } else {
          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
        }
        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
      } else {
        this.gestureOrAnimationInProgress = false;
      }
    });
    this.swipeHandlerChanged();
  }
  componentWillLoad() {
    this.ionNavWillLoad.emit();
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
  }
  /** @internal */
  async commit(enteringEl, leavingEl, opts) {
    const unlock = await this.lockController.lock();
    let changed = false;
    try {
      changed = await this.transition(enteringEl, leavingEl, opts);
    } catch (e2) {
      console.error(e2);
    }
    unlock();
    return changed;
  }
  /** @internal */
  async setRouteId(id2, params, direction, animation2) {
    const changed = await this.setRoot(id2, params, {
      duration: direction === "root" ? 0 : void 0,
      direction: direction === "back" ? "back" : "forward",
      animationBuilder: animation2
    });
    return {
      changed,
      element: this.activeEl
    };
  }
  /** @internal */
  async getRouteId() {
    const active = this.activeEl;
    return active ? {
      id: active.tagName,
      element: active,
      params: this.activeParams
    } : void 0;
  }
  async setRoot(component, params, opts) {
    if (this.activeComponent === component && shallowEqualStringMap(params, this.activeParams)) {
      return false;
    }
    const leavingEl = this.activeEl;
    const enteringEl = await attachComponent(this.delegate, this.el, component, ["ion-page", "ion-page-invisible"], params);
    this.activeComponent = component;
    this.activeEl = enteringEl;
    this.activeParams = params;
    await this.commit(enteringEl, leavingEl, opts);
    await detachComponent(this.delegate, leavingEl);
    return true;
  }
  async transition(enteringEl, leavingEl, opts = {}) {
    if (leavingEl === enteringEl) {
      return false;
    }
    this.ionNavWillChange.emit();
    const { el: el2, mode } = this;
    const animated = this.animated && config$1.getBoolean("animated", true);
    const animationBuilder = opts.animationBuilder || this.animation || config$1.get("navAnimation");
    await transition(Object.assign(Object.assign({
      mode,
      animated,
      enteringEl,
      leavingEl,
      baseEl: el2,
      /**
       * We need to wait for all Stencil components
       * to be ready only when using the lazy
       * loaded bundle.
       */
      deepWait: hasLazyBuild(el2),
      progressCallback: opts.progressAnimation ? (ani) => {
        if (ani !== void 0 && !this.gestureOrAnimationInProgress) {
          this.gestureOrAnimationInProgress = true;
          ani.onFinish(() => {
            this.gestureOrAnimationInProgress = false;
            if (this.swipeHandler) {
              this.swipeHandler.onEnd(false);
            }
          }, { oneTimeCallback: true });
          ani.progressEnd(0, 0, 0);
        } else {
          this.ani = ani;
        }
      } : void 0
    }, opts), { animationBuilder }));
    this.ionNavDidChange.emit();
    return true;
  }
  render() {
    return h$1("slot", { key: "69b452a0dc0c10440bdd8700cf4843c43154c707" });
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "swipeHandler": ["swipeHandlerChanged"]
    };
  }
  static get style() {
    return IonRouterOutletStyle0;
  }
}, [1, "ion-router-outlet", {
  "mode": [1025],
  "delegate": [16],
  "animated": [4],
  "animation": [16],
  "swipeHandler": [16],
  "commit": [64],
  "setRouteId": [64],
  "getRouteId": [64]
}, void 0, {
  "swipeHandler": ["swipeHandlerChanged"]
}]);
function defineCustomElement$1$3() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-router-outlet"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-router-outlet":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RouterOutlet);
        }
        break;
    }
  });
}
const defineCustomElement$5 = defineCustomElement$1$3;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const tabBarIosCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-right:var(--ion-safe-area-right);padding-bottom:var(--ion-safe-area-bottom, 0);padding-left:var(--ion-safe-area-left);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-color-step-50, #f7f7f7));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--color:var(--ion-tab-bar-color, var(--ion-color-step-600, #666666));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:50px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.tab-bar-translucent){--background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(210%) blur(20px);backdrop-filter:saturate(210%) blur(20px)}:host(.ion-color.tab-bar-translucent){background:rgba(var(--ion-color-base-rgb), 0.8)}:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.6)}}";
const IonTabBarIosStyle0 = tabBarIosCss;
const tabBarMdCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-right:var(--ion-safe-area-right);padding-bottom:var(--ion-safe-area-bottom, 0);padding-left:var(--ion-safe-area-left);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:1px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.07))));--color:var(--ion-tab-bar-color, var(--ion-color-step-650, #595959));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:56px}";
const IonTabBarMdStyle0 = tabBarMdCss;
const TabBar = /* @__PURE__ */ proxyCustomElement(class TabBar2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionTabBarChanged = createEvent(this, "ionTabBarChanged", 7);
    this.ionTabBarLoaded = createEvent(this, "ionTabBarLoaded", 7);
    this.keyboardCtrl = null;
    this.keyboardVisible = false;
    this.color = void 0;
    this.selectedTab = void 0;
    this.translucent = false;
  }
  selectedTabChanged() {
    if (this.selectedTab !== void 0) {
      this.ionTabBarChanged.emit({
        tab: this.selectedTab
      });
    }
  }
  componentWillLoad() {
    this.selectedTabChanged();
  }
  async connectedCallback() {
    this.keyboardCtrl = await createKeyboardController(async (keyboardOpen2, waitForResize) => {
      if (keyboardOpen2 === false && waitForResize !== void 0) {
        await waitForResize;
      }
      this.keyboardVisible = keyboardOpen2;
    });
  }
  disconnectedCallback() {
    if (this.keyboardCtrl) {
      this.keyboardCtrl.destroy();
    }
  }
  componentDidLoad() {
    this.ionTabBarLoaded.emit();
  }
  render() {
    const { color, translucent, keyboardVisible } = this;
    const mode = getIonMode$2(this);
    const shouldHide = keyboardVisible && this.el.getAttribute("slot") !== "top";
    return h$1(Host, { key: "e2b4b50270f171ed251359df6c65c5e7e4d526a4", role: "tablist", "aria-hidden": shouldHide ? "true" : null, class: createColorClasses$2(color, {
      [mode]: true,
      "tab-bar-translucent": translucent,
      "tab-bar-hidden": shouldHide
    }) }, h$1("slot", { key: "37495b2eddd01a758ceaeb36426abc9bd20bcca3" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "selectedTab": ["selectedTabChanged"]
    };
  }
  static get style() {
    return {
      ios: IonTabBarIosStyle0,
      md: IonTabBarMdStyle0
    };
  }
}, [33, "ion-tab-bar", {
  "color": [513],
  "selectedTab": [1, "selected-tab"],
  "translucent": [4],
  "keyboardVisible": [32]
}, void 0, {
  "selectedTab": ["selectedTabChanged"]
}]);
function defineCustomElement$1$2() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-tab-bar"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-tab-bar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, TabBar);
        }
        break;
    }
  });
}
const defineCustomElement$4 = defineCustomElement$1$2;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const tabButtonIosCss = ':host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}::slotted(ion-badge){-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px;padding-top:1px;padding-bottom:1px;top:4px;height:auto;font-size:12px;line-height:16px}@supports (inset-inline-start: 0){::slotted(ion-badge){inset-inline-start:calc(50% + 6px)}}@supports not (inset-inline-start: 0){::slotted(ion-badge){left:calc(50% + 6px)}:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}[dir=rtl] ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}@supports selector(:dir(rtl)){::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 6px)}}}::slotted(ion-icon){margin-top:2px;margin-bottom:2px;font-size:30px}::slotted(ion-icon::before){vertical-align:top}::slotted(ion-label){margin-top:0;margin-bottom:1px;min-height:11px;font-weight:500}:host(.tab-has-label-only) ::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-label),:host(.tab-layout-icon-start) ::slotted(ion-label),:host(.tab-layout-icon-hide) ::slotted(ion-label){margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-icon),:host(.tab-layout-icon-start) ::slotted(ion-icon){min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){inset-inline-start:calc(50% + 12px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:calc(50% + 12px)}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 12px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-bottom:dir(rtl)) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 12px)}}}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:1px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:4px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){top:10px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){inset-inline-start:calc(50% + 35px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:calc(50% + 35px)}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 35px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-start:dir(rtl)) ::slotted(ion-badge),:host(.tab-layout-icon-end:dir(rtl)) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 35px)}}}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){top:10px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){inset-inline-start:calc(50% + 30px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:calc(50% + 30px)}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 30px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-hide:dir(rtl)) ::slotted(ion-badge),:host(.tab-has-label-only:dir(rtl)) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 30px)}}}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:10px}:host(.tab-layout-label-hide) ::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}';
const IonTabButtonIosStyle0 = tabButtonIosCss;
const tabButtonMdCss = ':host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:12px;--padding-bottom:0;--padding-start:12px;max-width:168px;font-size:12px;font-weight:normal;letter-spacing:0.03em}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;text-transform:none}::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;-webkit-transform-origin:center center;transform-origin:center center;font-size:22px}:host-context([dir=rtl]) ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}[dir=rtl] ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}@supports selector(:dir(rtl)){::slotted(ion-icon):dir(rtl){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}}::slotted(ion-badge){border-radius:8px;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px;padding-top:3px;padding-bottom:2px;top:8px;min-width:12px;font-size:8px;font-weight:normal}@supports (inset-inline-start: 0){::slotted(ion-badge){inset-inline-start:calc(50% + 6px)}}@supports not (inset-inline-start: 0){::slotted(ion-badge){left:calc(50% + 6px)}:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}[dir=rtl] ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}@supports selector(:dir(rtl)){::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 6px)}}}::slotted(ion-badge:empty){display:block;min-width:8px;height:8px}:host(.tab-layout-icon-top) ::slotted(ion-icon){margin-top:6px;margin-bottom:2px}:host(.tab-layout-icon-top) ::slotted(ion-label){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){top:8px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){inset-inline-start:70%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:70%}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:70%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-bottom:dir(rtl)) ::slotted(ion-badge){left:unset;right:unset;right:70%}}}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:6px;margin-bottom:0}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){top:16px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){inset-inline-start:80%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:80%}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:80%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-start:dir(rtl)) ::slotted(ion-badge),:host(.tab-layout-icon-end:dir(rtl)) ::slotted(ion-badge){left:unset;right:unset;right:80%}}}:host(.tab-layout-icon-start) ::slotted(ion-icon){-webkit-margin-end:6px;margin-inline-end:6px}:host(.tab-layout-icon-end) ::slotted(ion-icon){-webkit-margin-start:6px;margin-inline-start:6px}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){top:16px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){inset-inline-start:70%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:70%}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:70%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-hide:dir(rtl)) ::slotted(ion-badge),:host(.tab-has-label-only:dir(rtl)) ::slotted(ion-badge){left:unset;right:unset;right:70%}}}:host(.tab-layout-icon-hide) ::slotted(ion-label),:host(.tab-has-label-only) ::slotted(ion-label){margin-top:0;margin-bottom:0}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:16px}:host(.tab-layout-label-hide) ::slotted(ion-icon),:host(.tab-has-icon-only) ::slotted(ion-icon){margin-top:0;margin-bottom:0;font-size:24px}';
const IonTabButtonMdStyle0 = tabButtonMdCss;
const TabButton = /* @__PURE__ */ proxyCustomElement(class TabButton2 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionTabButtonClick = createEvent(this, "ionTabButtonClick", 7);
    this.inheritedAttributes = {};
    this.onKeyUp = (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        this.selectTab(ev);
      }
    };
    this.onClick = (ev) => {
      this.selectTab(ev);
    };
    this.disabled = false;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.layout = void 0;
    this.selected = false;
    this.tab = void 0;
    this.target = void 0;
  }
  onTabBarChanged(ev) {
    const dispatchedFrom = ev.target;
    const parent = this.el.parentElement;
    if (ev.composedPath().includes(parent) || (dispatchedFrom === null || dispatchedFrom === void 0 ? void 0 : dispatchedFrom.contains(this.el))) {
      this.selected = this.tab === ev.detail.tab;
    }
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign({}, inheritAttributes$2(this.el, ["aria-label"]));
    if (this.layout === void 0) {
      this.layout = config$1.get("tabButtonLayout", "icon-top");
    }
  }
  selectTab(ev) {
    if (this.tab !== void 0) {
      if (!this.disabled) {
        this.ionTabButtonClick.emit({
          tab: this.tab,
          href: this.href,
          selected: this.selected
        });
      }
      ev.preventDefault();
    }
  }
  get hasLabel() {
    return !!this.el.querySelector("ion-label");
  }
  get hasIcon() {
    return !!this.el.querySelector("ion-icon");
  }
  render() {
    const { disabled, hasIcon, hasLabel, href, rel, target, layout, selected, tab, inheritedAttributes } = this;
    const mode = getIonMode$2(this);
    const attrs = {
      download: this.download,
      href,
      rel,
      target
    };
    return h$1(Host, { key: "9926f9392e7910ff3159397e4f907e0d7d2cf5a0", onClick: this.onClick, onKeyup: this.onKeyUp, id: tab !== void 0 ? `tab-button-${tab}` : null, class: {
      [mode]: true,
      "tab-selected": selected,
      "tab-disabled": disabled,
      "tab-has-label": hasLabel,
      "tab-has-icon": hasIcon,
      "tab-has-label-only": hasLabel && !hasIcon,
      "tab-has-icon-only": hasIcon && !hasLabel,
      [`tab-layout-${layout}`]: true,
      "ion-activatable": true,
      "ion-selectable": true,
      "ion-focusable": true
    } }, h$1("a", Object.assign({ key: "4b3ace749583a5502e94462f9a70c5158fe0194a" }, attrs, { class: "button-native", part: "native", role: "tab", "aria-selected": selected ? "true" : null, "aria-disabled": disabled ? "true" : null, tabindex: disabled ? "-1" : void 0 }, inheritedAttributes), h$1("span", { key: "a2a30c02fbd5052da12586a5ab00a45f3bf53b88", class: "button-inner" }, h$1("slot", { key: "3fb22ffbb09000d99537b531220c029330ae6940" })), mode === "md" && h$1("ion-ripple-effect", { type: "unbounded" })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonTabButtonIosStyle0,
      md: IonTabButtonMdStyle0
    };
  }
}, [33, "ion-tab-button", {
  "disabled": [4],
  "download": [1],
  "href": [1],
  "rel": [1],
  "layout": [1025],
  "selected": [1028],
  "tab": [1],
  "target": [1]
}, [[8, "ionTabBarChanged", "onTabBarChanged"]]]);
function defineCustomElement$1$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-tab-button", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-tab-button":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, TabButton);
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$w();
        }
        break;
    }
  });
}
const defineCustomElement$3 = defineCustomElement$1$1;
let CACHED_MAP;
const getIconMap = () => {
  if (typeof window === "undefined") {
    return /* @__PURE__ */ new Map();
  } else {
    if (!CACHED_MAP) {
      const win2 = window;
      win2.Ionicons = win2.Ionicons || {};
      CACHED_MAP = win2.Ionicons.map = win2.Ionicons.map || /* @__PURE__ */ new Map();
    }
    return CACHED_MAP;
  }
};
const getUrl = (i) => {
  let url = getSrc(i.src);
  if (url) {
    return url;
  }
  url = getName(i.name, i.icon, i.mode, i.ios, i.md);
  if (url) {
    return getNamedUrl(url, i);
  }
  if (i.icon) {
    url = getSrc(i.icon);
    if (url) {
      return url;
    }
    url = getSrc(i.icon[i.mode]);
    if (url) {
      return url;
    }
  }
  return null;
};
const getNamedUrl = (iconName, iconEl) => {
  const url = getIconMap().get(iconName);
  if (url) {
    return url;
  }
  try {
    return getAssetPath(`svg/${iconName}.svg`);
  } catch (e2) {
    console.warn(`[Ionicons Warning]: Could not load icon with name "${iconName}". Ensure that the icon is registered using addIcons or that the icon SVG data is passed directly to the icon component.`, iconEl);
  }
};
const getName = (iconName, icon, mode, ios, md2) => {
  mode = (mode && toLower(mode)) === "ios" ? "ios" : "md";
  if (ios && mode === "ios") {
    iconName = toLower(ios);
  } else if (md2 && mode === "md") {
    iconName = toLower(md2);
  } else {
    if (!iconName && icon && !isSrc(icon)) {
      iconName = icon;
    }
    if (isStr(iconName)) {
      iconName = toLower(iconName);
    }
  }
  if (!isStr(iconName) || iconName.trim() === "") {
    return null;
  }
  const invalidChars = iconName.replace(/[a-z]|-|\d/gi, "");
  if (invalidChars !== "") {
    return null;
  }
  return iconName;
};
const getSrc = (src) => {
  if (isStr(src)) {
    src = src.trim();
    if (isSrc(src)) {
      return src;
    }
  }
  return null;
};
const isSrc = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr = (val) => typeof val === "string";
const toLower = (val) => val.toLowerCase();
const inheritAttributes = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const isRTL = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
const validateContent = (svgContent) => {
  const div = document.createElement("div");
  div.innerHTML = svgContent;
  for (let i = div.childNodes.length - 1; i >= 0; i--) {
    if (div.childNodes[i].nodeName.toLowerCase() !== "svg") {
      div.removeChild(div.childNodes[i]);
    }
  }
  const svgElm = div.firstElementChild;
  if (svgElm && svgElm.nodeName.toLowerCase() === "svg") {
    const svgClass = svgElm.getAttribute("class") || "";
    svgElm.setAttribute("class", (svgClass + " s-ion-icon").trim());
    if (isValid(svgElm)) {
      return div.innerHTML;
    }
  }
  return "";
};
const isValid = (elm) => {
  if (elm.nodeType === 1) {
    if (elm.nodeName.toLowerCase() === "script") {
      return false;
    }
    for (let i = 0; i < elm.attributes.length; i++) {
      const name = elm.attributes[i].name;
      if (isStr(name) && name.toLowerCase().indexOf("on") === 0) {
        return false;
      }
    }
    for (let i = 0; i < elm.childNodes.length; i++) {
      if (!isValid(elm.childNodes[i])) {
        return false;
      }
    }
  }
  return true;
};
const isSvgDataUrl = (url) => url.startsWith("data:image/svg+xml");
const isEncodedDataUrl = (url) => url.indexOf(";utf8,") !== -1;
const ioniconContent = /* @__PURE__ */ new Map();
const requests = /* @__PURE__ */ new Map();
let parser;
const getSvgContent = (url, sanitize) => {
  let req = requests.get(url);
  if (!req) {
    if (typeof fetch !== "undefined" && typeof document !== "undefined") {
      if (isSvgDataUrl(url) && isEncodedDataUrl(url)) {
        if (!parser) {
          parser = new DOMParser();
        }
        const doc2 = parser.parseFromString(url, "text/html");
        const svg = doc2.querySelector("svg");
        if (svg) {
          ioniconContent.set(url, svg.outerHTML);
        }
        return Promise.resolve();
      } else {
        req = fetch(url).then((rsp) => {
          if (rsp.ok) {
            return rsp.text().then((svgContent) => {
              if (svgContent && sanitize !== false) {
                svgContent = validateContent(svgContent);
              }
              ioniconContent.set(url, svgContent || "");
            });
          }
          ioniconContent.set(url, "");
        });
        requests.set(url, req);
      }
    } else {
      ioniconContent.set(url, "");
      return Promise.resolve();
    }
  }
  return req;
};
const iconCss = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}@supports (background: -webkit-named-image(i)){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}@supports not selector(:dir(rtl)) and selector(:host-context([dir='rtl'])){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}:host(.flip-rtl):host-context([dir='rtl']) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}@supports selector(:dir(rtl)){:host(.flip-rtl:dir(rtl)) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.flip-rtl:dir(ltr)) .icon-inner{-webkit-transform:scaleX(1);transform:scaleX(1)}}:host(.icon-small){font-size:1.125rem !important}:host(.icon-large){font-size:2rem !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";
const Icon2 = /* @__PURE__ */ proxyCustomElement(class Icon3 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.iconName = null;
    this.inheritedAttributes = {};
    this.didLoadIcon = false;
    this.svgContent = void 0;
    this.isVisible = false;
    this.mode = getIonMode();
    this.color = void 0;
    this.ios = void 0;
    this.md = void 0;
    this.flipRtl = void 0;
    this.name = void 0;
    this.src = void 0;
    this.icon = void 0;
    this.size = void 0;
    this.lazy = false;
    this.sanitize = true;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes(this.el, ["aria-label"]);
  }
  connectedCallback() {
    this.waitUntilVisible(this.el, "50px", () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  componentDidLoad() {
    if (!this.didLoadIcon) {
      this.loadIcon();
    }
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  waitUntilVisible(el2, rootMargin, cb2) {
    if (this.lazy && typeof window !== "undefined" && window.IntersectionObserver) {
      const io = this.io = new window.IntersectionObserver((data) => {
        if (data[0].isIntersecting) {
          io.disconnect();
          this.io = void 0;
          cb2();
        }
      }, { rootMargin });
      io.observe(el2);
    } else {
      cb2();
    }
  }
  loadIcon() {
    if (this.isVisible) {
      const url = getUrl(this);
      if (url) {
        if (ioniconContent.has(url)) {
          this.svgContent = ioniconContent.get(url);
        } else {
          getSvgContent(url, this.sanitize).then(() => this.svgContent = ioniconContent.get(url));
        }
        this.didLoadIcon = true;
      }
    }
    this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);
  }
  render() {
    const { flipRtl, iconName, inheritedAttributes, el: el2 } = this;
    const mode = this.mode || "md";
    const shouldAutoFlip = iconName ? (iconName.includes("arrow") || iconName.includes("chevron")) && flipRtl !== false : false;
    const shouldBeFlippable = flipRtl || shouldAutoFlip;
    return h$1(Host, Object.assign({ role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, "flip-rtl": shouldBeFlippable, "icon-rtl": shouldBeFlippable && isRTL(el2) }) }, inheritedAttributes), this.svgContent ? h$1("div", { class: "icon-inner", innerHTML: this.svgContent }) : h$1("div", { class: "icon-inner" }));
  }
  static get assetsDirs() {
    return ["svg"];
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "name": ["loadIcon"],
      "src": ["loadIcon"],
      "icon": ["loadIcon"],
      "ios": ["loadIcon"],
      "md": ["loadIcon"]
    };
  }
  static get style() {
    return iconCss;
  }
}, [1, "ion-icon", {
  "mode": [1025],
  "color": [1],
  "ios": [1],
  "md": [1],
  "flipRtl": [4, "flip-rtl"],
  "name": [513],
  "src": [1],
  "icon": [8],
  "size": [1],
  "lazy": [4],
  "sanitize": [4],
  "svgContent": [32],
  "isVisible": [32]
}]);
const getIonMode = () => typeof document !== "undefined" && document.documentElement.getAttribute("mode") || "md";
const createColorClasses = (color) => {
  return color ? {
    "ion-color": true,
    [`ion-color-${color}`]: true
  } : null;
};
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-icon":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Icon2);
        }
        break;
    }
  });
}
const defineCustomElement$2 = defineCustomElement$1;
const IonLifeCycleContext = /* @__PURE__ */ React.createContext({
  onIonViewWillEnter: () => {
    return;
  },
  ionViewWillEnter: () => {
    return;
  },
  onIonViewDidEnter: () => {
    return;
  },
  ionViewDidEnter: () => {
    return;
  },
  onIonViewWillLeave: () => {
    return;
  },
  ionViewWillLeave: () => {
    return;
  },
  onIonViewDidLeave: () => {
    return;
  },
  ionViewDidLeave: () => {
    return;
  },
  cleanupIonViewWillEnter: () => {
    return;
  },
  cleanupIonViewDidEnter: () => {
    return;
  },
  cleanupIonViewWillLeave: () => {
    return;
  },
  cleanupIonViewDidLeave: () => {
    return;
  }
});
const DefaultIonLifeCycleContext = class {
  constructor() {
    this.ionViewWillEnterCallbacks = [];
    this.ionViewDidEnterCallbacks = [];
    this.ionViewWillLeaveCallbacks = [];
    this.ionViewDidLeaveCallbacks = [];
    this.ionViewWillEnterDestructorCallbacks = [];
    this.ionViewDidEnterDestructorCallbacks = [];
    this.ionViewWillLeaveDestructorCallbacks = [];
    this.ionViewDidLeaveDestructorCallbacks = [];
  }
  onIonViewWillEnter(callback) {
    if (callback.id) {
      const index = this.ionViewWillEnterCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index > -1) {
        this.ionViewWillEnterCallbacks[index] = callback;
      } else {
        this.ionViewWillEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewWillEnterCallbacks.push(callback);
    }
  }
  teardownCallback(callback, callbacks) {
    const matches2 = callbacks.filter((x2) => x2.id === callback.id);
    if (matches2.length !== 0) {
      matches2.forEach((match) => {
        if (match && typeof match.destructor === "function") {
          match.destructor();
        }
      });
      callbacks = callbacks.filter((x2) => x2.id !== callback.id);
    }
  }
  /**
   * Tears down the user-provided ionViewWillEnter lifecycle callback.
   * This is the same behavior as React's useEffect hook. The callback
   * is invoked when the component is unmounted.
   */
  cleanupIonViewWillEnter(callback) {
    this.teardownCallback(callback, this.ionViewWillEnterDestructorCallbacks);
  }
  /**
   * Tears down the user-provided ionViewDidEnter lifecycle callback.
   * This is the same behavior as React's useEffect hook. The callback
   * is invoked when the component is unmounted.
   */
  cleanupIonViewDidEnter(callback) {
    this.teardownCallback(callback, this.ionViewDidEnterDestructorCallbacks);
  }
  /**
   * Tears down the user-provided ionViewWillLeave lifecycle callback.
   * This is the same behavior as React's useEffect hook. The callback
   * is invoked when the component is unmounted.
   */
  cleanupIonViewWillLeave(callback) {
    this.teardownCallback(callback, this.ionViewWillLeaveDestructorCallbacks);
  }
  /**
   * Tears down the user-provided ionViewDidLeave lifecycle callback.
   * This is the same behavior as React's useEffect hook. The callback
   * is invoked when the component is unmounted.
   */
  cleanupIonViewDidLeave(callback) {
    this.teardownCallback(callback, this.ionViewDidLeaveDestructorCallbacks);
  }
  ionViewWillEnter() {
    this.ionViewWillEnterCallbacks.forEach((cb2) => {
      const destructor = cb2();
      if (cb2.id) {
        this.ionViewWillEnterDestructorCallbacks.push({ id: cb2.id, destructor });
      }
    });
  }
  onIonViewDidEnter(callback) {
    if (callback.id) {
      const index = this.ionViewDidEnterCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index > -1) {
        this.ionViewDidEnterCallbacks[index] = callback;
      } else {
        this.ionViewDidEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewDidEnterCallbacks.push(callback);
    }
  }
  ionViewDidEnter() {
    this.ionViewDidEnterCallbacks.forEach((cb2) => {
      const destructor = cb2();
      if (cb2.id) {
        this.ionViewDidEnterDestructorCallbacks.push({ id: cb2.id, destructor });
      }
    });
  }
  onIonViewWillLeave(callback) {
    if (callback.id) {
      const index = this.ionViewWillLeaveCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index > -1) {
        this.ionViewWillLeaveCallbacks[index] = callback;
      } else {
        this.ionViewWillLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewWillLeaveCallbacks.push(callback);
    }
  }
  ionViewWillLeave() {
    this.ionViewWillLeaveCallbacks.forEach((cb2) => {
      const destructor = cb2();
      if (cb2.id) {
        this.ionViewWillLeaveDestructorCallbacks.push({ id: cb2.id, destructor });
      }
    });
  }
  onIonViewDidLeave(callback) {
    if (callback.id) {
      const index = this.ionViewDidLeaveCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index > -1) {
        this.ionViewDidLeaveCallbacks[index] = callback;
      } else {
        this.ionViewDidLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewDidLeaveCallbacks.push(callback);
    }
  }
  ionViewDidLeave() {
    this.ionViewDidLeaveCallbacks.forEach((cb2) => {
      const destructor = cb2();
      if (cb2.id) {
        this.ionViewDidLeaveDestructorCallbacks.push({ id: cb2.id, destructor });
      }
    });
    this.componentCanBeDestroyed();
  }
  onComponentCanBeDestroyed(callback) {
    this.componentCanBeDestroyedCallback = callback;
  }
  componentCanBeDestroyed() {
    if (this.componentCanBeDestroyedCallback) {
      this.componentCanBeDestroyedCallback();
    }
  }
};
const NavContext = /* @__PURE__ */ React.createContext({
  getIonRedirect: () => void 0,
  getIonRoute: () => void 0,
  getPageManager: () => void 0,
  getStackManager: () => void 0,
  goBack: (route) => {
    if (typeof window !== "undefined") {
      if (typeof route === "string") {
        window.location.pathname = route;
      } else {
        window.history.back();
      }
    }
  },
  navigate: (path2) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path2;
    }
  },
  hasIonicRouter: () => false,
  routeInfo: void 0,
  setCurrentTab: () => void 0,
  changeTab: (_tab, path2) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path2;
    }
  },
  resetTab: (_tab, path2) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path2;
    }
  }
});
const dashToPascalCase = (str) => str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
const camelToDashCase = (str) => str.replace(/([A-Z])/g, (m2) => `-${m2[0].toLowerCase()}`);
const attachProps = (node, newProps, oldProps = {}) => {
  if (node instanceof Element) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className !== "") {
      node.className = className;
    }
    Object.keys(newProps).forEach((name) => {
      if (name === "children" || name === "style" || name === "ref" || name === "class" || name === "className" || name === "forwardedRef") {
        return;
      }
      if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
        const eventName = name.substring(2);
        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
        if (!isCoveredByReact(eventNameLc)) {
          syncEvent(node, eventNameLc, newProps[name]);
        }
      } else {
        node[name] = newProps[name];
        const propType = typeof newProps[name];
        if (propType === "string") {
          node.setAttribute(camelToDashCase(name), newProps[name]);
        }
      }
    });
  }
};
const getClassName = (classList, newProps, oldProps) => {
  const newClassProp = newProps.className || newProps.class;
  const oldClassProp = oldProps.className || oldProps.class;
  const currentClasses = arrayToMap(classList);
  const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(" ") : []);
  const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(" ") : []);
  const finalClassNames = [];
  currentClasses.forEach((currentClass) => {
    if (incomingPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
      incomingPropClasses.delete(currentClass);
    } else if (!oldPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
    }
  });
  incomingPropClasses.forEach((s2) => finalClassNames.push(s2));
  return finalClassNames.join(" ");
};
const transformReactEventName = (eventNameSuffix) => {
  switch (eventNameSuffix) {
    case "doubleclick":
      return "dblclick";
  }
  return eventNameSuffix;
};
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
const isCoveredByReact = (eventNameSuffix) => {
  if (typeof document === "undefined") {
    return true;
  } else {
    const eventName = "on" + transformReactEventName(eventNameSuffix);
    let isSupported = eventName in document;
    if (!isSupported) {
      const element = document.createElement("div");
      element.setAttribute(eventName, "return;");
      isSupported = typeof element[eventName] === "function";
    }
    return isSupported;
  }
};
const syncEvent = (node, eventName, newEventHandler) => {
  const eventStore = node.__events || (node.__events = {});
  const oldEventHandler = eventStore[eventName];
  if (oldEventHandler) {
    node.removeEventListener(eventName, oldEventHandler);
  }
  node.addEventListener(eventName, eventStore[eventName] = function handler(e2) {
    if (newEventHandler) {
      newEventHandler.call(this, e2);
    }
  });
};
const arrayToMap = (arr) => {
  const map = /* @__PURE__ */ new Map();
  arr.forEach((s2) => map.set(s2, s2));
  return map;
};
const setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref != null) {
    ref.current = value;
  }
};
const mergeRefs = (...refs) => {
  return (value) => {
    refs.forEach((ref) => {
      setRef(ref, value);
    });
  };
};
const createForwardRef$1 = (ReactComponent, displayName) => {
  const forwardRef = (props, ref) => {
    return React.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  return React.forwardRef(forwardRef);
};
const defineCustomElement = (tagName, customElement) => {
  if (customElement !== void 0 && typeof customElements !== "undefined" && !customElements.get(tagName)) {
    customElements.define(tagName, customElement);
  }
};
const createReactComponent = (tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement2) => {
  if (defineCustomElement2 !== void 0) {
    defineCustomElement2();
  }
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props) {
      super(props);
      this.setComponentElRef = (element) => {
        this.componentEl = element;
      };
    }
    componentDidMount() {
      this.componentDidUpdate(this.props);
    }
    componentDidUpdate(prevProps) {
      attachProps(this.componentEl, this.props, prevProps);
    }
    render() {
      const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
      let propsToPass = Object.keys(cProps).reduce((acc, name) => {
        const value = cProps[name];
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (typeof document !== "undefined" && isCoveredByReact(eventName)) {
            acc[name] = value;
          }
        } else {
          const type = typeof value;
          if (type === "string" || type === "boolean" || type === "number") {
            acc[camelToDashCase(name)] = value;
          }
        }
        return acc;
      }, {});
      if (manipulatePropsFunction) {
        propsToPass = manipulatePropsFunction(this.props, propsToPass);
      }
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: mergeRefs(forwardedRef, this.setComponentElRef), style });
      return reactExports.createElement(tagName, newProps, children);
    }
    static get displayName() {
      return displayName;
    }
  };
  if (ReactComponentContext) {
    ReactComponent.contextType = ReactComponentContext;
  }
  return createForwardRef$1(ReactComponent, displayName);
};
const IonButtons = /* @__PURE__ */ createReactComponent("ion-buttons", void 0, void 0, defineCustomElement$x);
const IonCol = /* @__PURE__ */ createReactComponent("ion-col", void 0, void 0, defineCustomElement$v);
const IonContent = /* @__PURE__ */ createReactComponent("ion-content", void 0, void 0, defineCustomElement$u);
const IonFooter = /* @__PURE__ */ createReactComponent("ion-footer", void 0, void 0, defineCustomElement$r);
const IonGrid = /* @__PURE__ */ createReactComponent("ion-grid", void 0, void 0, defineCustomElement$q);
const IonHeader = /* @__PURE__ */ createReactComponent("ion-header", void 0, void 0, defineCustomElement$p);
const IonLabel = /* @__PURE__ */ createReactComponent("ion-label", void 0, void 0, defineCustomElement$n);
const IonList = /* @__PURE__ */ createReactComponent("ion-list", void 0, void 0, defineCustomElement$l);
const IonNote = /* @__PURE__ */ createReactComponent("ion-note", void 0, void 0, defineCustomElement$j);
const IonProgressBar = /* @__PURE__ */ createReactComponent("ion-progress-bar", void 0, void 0, defineCustomElement$i);
const IonRow = /* @__PURE__ */ createReactComponent("ion-row", void 0, void 0, defineCustomElement$h);
const IonSearchbar = /* @__PURE__ */ createReactComponent("ion-searchbar", void 0, void 0, defineCustomElement$g);
const IonSegment = /* @__PURE__ */ createReactComponent("ion-segment", void 0, void 0, defineCustomElement$f);
const IonSegmentButton = /* @__PURE__ */ createReactComponent("ion-segment-button", void 0, void 0, defineCustomElement$e);
const IonSpinner = /* @__PURE__ */ createReactComponent("ion-spinner", void 0, void 0, defineCustomElement$c);
const IonTitle = /* @__PURE__ */ createReactComponent("ion-title", void 0, void 0, defineCustomElement$b);
const IonToggle = /* @__PURE__ */ createReactComponent("ion-toggle", void 0, void 0, defineCustomElement$a);
const IonToolbar = /* @__PURE__ */ createReactComponent("ion-toolbar", void 0, void 0, defineCustomElement$9);
const createForwardRef = (ReactComponent, displayName) => {
  const forwardRef = (props, ref) => {
    return React.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  return React.forwardRef(forwardRef);
};
const getConfig = () => {
  if (typeof window !== "undefined") {
    const Ionic = window.Ionic;
    if (Ionic && Ionic.config) {
      return Ionic.config;
    }
  }
  return null;
};
const createRoutingComponent = (tagName, customElement) => {
  defineCustomElement(tagName, customElement);
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props) {
      super(props);
      this.handleClick = (e2) => {
        const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;
        if (routerLink !== void 0) {
          e2.preventDefault();
          this.context.navigate(routerLink, routerDirection, void 0, routerAnimation, routerOptions);
        }
      };
      this.ref = React.createRef();
      this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
    }
    componentDidMount() {
      this.componentDidUpdate(this.props);
    }
    componentDidUpdate(prevProps) {
      const node = this.ref.current;
      attachProps(node, this.props, prevProps);
    }
    render() {
      const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
      const propsToPass = Object.keys(cProps).reduce((acc, name) => {
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (isCoveredByReact(eventName)) {
            acc[name] = cProps[name];
          }
        } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
          acc[camelToDashCase(name)] = cProps[name];
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
      if (this.props.routerLink && !this.props.href) {
        newProps.href = this.props.routerLink;
      }
      if (newProps.onClick) {
        const oldClick = newProps.onClick;
        newProps.onClick = (e2) => {
          oldClick(e2);
          if (!e2.defaultPrevented) {
            this.handleClick(e2);
          }
        };
      } else {
        newProps.onClick = this.handleClick;
      }
      return reactExports.createElement(tagName, newProps, children);
    }
    static get displayName() {
      return displayName;
    }
    static get contextType() {
      return NavContext;
    }
  };
  return createForwardRef(ReactComponent, displayName);
};
const IonButton = /* @__PURE__ */ createRoutingComponent("ion-button", IonButton$1);
const IonItem = /* @__PURE__ */ createRoutingComponent("ion-item", IonItem$1);
const detachProps = (node, props) => {
  if (node instanceof Element) {
    Object.keys(props).forEach((name) => {
      if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
        const eventName = name.substring(2);
        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
        if (!isCoveredByReact(eventNameLc)) {
          detachEvent(node, eventNameLc);
        }
      }
    });
  }
};
const detachEvent = (node, eventName) => {
  const eventStore = node.__events || (node.__events = {});
  const eventHandler = eventStore[eventName];
  if (eventHandler) {
    node.removeEventListener(eventName, eventHandler);
    eventStore[eventName] = void 0;
  }
};
const createInlineOverlayComponent = (tagName, defineCustomElement2, hasDelegateHost) => {
  if (defineCustomElement2) {
    defineCustomElement2();
  }
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props) {
      super(props);
      this.handleIonMount = () => {
        this.setState({ isOpen: true });
      };
      this.handleWillPresent = (evt) => {
        this.setState({ isOpen: true });
        this.props.onWillPresent && this.props.onWillPresent(evt);
      };
      this.handleDidDismiss = (evt) => {
        const wrapper = this.wrapperRef.current;
        const el2 = this.ref.current;
        if (wrapper && el2) {
          el2.append(wrapper);
          this.setState({ isOpen: false });
        }
        this.props.onDidDismiss && this.props.onDidDismiss(evt);
      };
      this.ref = React.createRef();
      this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
      this.state = { isOpen: false };
      this.wrapperRef = React.createRef();
    }
    componentDidMount() {
      var _a, _b, _c;
      this.componentDidUpdate(this.props);
      (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener("ionMount", this.handleIonMount);
      (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener("willPresent", this.handleWillPresent);
      (_c = this.ref.current) === null || _c === void 0 ? void 0 : _c.addEventListener("didDismiss", this.handleDidDismiss);
    }
    componentDidUpdate(prevProps) {
      const node = this.ref.current;
      const _a = this.props, cProps = __rest(_a, ["onDidDismiss", "onWillPresent"]);
      attachProps(node, cProps, prevProps);
    }
    componentWillUnmount() {
      const node = this.ref.current;
      if (node && this.state.isOpen) {
        node.removeEventListener("didDismiss", this.handleDidDismiss);
        node.remove();
        detachProps(node, this.props);
      }
    }
    render() {
      const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
      const propsToPass = Object.keys(cProps).reduce((acc, name) => {
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (isCoveredByReact(eventName)) {
            acc[name] = cProps[name];
          }
        } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
          acc[camelToDashCase(name)] = cProps[name];
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
      const getWrapperClasses = () => {
        if (hasDelegateHost) {
          return `${DELEGATE_HOST} ion-page`;
        }
        return DELEGATE_HOST;
      };
      return reactExports.createElement("template", {}, reactExports.createElement(
        tagName,
        newProps,
        /**
         * We only want the inner component
         * to be mounted if the overlay is open,
         * so conditionally render the component
         * based on the isOpen state.
         */
        this.state.isOpen || this.props.keepContentsMounted ? reactExports.createElement("div", {
          ref: this.wrapperRef,
          className: getWrapperClasses()
        }, children) : null
      ));
    }
    static get displayName() {
      return displayName;
    }
  };
  return createForwardRef(ReactComponent, displayName);
};
const DELEGATE_HOST = "ion-delegate-host";
const IonAlert = /* @__PURE__ */ createInlineOverlayComponent("ion-alert", defineCustomElement$8);
const IonModal = /* @__PURE__ */ createInlineOverlayComponent("ion-modal", defineCustomElement$7, true);
const IonContext = React.createContext({
  addOverlay: () => {
    return;
  },
  removeOverlay: () => {
    return;
  }
});
const IonOverlayManager = ({ onAddOverlay, onRemoveOverlay }) => {
  const [overlays, setOverlays] = reactExports.useState({});
  const overlaysRef = reactExports.useRef({});
  reactExports.useEffect(() => {
    onAddOverlay(addOverlay);
    onRemoveOverlay(removeOverlay);
  }, []);
  const addOverlay = (id2, component, containerElement) => {
    const newOverlays = Object.assign({}, overlaysRef.current);
    newOverlays[id2] = { component, containerElement };
    overlaysRef.current = newOverlays;
    setOverlays(newOverlays);
  };
  const removeOverlay = (id2) => {
    const newOverlays = Object.assign({}, overlaysRef.current);
    delete newOverlays[id2];
    overlaysRef.current = newOverlays;
    setOverlays(newOverlays);
  };
  const overlayKeys = Object.keys(overlays);
  return React.createElement(React.Fragment, null, overlayKeys.map((key) => {
    const overlay = overlays[key];
    return ReactDOM.createPortal(overlay.component, overlay.containerElement, `overlay-${key}`);
  }));
};
const IonTabButtonInner = /* @__PURE__ */ createReactComponent("ion-tab-button", void 0, void 0, defineCustomElement$3);
const IonTabBarInner = /* @__PURE__ */ createReactComponent("ion-tab-bar", void 0, void 0, defineCustomElement$4);
const IonRouterOutletInner = /* @__PURE__ */ createReactComponent("ion-router-outlet", void 0, void 0, defineCustomElement$5);
const IonAppInner = /* @__PURE__ */ createReactComponent("ion-app", void 0, void 0, defineCustomElement$6);
const IonIconInner = /* @__PURE__ */ createReactComponent("ion-icon", void 0, void 0, defineCustomElement$2);
const IonApp = /* @__PURE__ */ (() => class extends React.Component {
  constructor(props) {
    super(props);
    this.ionContext = {
      addOverlay: (id2, overlay, containerElement) => {
        if (this.addOverlayCallback) {
          this.addOverlayCallback(id2, overlay, containerElement);
        }
      },
      removeOverlay: (id2) => {
        if (this.removeOverlayCallback) {
          this.removeOverlayCallback(id2);
        }
      }
    };
  }
  render() {
    return React.createElement(
      IonContext.Provider,
      { value: this.ionContext },
      React.createElement(IonAppInner, Object.assign({}, this.props), this.props.children),
      React.createElement(IonOverlayManager, { onAddOverlay: (callback) => {
        this.addOverlayCallback = callback;
      }, onRemoveOverlay: (callback) => {
        this.removeOverlayCallback = callback;
      } })
    );
  }
  static get displayName() {
    return "IonApp";
  }
})();
const StackContext = React.createContext({
  registerIonPage: () => void 0,
  isInOutlet: () => false
});
class PageManager extends React.PureComponent {
  constructor(props) {
    super(props);
    this.ionPageElementRef = React.createRef();
    this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);
    this.ionViewWillEnterHandler = this.ionViewWillEnterHandler.bind(this);
    this.ionViewDidEnterHandler = this.ionViewDidEnterHandler.bind(this);
    this.ionViewWillLeaveHandler = this.ionViewWillLeaveHandler.bind(this);
    this.ionViewDidLeaveHandler = this.ionViewDidLeaveHandler.bind(this);
  }
  componentDidMount() {
    if (this.ionPageElementRef.current) {
      if (this.context.isInOutlet()) {
        this.ionPageElementRef.current.classList.add("ion-page-invisible");
      }
      this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);
      this.ionPageElementRef.current.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler);
      this.ionPageElementRef.current.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler);
      this.ionPageElementRef.current.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler);
      this.ionPageElementRef.current.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler);
    }
  }
  componentWillUnmount() {
    if (this.ionPageElementRef.current) {
      this.ionPageElementRef.current.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler);
      this.ionPageElementRef.current.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler);
      this.ionPageElementRef.current.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler);
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = __rest(_a, ["className", "children", "routeInfo", "forwardedRef"]);
    return React.createElement(IonLifeCycleContext.Consumer, null, (context) => {
      this.ionLifeCycleContext = context;
      return React.createElement("div", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props), children);
    });
  }
  static get contextType() {
    return StackContext;
  }
}
class IonPageInternal extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const _a = this.props, { className, children, forwardedRef } = _a, props = __rest(_a, ["className", "children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? React.createElement(PageManager, Object.assign({ className: className ? `${className}` : "", routeInfo: this.context.routeInfo, forwardedRef }, props), children) : React.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : "ion-page", ref: forwardedRef }, props), children);
  }
  static get displayName() {
    return "IonPage";
  }
  static get contextType() {
    return NavContext;
  }
}
const IonPage = createForwardRef(IonPageInternal, "IonPage");
const ids = { main: 0 };
const generateId = (type = "main") => {
  var _a;
  const id2 = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
  ids[type] = id2;
  return id2.toString();
};
const ReactDelegate = (addView, removeView) => {
  const refMap = /* @__PURE__ */ new WeakMap();
  const reactDelegateId = `react-delegate-${generateId()}`;
  let id2 = 0;
  const attachViewToDom = async (parentElement, component, propsOrDataObj, cssClasses) => {
    const div = document.createElement("div");
    cssClasses && div.classList.add(...cssClasses);
    parentElement.appendChild(div);
    const componentWithProps = component(propsOrDataObj);
    const key = `${reactDelegateId}-${id2++}`;
    const hostComponent = reactDomExports.createPortal(componentWithProps, div, key);
    refMap.set(div, hostComponent);
    addView(hostComponent);
    return Promise.resolve(div);
  };
  const removeViewFromDom = (_container, component) => {
    const hostComponent = refMap.get(component);
    hostComponent && removeView(hostComponent);
    component.remove();
    return Promise.resolve();
  };
  return {
    attachViewToDom,
    removeViewFromDom
  };
};
const IonNavInner = createReactComponent("ion-nav", void 0, void 0, defineCustomElement$k);
const IonNavInternal = (_a) => {
  var { children, forwardedRef } = _a, restOfProps = __rest(_a, ["children", "forwardedRef"]);
  const [views, setViews] = reactExports.useState([]);
  const addView = (view) => setViews((existingViews) => [...existingViews, view]);
  const removeView = (view) => setViews((existingViews) => existingViews.filter((v2) => v2 !== view));
  const delegate = reactExports.useMemo(() => ReactDelegate(addView, removeView), []);
  return React.createElement(IonNavInner, Object.assign({ delegate, ref: forwardedRef }, restOfProps), views);
};
createForwardRef(IonNavInternal, "IonNav");
React.createContext({
  activeTab: void 0,
  selectTab: () => false
});
const HTMLElementSSR = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class OutletPageManager extends React.Component {
  constructor(props) {
    super(props);
    this.outletIsReady = false;
    this.ionViewWillEnterHandler = this.ionViewWillEnterHandler.bind(this);
    this.ionViewDidEnterHandler = this.ionViewDidEnterHandler.bind(this);
    this.ionViewWillLeaveHandler = this.ionViewWillLeaveHandler.bind(this);
    this.ionViewDidLeaveHandler = this.ionViewDidLeaveHandler.bind(this);
  }
  componentDidMount() {
    if (this.ionRouterOutlet) {
      if (!this.outletIsReady) {
        componentOnReady(this.ionRouterOutlet, () => {
          this.outletIsReady = true;
          this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);
        });
      }
      this.ionRouterOutlet.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler);
      this.ionRouterOutlet.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler);
      this.ionRouterOutlet.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler);
      this.ionRouterOutlet.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler);
    }
  }
  componentWillUnmount() {
    if (this.ionRouterOutlet) {
      this.ionRouterOutlet.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler);
      this.ionRouterOutlet.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler);
      this.ionRouterOutlet.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler);
      this.ionRouterOutlet.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler);
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a = this.props, { StackManager, children, routeInfo } = _a, props = __rest(_a, ["StackManager", "children", "routeInfo"]);
    return React.createElement(IonLifeCycleContext.Consumer, null, (context) => {
      this.ionLifeCycleContext = context;
      return React.createElement(
        StackManager,
        { routeInfo },
        React.createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => this.ionRouterOutlet = val }, props), children)
      );
    });
  }
  static get contextType() {
    return StackContext;
  }
}
class IonRouterOutletContainer extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const StackManager = this.context.getStackManager();
    const _a = this.props, { children, forwardedRef } = _a, props = __rest(_a, ["children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? props.ionPage ? React.createElement(OutletPageManager, Object.assign({ StackManager, routeInfo: this.context.routeInfo }, props), children) : React.createElement(
      StackManager,
      { routeInfo: this.context.routeInfo },
      React.createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef }), children)
    ) : React.createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
}
createForwardRef(IonRouterOutletContainer, "IonRouterOutlet");
const IonTabButton = /* @__PURE__ */ (() => class extends React.Component {
  constructor(props) {
    super(props);
    this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);
  }
  handleIonTabButtonClick() {
    if (this.props.onClick) {
      this.props.onClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          tab: this.props.tab,
          href: this.props.href,
          routeOptions: this.props.routerOptions
        }
      }));
    }
  }
  render() {
    const _a = this.props, rest = __rest(_a, ["onClick"]);
    return React.createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest));
  }
  static get displayName() {
    return "IonTabButton";
  }
})();
class IonTabBarUnwrapped extends React.PureComponent {
  constructor(props) {
    super(props);
    this.setActiveTabOnContext = (_tab) => {
    };
    const tabs = {};
    React.Children.forEach(props.children, (child) => {
      var _a, _b, _c, _d;
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        tabs[child.props.tab] = {
          originalHref: child.props.href,
          currentHref: child.props.href,
          originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : void 0,
          currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname) ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : void 0
        };
      }
    });
    this.state = {
      tabs
    };
    this.onTabButtonClick = this.onTabButtonClick.bind(this);
    this.renderTabButton = this.renderTabButton.bind(this);
    this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);
    this.selectTab = this.selectTab.bind(this);
  }
  componentDidMount() {
    const tabs = this.state.tabs;
    const tabKeys = Object.keys(tabs);
    const activeTab = tabKeys.find((key) => {
      const href = tabs[key].originalHref;
      return this.props.routeInfo.pathname.startsWith(href);
    });
    if (activeTab) {
      this.setState({
        activeTab
      });
    }
  }
  componentDidUpdate() {
    if (this.state.activeTab) {
      this.setActiveTabOnContext(this.state.activeTab);
    }
  }
  selectTab(tab) {
    const tabUrl = this.state.tabs[tab];
    if (tabUrl) {
      this.onTabButtonClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          href: tabUrl.currentHref,
          tab,
          selected: tab === this.state.activeTab,
          routeOptions: void 0
        }
      }));
      return true;
    }
    return false;
  }
  static getDerivedStateFromProps(props, state) {
    var _a, _b, _c;
    const tabs = Object.assign({}, state.tabs);
    const tabKeys = Object.keys(state.tabs);
    const activeTab = tabKeys.find((key) => {
      const href = state.tabs[key].originalHref;
      return props.routeInfo.pathname.startsWith(href);
    });
    React.Children.forEach(props.children, (child) => {
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const tab = tabs[child.props.tab];
        if (!tab || tab.originalHref !== child.props.href) {
          tabs[child.props.tab] = {
            originalHref: child.props.href,
            currentHref: child.props.href,
            originalRouteOptions: child.props.routeOptions,
            currentRouteOptions: child.props.routeOptions
          };
        }
      }
    });
    const { activeTab: prevActiveTab } = state;
    if (activeTab && prevActiveTab) {
      const prevHref = state.tabs[prevActiveTab].currentHref;
      const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;
      if (activeTab !== prevActiveTab || prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) || prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {
        tabs[activeTab] = {
          originalHref: tabs[activeTab].originalHref,
          currentHref: props.routeInfo.pathname + (props.routeInfo.search || ""),
          originalRouteOptions: tabs[activeTab].originalRouteOptions,
          currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions
        };
        if (props.routeInfo.routeAction === "pop" && activeTab !== prevActiveTab) {
          tabs[prevActiveTab] = {
            originalHref: tabs[prevActiveTab].originalHref,
            currentHref: tabs[prevActiveTab].originalHref,
            originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,
            currentRouteOptions: tabs[prevActiveTab].currentRouteOptions
          };
        }
      }
    }
    activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);
    return {
      activeTab,
      tabs
    };
  }
  onTabButtonClick(e2, onClickFn) {
    const tappedTab = this.state.tabs[e2.detail.tab];
    const originalHref = tappedTab.originalHref;
    const currentHref = e2.detail.href;
    const { activeTab: prevActiveTab } = this.state;
    if (onClickFn) {
      onClickFn(e2);
    }
    if (prevActiveTab === e2.detail.tab) {
      if (originalHref !== currentHref) {
        this.context.resetTab(e2.detail.tab, originalHref, tappedTab.originalRouteOptions);
      }
    } else {
      if (this.props.onIonTabsWillChange) {
        this.props.onIonTabsWillChange(new CustomEvent("ionTabWillChange", { detail: { tab: e2.detail.tab } }));
      }
      if (this.props.onIonTabsDidChange) {
        this.props.onIonTabsDidChange(new CustomEvent("ionTabDidChange", { detail: { tab: e2.detail.tab } }));
      }
      this.setActiveTabOnContext(e2.detail.tab);
      this.context.changeTab(e2.detail.tab, currentHref, e2.detail.routeOptions);
    }
  }
  renderTabButton(activeTab) {
    return (child) => {
      var _a, _b;
      if (child != null && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const href = child.props.tab === activeTab ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;
        const routeOptions = child.props.tab === activeTab ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;
        return React.cloneElement(child, {
          href,
          routeOptions,
          onClick: (ev) => this.onTabButtonClick(ev, child.props.onClick)
        });
      }
      return null;
    };
  }
  render() {
    const { activeTab } = this.state;
    return React.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), React.Children.map(this.props.children, this.renderTabButton(activeTab)));
  }
  static get contextType() {
    return NavContext;
  }
}
const IonTabBarContainer = React.memo((_a) => {
  var { forwardedRef } = _a, props = __rest(_a, ["forwardedRef"]);
  const context = reactExports.useContext(NavContext);
  return React.createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props, { routeInfo: props.routeInfo || context.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context.setCurrentTab }), props.children);
});
createForwardRef(IonTabBarContainer, "IonTabBar");
class IonTabsElement extends HTMLElementSSR {
  constructor() {
    super();
  }
}
if (typeof window !== "undefined" && window.customElements) {
  const element = window.customElements.get("ion-tabs");
  if (!element) {
    window.customElements.define("ion-tabs", IonTabsElement);
  }
}
class IonIconContainer extends React.PureComponent {
  constructor(props) {
    super(props);
    if (this.props.name) {
      console.warn('In Ionic React, you import icons from "ionicons/icons" and set the icon you imported to the "icon" property. Setting the "name" property has no effect.');
    }
  }
  render() {
    var _a, _b;
    const _c = this.props, { icon, ios, md: md2, mode } = _c, rest = __rest(_c, ["icon", "ios", "md", "mode"]);
    let iconToUse;
    const config2 = getConfig();
    const iconMode = mode || (config2 === null || config2 === void 0 ? void 0 : config2.get("mode"));
    if (ios || md2) {
      if (iconMode === "ios") {
        iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md2) !== null && _a !== void 0 ? _a : icon;
      } else {
        iconToUse = (_b = md2 !== null && md2 !== void 0 ? md2 : ios) !== null && _b !== void 0 ? _b : icon;
      }
    } else {
      iconToUse = icon;
    }
    return React.createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
}
const IonIcon = createForwardRef(IonIconContainer, "IonIcon");
class IonRoute extends React.PureComponent {
  render() {
    const IonRouteInner = this.context.getIonRoute();
    if (!this.context.hasIonicRouter() || !IonRoute) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRoute>");
      return null;
    }
    return React.createElement(IonRouteInner, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
}
class IonRedirect extends React.PureComponent {
  render() {
    const IonRedirectInner = this.context.getIonRedirect();
    if (!this.context.hasIonicRouter() || !IonRedirect) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRedirect>");
      return null;
    }
    return React.createElement(IonRedirectInner, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
}
const IonRouterContext = React.createContext({
  routeInfo: void 0,
  push: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  back: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  canGoBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  nativeBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  }
});
class CreateAnimation extends React.PureComponent {
  constructor(props) {
    super(props);
    this.nodes = /* @__PURE__ */ new Map();
    this.animation = createAnimation(props.id);
  }
  setupAnimation(props) {
    const animation2 = this.animation;
    if (this.nodes.size > 0) {
      animation2.addElement(Array.from(this.nodes.values()));
    }
    checkConfig(animation2, props);
    checkPlayback(animation2, props);
  }
  componentDidMount() {
    const props = this.props;
    this.setupAnimation(props);
  }
  componentDidUpdate(prevProps) {
    const animation2 = this.animation;
    const props = this.props;
    checkConfig(animation2, props, prevProps);
    checkProgress(animation2, props, prevProps);
    checkPlayback(animation2, props, prevProps);
  }
  render() {
    const { children } = this.props;
    return React.createElement(React.Fragment, null, React.Children.map(children, (child, id2) => React.cloneElement(child, { ref: (el2) => this.nodes.set(id2, el2) })));
  }
}
const checkConfig = (animation2, currentProps = {}, prevProps = {}) => {
  const reservedProps = [
    "children",
    "progressStart",
    "progressStep",
    "progressEnd",
    "pause",
    "stop",
    "destroy",
    "play",
    "from",
    "to",
    "fromTo",
    "onFinish"
  ];
  for (const key in currentProps) {
    if (
      // eslint-disable-next-line no-prototype-builtins
      currentProps.hasOwnProperty(key) && !reservedProps.includes(key) && currentProps[key] !== prevProps[key]
    ) {
      animation2[key](currentProps[key]);
    }
  }
  const fromValues = currentProps.from;
  if (fromValues && fromValues !== prevProps.from) {
    const values = Array.isArray(fromValues) ? fromValues : [fromValues];
    values.forEach((val) => animation2.from(val.property, val.value));
  }
  const toValues = currentProps.to;
  if (toValues && toValues !== prevProps.to) {
    const values = Array.isArray(toValues) ? toValues : [toValues];
    values.forEach((val) => animation2.to(val.property, val.value));
  }
  const fromToValues = currentProps.fromTo;
  if (fromToValues && fromToValues !== prevProps.fromTo) {
    const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];
    values.forEach((val) => animation2.fromTo(val.property, val.fromValue, val.toValue));
  }
  const onFinishValues = currentProps.onFinish;
  if (onFinishValues && onFinishValues !== prevProps.onFinish) {
    const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];
    values.forEach((val) => animation2.onFinish(val.callback, val.opts));
  }
};
const checkProgress = (animation2, currentProps = {}, prevProps = {}) => {
  var _a, _b, _c, _d, _e;
  const { progressStart, progressStep, progressEnd } = currentProps;
  if (progressStart && (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) || ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {
    animation2.progressStart(progressStart.forceLinearEasing, progressStart.step);
  }
  if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {
    animation2.progressStep(progressStep.step);
  }
  if (progressEnd && (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) || ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {
    animation2.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);
  }
};
const checkPlayback = (animation2, currentProps = {}, prevProps = {}) => {
  if (!prevProps.play && currentProps.play) {
    animation2.play();
  }
  if (!prevProps.pause && currentProps.pause) {
    animation2.pause();
  }
  if (!prevProps.stop && currentProps.stop) {
    animation2.stop();
  }
  if (!prevProps.destroy && currentProps.destroy) {
    animation2.destroy();
  }
};
const setupIonicReact = (config2 = {}) => {
  if (typeof document !== "undefined") {
    document.documentElement.classList.add("ion-ce");
  }
  initialize(Object.assign({}, config2));
};
class ViewLifeCycleManager extends React.Component {
  constructor(props) {
    super(props);
    this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
    this._isMounted = false;
    this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
      if (!this.props.mount) {
        if (this._isMounted) {
          this.setState({
            show: false
          }, () => this.props.removeView());
        }
      }
    });
    this.state = {
      show: true
    };
  }
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
  render() {
    const { show } = this.state;
    return React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children);
  }
}
class NavManager extends React.PureComponent {
  constructor(props) {
    super(props);
    this.ionRouterContextValue = {
      push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {
        this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);
      },
      back: (animationBuilder) => {
        this.goBack(void 0, animationBuilder);
      },
      canGoBack: () => this.props.locationHistory.canGoBack(),
      nativeBack: () => this.props.onNativeBack(),
      routeInfo: this.props.routeInfo
    };
    this.state = {
      goBack: this.goBack.bind(this),
      hasIonicRouter: () => true,
      navigate: this.navigate.bind(this),
      getIonRedirect: this.getIonRedirect.bind(this),
      getIonRoute: this.getIonRoute.bind(this),
      getStackManager: this.getStackManager.bind(this),
      getPageManager: this.getPageManager.bind(this),
      routeInfo: this.props.routeInfo,
      setCurrentTab: this.props.onSetCurrentTab,
      changeTab: this.props.onChangeTab,
      resetTab: this.props.onResetTab
    };
  }
  componentDidMount() {
    if (typeof document !== "undefined") {
      this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);
      document.addEventListener("ionBackButton", this.handleHardwareBackButton);
    }
  }
  componentWillUnmount() {
    if (typeof document !== "undefined") {
      document.removeEventListener("ionBackButton", this.handleHardwareBackButton);
    }
  }
  handleHardwareBackButton(e2) {
    e2.detail.register(0, (processNextHandler) => {
      this.nativeGoBack();
      processNextHandler();
    });
  }
  goBack(route, animationBuilder) {
    this.props.onNavigateBack(route, animationBuilder);
  }
  nativeGoBack() {
    this.props.onNativeBack();
  }
  navigate(path2, direction = "forward", action = "push", animationBuilder, options, tab) {
    this.props.onNavigate(path2, action, direction, animationBuilder, options, tab);
  }
  getPageManager() {
    return PageManager;
  }
  getIonRedirect() {
    return this.props.ionRedirect;
  }
  getIonRoute() {
    return this.props.ionRoute;
  }
  getStackManager() {
    return this.props.stackManager;
  }
  render() {
    return React.createElement(
      NavContext.Provider,
      { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) },
      React.createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children)
    );
  }
}
const Loading = () => {
  return /* @__PURE__ */ React.createElement("div", { className: "loading-page" }, /* @__PURE__ */ React.createElement(IonSpinner, { name: "crescent" }), /* @__PURE__ */ React.createElement("h1", null, "Loading..."), /* @__PURE__ */ React.createElement(IonProgressBar, { color: "success", value: 0 }));
};
const SectionDivider = () => {
  return /* @__PURE__ */ React.createElement("div", { className: "division" });
};
const DarkModeContext = reactExports.createContext();
const DarkModeProvider = ({ children }) => {
  const [darkMode, setDarkMode] = reactExports.useState(true);
  const toggleDarkMode = () => {
    setDarkMode((prevMode) => !prevMode);
  };
  return /* @__PURE__ */ React.createElement(DarkModeContext.Provider, { value: { darkMode, toggleDarkMode } }, children);
};
const useDarkMode = () => {
  const context = reactExports.useContext(DarkModeContext);
  if (!context) {
    throw new Error("useDarkMode must be used within a DarkModeProvider");
  }
  return context;
};
const GridItem = ({ character, pronunciation, onClick, level }) => {
  const { darkMode } = useDarkMode();
  const handleOnClick = (character2, pronunciation2) => {
    if (level > 0) {
      onClick({ character: character2, pronunciation: pronunciation2, level });
    }
  };
  return /* @__PURE__ */ React.createElement("div", { className: "grid-item", onClick: () => handleOnClick(character, pronunciation), style: { borderColor: level > 0 ? darkMode ? "#FFFFFF" : "#08a391" : darkMode ? "#262130" : "lightsteelblue" } }, /* @__PURE__ */ React.createElement("b", null, character), /* @__PURE__ */ React.createElement("br", null), pronunciation, /* @__PURE__ */ React.createElement(IonProgressBar, { value: level / 20 }));
};
const search = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M456.69 421.39L362.6 327.3a173.81 173.81 0 0034.84-104.58C397.44 126.38 319.06 48 222.72 48S48 126.38 48 222.72s78.38 174.72 174.72 174.72A173.81 173.81 0 00327.3 362.6l94.09 94.09a25 25 0 0035.3-35.3zM97.92 222.72a124.8 124.8 0 11124.8 124.8 124.95 124.95 0 01-124.8-124.8z'/></svg>";
const settings = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><circle cx='256' cy='256' r='48'/><path d='M470.39 300l-.47-.38-31.56-24.75a16.11 16.11 0 01-6.1-13.33v-11.56a16 16 0 016.11-13.22L469.92 212l.47-.38a26.68 26.68 0 005.9-34.06l-42.71-73.9a1.59 1.59 0 01-.13-.22A26.86 26.86 0 00401 92.14l-.35.13-37.1 14.93a15.94 15.94 0 01-14.47-1.29q-4.92-3.1-10-5.86a15.94 15.94 0 01-8.19-11.82l-5.59-39.59-.12-.72A27.22 27.22 0 00298.76 26h-85.52a26.92 26.92 0 00-26.45 22.39l-.09.56-5.57 39.67a16 16 0 01-8.13 11.82 175.21 175.21 0 00-10 5.82 15.92 15.92 0 01-14.43 1.27l-37.13-15-.35-.14a26.87 26.87 0 00-32.48 11.34l-.13.22-42.77 73.95a26.71 26.71 0 005.9 34.1l.47.38 31.56 24.75a16.11 16.11 0 016.1 13.33v11.56a16 16 0 01-6.11 13.22L42.08 300l-.47.38a26.68 26.68 0 00-5.9 34.06l42.71 73.9a1.59 1.59 0 01.13.22 26.86 26.86 0 0032.45 11.3l.35-.13 37.07-14.93a15.94 15.94 0 0114.47 1.29q4.92 3.11 10 5.86a15.94 15.94 0 018.19 11.82l5.56 39.59.12.72A27.22 27.22 0 00213.24 486h85.52a26.92 26.92 0 0026.45-22.39l.09-.56 5.57-39.67a16 16 0 018.18-11.82c3.42-1.84 6.76-3.79 10-5.82a15.92 15.92 0 0114.43-1.27l37.13 14.95.35.14a26.85 26.85 0 0032.48-11.34 2.53 2.53 0 01.13-.22l42.71-73.89a26.7 26.7 0 00-5.89-34.11zm-134.48-40.24a80 80 0 11-83.66-83.67 80.21 80.21 0 0183.66 83.67z'/></svg>";
const volumeHighOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M126 192H56a8 8 0 00-8 8v112a8 8 0 008 8h69.65a15.93 15.93 0 0110.14 3.54l91.47 74.89A8 8 0 00240 392V120a8 8 0 00-12.74-6.43l-91.47 74.89A15 15 0 01126 192zM320 320c9.74-19.38 16-40.84 16-64 0-23.48-6-44.42-16-64M368 368c19.48-33.92 32-64.06 32-112s-12-77.74-32-112M416 416c30-46 48-91.43 48-160s-18-113-48-160' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
/*! Capacitor: https://capacitorjs.com/ - MIT License */
const createCapacitorPlatforms = (win2) => {
  const defaultPlatformMap = /* @__PURE__ */ new Map();
  defaultPlatformMap.set("web", { name: "web" });
  const capPlatforms = win2.CapacitorPlatforms || {
    currentPlatform: { name: "web" },
    platforms: defaultPlatformMap
  };
  const addPlatform = (name, platform2) => {
    capPlatforms.platforms.set(name, platform2);
  };
  const setPlatform = (name) => {
    if (capPlatforms.platforms.has(name)) {
      capPlatforms.currentPlatform = capPlatforms.platforms.get(name);
    }
  };
  capPlatforms.addPlatform = addPlatform;
  capPlatforms.setPlatform = setPlatform;
  return capPlatforms;
};
const initPlatforms = (win2) => win2.CapacitorPlatforms = createCapacitorPlatforms(win2);
const CapacitorPlatforms = /* @__PURE__ */ initPlatforms(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
CapacitorPlatforms.addPlatform;
CapacitorPlatforms.setPlatform;
var ExceptionCode;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
class CapacitorException extends Error {
  constructor(message, code, data) {
    super(message);
    this.message = message;
    this.code = code;
    this.data = data;
  }
}
const getPlatformId = (win2) => {
  var _a, _b;
  if (win2 === null || win2 === void 0 ? void 0 : win2.androidBridge) {
    return "android";
  } else if ((_b = (_a = win2 === null || win2 === void 0 ? void 0 : win2.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
    return "ios";
  } else {
    return "web";
  }
};
const createCapacitor = (win2) => {
  var _a, _b, _c, _d, _e;
  const capCustomPlatform = win2.CapacitorCustomPlatform || null;
  const cap = win2.Capacitor || {};
  const Plugins = cap.Plugins = cap.Plugins || {};
  const capPlatforms = win2.CapacitorPlatforms;
  const defaultGetPlatform = () => {
    return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win2);
  };
  const getPlatform = ((_a = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _a === void 0 ? void 0 : _a.getPlatform) || defaultGetPlatform;
  const defaultIsNativePlatform = () => getPlatform() !== "web";
  const isNativePlatform = ((_b = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _b === void 0 ? void 0 : _b.isNativePlatform) || defaultIsNativePlatform;
  const defaultIsPluginAvailable = (pluginName) => {
    const plugin = registeredPlugins.get(pluginName);
    if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
      return true;
    }
    if (getPluginHeader(pluginName)) {
      return true;
    }
    return false;
  };
  const isPluginAvailable = ((_c = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _c === void 0 ? void 0 : _c.isPluginAvailable) || defaultIsPluginAvailable;
  const defaultGetPluginHeader = (pluginName) => {
    var _a2;
    return (_a2 = cap.PluginHeaders) === null || _a2 === void 0 ? void 0 : _a2.find((h2) => h2.name === pluginName);
  };
  const getPluginHeader = ((_d = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _d === void 0 ? void 0 : _d.getPluginHeader) || defaultGetPluginHeader;
  const handleError = (err) => win2.console.error(err);
  const pluginMethodNoop = (_target, prop, pluginName) => {
    return Promise.reject(`${pluginName} does not have an implementation of "${prop}".`);
  };
  const registeredPlugins = /* @__PURE__ */ new Map();
  const defaultRegisterPlugin = (pluginName, jsImplementations = {}) => {
    const registeredPlugin = registeredPlugins.get(pluginName);
    if (registeredPlugin) {
      console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
      return registeredPlugin.proxy;
    }
    const platform2 = getPlatform();
    const pluginHeader = getPluginHeader(pluginName);
    let jsImplementation;
    const loadPluginImplementation = async () => {
      if (!jsImplementation && platform2 in jsImplementations) {
        jsImplementation = typeof jsImplementations[platform2] === "function" ? jsImplementation = await jsImplementations[platform2]() : jsImplementation = jsImplementations[platform2];
      } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
        jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
      }
      return jsImplementation;
    };
    const createPluginMethod = (impl, prop) => {
      var _a2, _b2;
      if (pluginHeader) {
        const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m2) => prop === m2.name);
        if (methodHeader) {
          if (methodHeader.rtype === "promise") {
            return (options) => cap.nativePromise(pluginName, prop.toString(), options);
          } else {
            return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
          }
        } else if (impl) {
          return (_a2 = impl[prop]) === null || _a2 === void 0 ? void 0 : _a2.bind(impl);
        }
      } else if (impl) {
        return (_b2 = impl[prop]) === null || _b2 === void 0 ? void 0 : _b2.bind(impl);
      } else {
        throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform2}`, ExceptionCode.Unimplemented);
      }
    };
    const createPluginMethodWrapper = (prop) => {
      let remove;
      const wrapper = (...args) => {
        const p2 = loadPluginImplementation().then((impl) => {
          const fn = createPluginMethod(impl, prop);
          if (fn) {
            const p3 = fn(...args);
            remove = p3 === null || p3 === void 0 ? void 0 : p3.remove;
            return p3;
          } else {
            throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform2}`, ExceptionCode.Unimplemented);
          }
        });
        if (prop === "addListener") {
          p2.remove = async () => remove();
        }
        return p2;
      };
      wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
      Object.defineProperty(wrapper, "name", {
        value: prop,
        writable: false,
        configurable: false
      });
      return wrapper;
    };
    const addListener2 = createPluginMethodWrapper("addListener");
    const removeListener2 = createPluginMethodWrapper("removeListener");
    const addListenerNative = (eventName, callback) => {
      const call = addListener2({ eventName }, callback);
      const remove = async () => {
        const callbackId = await call;
        removeListener2({
          eventName,
          callbackId
        }, callback);
      };
      const p2 = new Promise((resolve2) => call.then(() => resolve2({ remove })));
      p2.remove = async () => {
        console.warn(`Using addListener() without 'await' is deprecated.`);
        await remove();
      };
      return p2;
    };
    const proxy = new Proxy({}, {
      get(_, prop) {
        switch (prop) {
          case "$$typeof":
            return void 0;
          case "toJSON":
            return () => ({});
          case "addListener":
            return pluginHeader ? addListenerNative : addListener2;
          case "removeListener":
            return removeListener2;
          default:
            return createPluginMethodWrapper(prop);
        }
      }
    });
    Plugins[pluginName] = proxy;
    registeredPlugins.set(pluginName, {
      name: pluginName,
      proxy,
      platforms: /* @__PURE__ */ new Set([
        ...Object.keys(jsImplementations),
        ...pluginHeader ? [platform2] : []
      ])
    });
    return proxy;
  };
  const registerPlugin2 = ((_e = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _e === void 0 ? void 0 : _e.registerPlugin) || defaultRegisterPlugin;
  if (!cap.convertFileSrc) {
    cap.convertFileSrc = (filePath) => filePath;
  }
  cap.getPlatform = getPlatform;
  cap.handleError = handleError;
  cap.isNativePlatform = isNativePlatform;
  cap.isPluginAvailable = isPluginAvailable;
  cap.pluginMethodNoop = pluginMethodNoop;
  cap.registerPlugin = registerPlugin2;
  cap.Exception = CapacitorException;
  cap.DEBUG = !!cap.DEBUG;
  cap.isLoggingEnabled = !!cap.isLoggingEnabled;
  cap.platform = cap.getPlatform();
  cap.isNative = cap.isNativePlatform();
  return cap;
};
const initCapacitorGlobal = (win2) => win2.Capacitor = createCapacitor(win2);
const Capacitor = /* @__PURE__ */ initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
const registerPlugin = Capacitor.registerPlugin;
Capacitor.Plugins;
class WebPlugin {
  constructor(config2) {
    this.listeners = {};
    this.windowListeners = {};
    if (config2) {
      console.warn(`Capacitor WebPlugin "${config2.name}" config object was deprecated in v3 and will be removed in v4.`);
      this.config = config2;
    }
  }
  addListener(eventName, listenerFunc) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      this.listeners[eventName] = [];
    }
    this.listeners[eventName].push(listenerFunc);
    const windowListener = this.windowListeners[eventName];
    if (windowListener && !windowListener.registered) {
      this.addWindowListener(windowListener);
    }
    const remove = async () => this.removeListener(eventName, listenerFunc);
    const p2 = Promise.resolve({ remove });
    Object.defineProperty(p2, "remove", {
      value: async () => {
        console.warn(`Using addListener() without 'await' is deprecated.`);
        await remove();
      }
    });
    return p2;
  }
  async removeAllListeners() {
    this.listeners = {};
    for (const listener in this.windowListeners) {
      this.removeWindowListener(this.windowListeners[listener]);
    }
    this.windowListeners = {};
  }
  notifyListeners(eventName, data) {
    const listeners = this.listeners[eventName];
    if (listeners) {
      listeners.forEach((listener) => listener(data));
    }
  }
  hasListeners(eventName) {
    return !!this.listeners[eventName].length;
  }
  registerWindowListener(windowEventName, pluginEventName) {
    this.windowListeners[pluginEventName] = {
      registered: false,
      windowEventName,
      pluginEventName,
      handler: (event) => {
        this.notifyListeners(pluginEventName, event);
      }
    };
  }
  unimplemented(msg = "not implemented") {
    return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
  }
  unavailable(msg = "not available") {
    return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
  }
  async removeListener(eventName, listenerFunc) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listenerFunc);
    this.listeners[eventName].splice(index, 1);
    if (!this.listeners[eventName].length) {
      this.removeWindowListener(this.windowListeners[eventName]);
    }
  }
  addWindowListener(handle) {
    window.addEventListener(handle.windowEventName, handle.handler);
    handle.registered = true;
  }
  removeWindowListener(handle) {
    if (!handle) {
      return;
    }
    window.removeEventListener(handle.windowEventName, handle.handler);
    handle.registered = false;
  }
}
const encode = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
const decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class CapacitorCookiesPluginWeb extends WebPlugin {
  async getCookies() {
    const cookies = document.cookie;
    const cookieMap = {};
    cookies.split(";").forEach((cookie) => {
      if (cookie.length <= 0)
        return;
      let [key, value] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
      key = decode(key).trim();
      value = decode(value).trim();
      cookieMap[key] = value;
    });
    return cookieMap;
  }
  async setCookie(options) {
    try {
      const encodedKey = encode(options.key);
      const encodedValue = encode(options.value);
      const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
      const path2 = (options.path || "/").replace("path=", "");
      const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : "";
      document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path2}; ${domain};`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async deleteCookie(options) {
    try {
      document.cookie = `${options.key}=; Max-Age=0`;
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearCookies() {
    try {
      const cookies = document.cookie.split(";") || [];
      for (const cookie of cookies) {
        document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${(/* @__PURE__ */ new Date()).toUTCString()};path=/`);
      }
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearAllCookies() {
    try {
      await this.clearCookies();
    } catch (error) {
      return Promise.reject(error);
    }
  }
}
registerPlugin("CapacitorCookies", {
  web: () => new CapacitorCookiesPluginWeb()
});
const readBlobAsBase64 = async (blob) => new Promise((resolve2, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    const base64String = reader.result;
    resolve2(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
  };
  reader.onerror = (error) => reject(error);
  reader.readAsDataURL(blob);
});
const normalizeHttpHeaders = (headers = {}) => {
  const originalKeys = Object.keys(headers);
  const loweredKeys = Object.keys(headers).map((k2) => k2.toLocaleLowerCase());
  const normalized = loweredKeys.reduce((acc, key, index) => {
    acc[key] = headers[originalKeys[index]];
    return acc;
  }, {});
  return normalized;
};
const buildUrlParams = (params, shouldEncode = true) => {
  if (!params)
    return null;
  const output = Object.entries(params).reduce((accumulator, entry) => {
    const [key, value] = entry;
    let encodedValue;
    let item;
    if (Array.isArray(value)) {
      item = "";
      value.forEach((str) => {
        encodedValue = shouldEncode ? encodeURIComponent(str) : str;
        item += `${key}=${encodedValue}&`;
      });
      item.slice(0, -1);
    } else {
      encodedValue = shouldEncode ? encodeURIComponent(value) : value;
      item = `${key}=${encodedValue}`;
    }
    return `${accumulator}&${item}`;
  }, "");
  return output.substr(1);
};
const buildRequestInit = (options, extra = {}) => {
  const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
  const headers = normalizeHttpHeaders(options.headers);
  const type = headers["content-type"] || "";
  if (typeof options.data === "string") {
    output.body = options.data;
  } else if (type.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.data || {})) {
      params.set(key, value);
    }
    output.body = params.toString();
  } else if (type.includes("multipart/form-data") || options.data instanceof FormData) {
    const form = new FormData();
    if (options.data instanceof FormData) {
      options.data.forEach((value, key) => {
        form.append(key, value);
      });
    } else {
      for (const key of Object.keys(options.data)) {
        form.append(key, options.data[key]);
      }
    }
    output.body = form;
    const headers2 = new Headers(output.headers);
    headers2.delete("content-type");
    output.headers = headers2;
  } else if (type.includes("application/json") || typeof options.data === "object") {
    output.body = JSON.stringify(options.data);
  }
  return output;
};
class CapacitorHttpPluginWeb extends WebPlugin {
  /**
   * Perform an Http request given a set of options
   * @param options Options to build the HTTP request
   */
  async request(options) {
    const requestInit = buildRequestInit(options, options.webFetchExtra);
    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
    const url = urlParams ? `${options.url}?${urlParams}` : options.url;
    const response = await fetch(url, requestInit);
    const contentType = response.headers.get("content-type") || "";
    let { responseType = "text" } = response.ok ? options : {};
    if (contentType.includes("application/json")) {
      responseType = "json";
    }
    let data;
    let blob;
    switch (responseType) {
      case "arraybuffer":
      case "blob":
        blob = await response.blob();
        data = await readBlobAsBase64(blob);
        break;
      case "json":
        data = await response.json();
        break;
      case "document":
      case "text":
      default:
        data = await response.text();
    }
    const headers = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });
    return {
      data,
      headers,
      status: response.status,
      url: response.url
    };
  }
  /**
   * Perform an Http GET request given a set of options
   * @param options Options to build the HTTP request
   */
  async get(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
  }
  /**
   * Perform an Http POST request given a set of options
   * @param options Options to build the HTTP request
   */
  async post(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
  }
  /**
   * Perform an Http PUT request given a set of options
   * @param options Options to build the HTTP request
   */
  async put(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
  }
  /**
   * Perform an Http PATCH request given a set of options
   * @param options Options to build the HTTP request
   */
  async patch(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
  }
  /**
   * Perform an Http DELETE request given a set of options
   * @param options Options to build the HTTP request
   */
  async delete(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
  }
}
registerPlugin("CapacitorHttp", {
  web: () => new CapacitorHttpPluginWeb()
});
const NativeAudio = registerPlugin("NativeAudio", {
  web: () => __vitePreload(() => import("./web-vbM328m3.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((m2) => new m2.NativeAudioWeb())
});
const ItemScreen = ({ character, pronunciation, level, isOpen, onClose }) => {
  const { darkMode } = useDarkMode();
  NativeAudio.preload({
    assetId: pronunciation,
    assetPath: `${pronunciation}.mp3`,
    audioChannelNum: 1,
    isUrl: false
  }).catch((error) => {
    console.error("Error playing audio:", error);
    console.log(pronunciation);
  });
  const playAudio = () => {
    NativeAudio.play({
      assetId: pronunciation
    }).catch((error) => {
      console.error("Error playing audio:", error);
      console.log(pronunciation);
    });
  };
  return /* @__PURE__ */ React.createElement(IonModal, { isOpen, onWillDismiss: onClose }, /* @__PURE__ */ React.createElement("div", { className: darkMode ? "itemscreen-content dark" : "itemscreen-content light" }, /* @__PURE__ */ React.createElement("h2", null, character), /* @__PURE__ */ React.createElement("p", null, "Pronunciation: ", pronunciation), /* @__PURE__ */ React.createElement(IonButton, { style: { width: "100%", marginTop: "50px" }, color: "primary", onClick: () => playAudio() }, /* @__PURE__ */ React.createElement(IonIcon, { icon: volumeHighOutline })), /* @__PURE__ */ React.createElement(IonProgressBar, { style: { marginTop: "50px" }, value: level / 20 }), /* @__PURE__ */ React.createElement(IonFooter, { style: { position: "fixed", bottom: "0", width: "100%", left: "0" } }, /* @__PURE__ */ React.createElement(IonToolbar, null, /* @__PURE__ */ React.createElement(IonButton, { onClick: onClose, style: { width: "100%", background: "white", height: "75px" }, color: "light", fill: "clear" }, /* @__PURE__ */ React.createElement(IonLabel, { style: { color: "black" } }, /* @__PURE__ */ React.createElement("b", null, "Close")))))));
};
const itemsPerRow$2 = 4;
const Hiragana = ({ data }) => {
  const [selectedCharacter, setSelectedCharacter] = reactExports.useState(null);
  const { darkMode } = useDarkMode();
  const handleGridItemClick = (character) => {
    setSelectedCharacter(character);
  };
  const handleCloseItem = () => {
    setSelectedCharacter(null);
  };
  return /* @__PURE__ */ React.createElement("div", { className: darkMode ? "mainSection dark" : "mainSection light" }, /* @__PURE__ */ React.createElement("h1", null, "Hiragana"), /* @__PURE__ */ React.createElement(SectionDivider, null), /* @__PURE__ */ React.createElement(IonContent, null, /* @__PURE__ */ React.createElement(IonGrid, { style: { marginBottom: "200px" } }, data && data.reduce((rows, item, index) => {
    if (index % itemsPerRow$2 === 0) {
      rows.push([]);
    }
    rows[rows.length - 1].push(item);
    return rows;
  }, []).map((row, rowIndex) => /* @__PURE__ */ React.createElement(IonRow, { key: rowIndex }, row.map((item, colIndex) => /* @__PURE__ */ React.createElement(IonCol, { key: colIndex }, /* @__PURE__ */ React.createElement(GridItem, { character: item.character, level: item.level, pronunciation: item.pronunciation, onClick: handleGridItemClick }))))))), selectedCharacter !== null && /* @__PURE__ */ React.createElement(
    ItemScreen,
    {
      isOpen: selectedCharacter !== null,
      onClose: handleCloseItem,
      character: selectedCharacter == null ? void 0 : selectedCharacter.character,
      pronunciation: selectedCharacter == null ? void 0 : selectedCharacter.pronunciation,
      level: selectedCharacter == null ? void 0 : selectedCharacter.level
    }
  ));
};
const itemsPerRow$1 = 4;
const Katakana = ({ data }) => {
  const [selectedCharacter, setSelectedCharacter] = reactExports.useState(null);
  const { darkMode } = useDarkMode();
  const handleGridItemClick = (character) => {
    setSelectedCharacter(character);
  };
  const handleCloseItem = () => {
    setSelectedCharacter(null);
  };
  return /* @__PURE__ */ React.createElement("div", { className: darkMode ? "mainSection dark" : "mainSection light" }, /* @__PURE__ */ React.createElement("h1", null, "Katakana"), /* @__PURE__ */ React.createElement(SectionDivider, null), /* @__PURE__ */ React.createElement(IonContent, null, /* @__PURE__ */ React.createElement(IonGrid, { style: { marginBottom: "200px" } }, data && data.reduce((rows, item, index) => {
    if (index % itemsPerRow$1 === 0) {
      rows.push([]);
    }
    rows[rows.length - 1].push(item);
    return rows;
  }, []).map((row, rowIndex) => /* @__PURE__ */ React.createElement(IonRow, { key: rowIndex }, row.map((item, colIndex) => /* @__PURE__ */ React.createElement(IonCol, { key: colIndex }, /* @__PURE__ */ React.createElement(GridItem, { character: item.character, level: item.level, pronunciation: item.pronunciation, onClick: handleGridItemClick }))))))), selectedCharacter !== null && /* @__PURE__ */ React.createElement(
    ItemScreen,
    {
      isOpen: selectedCharacter !== null,
      onClose: handleCloseItem,
      character: selectedCharacter == null ? void 0 : selectedCharacter.character,
      pronunciation: selectedCharacter == null ? void 0 : selectedCharacter.pronunciation,
      level: selectedCharacter == null ? void 0 : selectedCharacter.level
    }
  ));
};
const n5Kanji = {
  "一": {
    "freq": 2,
    "jlpt_new": 5,
    "meanings": [
      "One",
      "One Radical (no.1)"
    ],
    "readings_on": [
      "いち",
      "いつ"
    ],
    "readings_kun": [
      "ひと-",
      "ひと.つ"
    ]
  },
  "二": {
    "freq": 9,
    "jlpt_new": 5,
    "meanings": [
      "Two",
      "Two Radical (no. 7)"
    ],
    "readings_on": [
      "に",
      "じ"
    ],
    "readings_kun": [
      "ふた",
      "ふた.つ",
      "ふたたび"
    ]
  },
  "九": {
    "freq": 55,
    "jlpt_new": 5,
    "meanings": [
      "Nine"
    ],
    "readings_on": [
      "きゅう",
      "く"
    ],
    "readings_kun": [
      "ここの",
      "ここの.つ"
    ]
  },
  "七": {
    "freq": 115,
    "jlpt_new": 5,
    "meanings": [
      "Seven"
    ],
    "readings_on": [
      "しち"
    ],
    "readings_kun": [
      "なな",
      "なな.つ",
      "なの"
    ]
  },
  "人": {
    "freq": 5,
    "jlpt_new": 5,
    "meanings": [
      "Person"
    ],
    "readings_on": [
      "じん",
      "にん"
    ],
    "readings_kun": [
      "ひと",
      "-り",
      "-と"
    ]
  },
  "入": {
    "freq": 56,
    "jlpt_new": 5,
    "meanings": [
      "Enter",
      "Insert"
    ],
    "readings_on": [
      "にゅう",
      "じゅ"
    ],
    "readings_kun": [
      "い.る",
      "-い.る",
      "-い.り",
      "い.れる",
      "-い.れ",
      "はい.る"
    ]
  },
  "八": {
    "freq": 92,
    "jlpt_new": 5,
    "meanings": [
      "Eight",
      "Eight Radical (no. 12)"
    ],
    "readings_on": [
      "はち"
    ],
    "readings_kun": [
      "や",
      "や.つ",
      "やっ.つ",
      "よう"
    ]
  },
  "十": {
    "freq": 8,
    "jlpt_new": 5,
    "meanings": [
      "Ten"
    ],
    "readings_on": [
      "じゅう",
      "じっ",
      "じゅっ"
    ],
    "readings_kun": [
      "とお",
      "と"
    ]
  },
  "三": {
    "freq": 14,
    "jlpt_new": 5,
    "meanings": [
      "Three"
    ],
    "readings_on": [
      "さん",
      "ぞう"
    ],
    "readings_kun": [
      "み",
      "み.つ",
      "みっ.つ"
    ]
  },
  "上": {
    "freq": 35,
    "jlpt_new": 5,
    "meanings": [
      "Above",
      "Up"
    ],
    "readings_on": [
      "じょう",
      "しょう",
      "しゃん"
    ],
    "readings_kun": [
      "うえ",
      "-うえ",
      "うわ-",
      "かみ",
      "あ.げる",
      "-あ.げる",
      "あ.がる",
      "-あ.がる",
      "あ.がり",
      "-あ.がり",
      "のぼ.る",
      "のぼ.り",
      "のぼ.せる",
      "のぼ.す",
      "たてまつ.る"
    ]
  },
  "下": {
    "freq": 97,
    "jlpt_new": 5,
    "meanings": [
      "Below",
      "Down",
      "Descend",
      "Give",
      "Low",
      "Inferior"
    ],
    "readings_on": [
      "か",
      "げ"
    ],
    "readings_kun": [
      "した",
      "しも",
      "もと",
      "さ.げる",
      "さ.がる",
      "くだ.る",
      "くだ.り",
      "くだ.す",
      "-くだ.す",
      "くだ.さる",
      "お.ろす",
      "お.りる"
    ]
  },
  "大": {
    "freq": 7,
    "jlpt_new": 5,
    "meanings": [
      "Large",
      "Big"
    ],
    "readings_on": [
      "だい",
      "たい"
    ],
    "readings_kun": [
      "おお-",
      "おお.きい",
      "-おお.いに"
    ]
  },
  "女": {
    "freq": 151,
    "jlpt_new": 5,
    "meanings": [
      "Woman",
      "Female"
    ],
    "readings_on": [
      "じょ",
      "にょ",
      "にょう"
    ],
    "readings_kun": [
      "おんな",
      "め"
    ]
  },
  "山": {
    "freq": 131,
    "jlpt_new": 5,
    "meanings": [
      "Mountain"
    ],
    "readings_on": [
      "さん",
      "せん"
    ],
    "readings_kun": [
      "やま"
    ]
  },
  "川": {
    "freq": 181,
    "jlpt_new": 5,
    "meanings": [
      "Stream",
      "River",
      "River Or Three-stroke River Radical (no. 47)"
    ],
    "readings_on": [
      "せん"
    ],
    "readings_kun": [
      "かわ"
    ]
  },
  "土": {
    "freq": 307,
    "jlpt_new": 5,
    "meanings": [
      "Soil",
      "Earth",
      "Ground",
      "Turkey"
    ],
    "readings_on": [
      "ど",
      "と"
    ],
    "readings_kun": [
      "つち"
    ]
  },
  "千": {
    "freq": 195,
    "jlpt_new": 5,
    "meanings": [
      "Thousand"
    ],
    "readings_on": [
      "せん"
    ],
    "readings_kun": [
      "ち"
    ]
  },
  "子": {
    "freq": 72,
    "jlpt_new": 5,
    "meanings": [
      "Child",
      "Sign Of The Rat",
      "11pm-1am",
      "First Sign Of Chinese Zodiac"
    ],
    "readings_on": [
      "し",
      "す",
      "つ"
    ],
    "readings_kun": [
      "こ",
      "-こ",
      "ね"
    ]
  },
  "小": {
    "freq": 114,
    "jlpt_new": 5,
    "meanings": [
      "Little",
      "Small"
    ],
    "readings_on": [
      "しょう"
    ],
    "readings_kun": [
      "ちい.さい",
      "こ-",
      "お-",
      "さ-"
    ]
  },
  "中": {
    "freq": 11,
    "jlpt_new": 5,
    "meanings": [
      "In",
      "Inside",
      "Middle",
      "Mean",
      "Center"
    ],
    "readings_on": [
      "ちゅう"
    ],
    "readings_kun": [
      "なか",
      "うち",
      "あた.る"
    ]
  },
  "五": {
    "freq": 31,
    "jlpt_new": 5,
    "meanings": [
      "Five"
    ],
    "readings_on": [
      "ご"
    ],
    "readings_kun": [
      "いつ",
      "いつ.つ"
    ]
  },
  "六": {
    "freq": 93,
    "jlpt_new": 5,
    "meanings": [
      "Six"
    ],
    "readings_on": [
      "ろく",
      "りく"
    ],
    "readings_kun": [
      "む",
      "む.つ",
      "むっ.つ",
      "むい"
    ]
  },
  "円": {
    "freq": 69,
    "jlpt_new": 5,
    "meanings": [
      "Circle",
      "Yen",
      "Round"
    ],
    "readings_on": [
      "えん"
    ],
    "readings_kun": [
      "まる.い",
      "まる",
      "まど",
      "まど.か",
      "まろ.やか"
    ]
  },
  "天": {
    "freq": 512,
    "jlpt_new": 5,
    "meanings": [
      "Heavens",
      "Sky",
      "Imperial"
    ],
    "readings_on": [
      "てん"
    ],
    "readings_kun": [
      "あまつ",
      "あめ",
      "あま-"
    ]
  },
  "日": {
    "freq": 1,
    "jlpt_new": 5,
    "meanings": [
      "Day",
      "Sun",
      "Japan",
      "Counter For Days"
    ],
    "readings_on": [
      "にち",
      "じつ"
    ],
    "readings_kun": [
      "ひ",
      "-び",
      "-か"
    ]
  },
  "月": {
    "freq": 23,
    "jlpt_new": 5,
    "meanings": [
      "Month",
      "Moon"
    ],
    "readings_on": [
      "げつ",
      "がつ"
    ],
    "readings_kun": [
      "つき"
    ]
  },
  "木": {
    "freq": 317,
    "jlpt_new": 5,
    "meanings": [
      "Tree",
      "Wood"
    ],
    "readings_on": [
      "ぼく",
      "もく"
    ],
    "readings_kun": [
      "き",
      "こ-"
    ]
  },
  "水": {
    "freq": 223,
    "jlpt_new": 5,
    "meanings": [
      "Water"
    ],
    "readings_on": [
      "すい"
    ],
    "readings_kun": [
      "みず",
      "みず-"
    ]
  },
  "火": {
    "freq": 574,
    "jlpt_new": 5,
    "meanings": [
      "Fire"
    ],
    "readings_on": [
      "か"
    ],
    "readings_kun": [
      "ひ",
      "-び",
      "ほ-"
    ]
  },
  "出": {
    "freq": 13,
    "jlpt_new": 5,
    "meanings": [
      "Exit",
      "Leave",
      "Go Out",
      "Come Out",
      "Put Out",
      "Protrude"
    ],
    "readings_on": [
      "しゅつ",
      "すい"
    ],
    "readings_kun": [
      "で.る",
      "-で",
      "だ.す",
      "-だ.す",
      "い.でる",
      "い.だす"
    ]
  },
  "右": {
    "freq": 602,
    "jlpt_new": 5,
    "meanings": [
      "Right"
    ],
    "readings_on": [
      "う",
      "ゆう"
    ],
    "readings_kun": [
      "みぎ"
    ]
  },
  "四": {
    "freq": 47,
    "jlpt_new": 5,
    "meanings": [
      "Four"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "よ",
      "よ.つ",
      "よっ.つ",
      "よん"
    ]
  },
  "左": {
    "freq": 630,
    "jlpt_new": 5,
    "meanings": [
      "Left"
    ],
    "readings_on": [
      "さ",
      "しゃ"
    ],
    "readings_kun": [
      "ひだり"
    ]
  },
  "本": {
    "freq": 10,
    "jlpt_new": 5,
    "meanings": [
      "Book",
      "Present",
      "Main",
      "Origin",
      "True",
      "Real",
      "Counter For Long Cylindrical Things"
    ],
    "readings_on": [
      "ほん"
    ],
    "readings_kun": [
      "もと"
    ]
  },
  "白": {
    "freq": 483,
    "jlpt_new": 5,
    "meanings": [
      "White"
    ],
    "readings_on": [
      "はく",
      "びゃく"
    ],
    "readings_kun": [
      "しろ",
      "しら-",
      "しろ.い"
    ]
  },
  "万": {
    "freq": 375,
    "jlpt_new": 5,
    "meanings": [
      "Ten Thousand",
      "10,000"
    ],
    "readings_on": [
      "まん",
      "ばん"
    ],
    "readings_kun": [
      "よろず"
    ]
  },
  "今": {
    "freq": 49,
    "jlpt_new": 5,
    "meanings": [
      "Now"
    ],
    "readings_on": [
      "こん",
      "きん"
    ],
    "readings_kun": [
      "いま"
    ]
  },
  "午": {
    "freq": 154,
    "jlpt_new": 5,
    "meanings": [
      "Noon",
      "Sign Of The Horse",
      "11am-1pm",
      "Seventh Sign Of Chinese Zodiac"
    ],
    "readings_on": [
      "ご"
    ],
    "readings_kun": [
      "うま"
    ]
  },
  "友": {
    "freq": 622,
    "jlpt_new": 5,
    "meanings": [
      "Friend"
    ],
    "readings_on": [
      "ゆう"
    ],
    "readings_kun": [
      "とも"
    ]
  },
  "父": {
    "freq": 646,
    "jlpt_new": 5,
    "meanings": [
      "Father"
    ],
    "readings_on": [
      "ふ"
    ],
    "readings_kun": [
      "ちち"
    ]
  },
  "北": {
    "freq": 153,
    "jlpt_new": 5,
    "meanings": [
      "North"
    ],
    "readings_on": [
      "ほく"
    ],
    "readings_kun": [
      "きた"
    ]
  },
  "半": {
    "freq": 224,
    "jlpt_new": 5,
    "meanings": [
      "Half",
      "Middle",
      "Odd Number",
      "Semi-",
      "Part-"
    ],
    "readings_on": [
      "はん"
    ],
    "readings_kun": [
      "なか.ば"
    ]
  },
  "外": {
    "freq": 81,
    "jlpt_new": 5,
    "meanings": [
      "Outside"
    ],
    "readings_on": [
      "がい",
      "げ"
    ],
    "readings_kun": [
      "そと",
      "ほか",
      "はず.す",
      "はず.れる",
      "と-"
    ]
  },
  "母": {
    "freq": 570,
    "jlpt_new": 5,
    "meanings": [
      "Mother"
    ],
    "readings_on": [
      "ぼ"
    ],
    "readings_kun": [
      "はは",
      "も"
    ]
  },
  "休": {
    "freq": 642,
    "jlpt_new": 5,
    "meanings": [
      "Rest",
      "Day Off",
      "Retire",
      "Sleep"
    ],
    "readings_on": [
      "きゅう"
    ],
    "readings_kun": [
      "やす.む",
      "やす.まる",
      "やす.める"
    ]
  },
  "先": {
    "freq": 173,
    "jlpt_new": 5,
    "meanings": [
      "Before",
      "Ahead",
      "Previous",
      "Future",
      "Precedence"
    ],
    "readings_on": [
      "せん"
    ],
    "readings_kun": [
      "さき",
      "ま.ず"
    ]
  },
  "名": {
    "freq": 177,
    "jlpt_new": 5,
    "meanings": [
      "Name",
      "Noted",
      "Distinguished",
      "Reputation"
    ],
    "readings_on": [
      "めい",
      "みょう"
    ],
    "readings_kun": [
      "な",
      "-な"
    ]
  },
  "年": {
    "freq": 6,
    "jlpt_new": 5,
    "meanings": [
      "Year",
      "Counter For Years"
    ],
    "readings_on": [
      "ねん"
    ],
    "readings_kun": [
      "とし"
    ]
  },
  "気": {
    "freq": 113,
    "jlpt_new": 5,
    "meanings": [
      "Spirit",
      "Mind",
      "Air",
      "Atmosphere",
      "Mood"
    ],
    "readings_on": [
      "き",
      "け"
    ],
    "readings_kun": [
      "いき"
    ]
  },
  "百": {
    "freq": 163,
    "jlpt_new": 5,
    "meanings": [
      "Hundred"
    ],
    "readings_on": [
      "ひゃく",
      "びゃく"
    ],
    "readings_kun": [
      "もも"
    ]
  },
  "男": {
    "freq": 240,
    "jlpt_new": 5,
    "meanings": [
      "Male"
    ],
    "readings_on": [
      "だん",
      "なん"
    ],
    "readings_kun": [
      "おとこ",
      "お"
    ]
  },
  "見": {
    "freq": 22,
    "jlpt_new": 5,
    "meanings": [
      "See",
      "Hopes",
      "Chances",
      "Idea",
      "Opinion",
      "Look At",
      "Visible"
    ],
    "readings_on": [
      "けん"
    ],
    "readings_kun": [
      "み.る",
      "み.える",
      "み.せる"
    ]
  },
  "車": {
    "freq": 333,
    "jlpt_new": 5,
    "meanings": [
      "Car"
    ],
    "readings_on": [
      "しゃ"
    ],
    "readings_kun": [
      "くるま"
    ]
  },
  "毎": {
    "freq": 436,
    "jlpt_new": 5,
    "meanings": [
      "Every"
    ],
    "readings_on": [
      "まい"
    ],
    "readings_kun": [
      "ごと",
      "-ごと.に"
    ]
  },
  "行": {
    "freq": 20,
    "jlpt_new": 5,
    "meanings": [
      "Going",
      "Journey",
      "Carry Out",
      "Conduct",
      "Act",
      "Line",
      "Row",
      "Bank"
    ],
    "readings_on": [
      "こう",
      "ぎょう",
      "あん"
    ],
    "readings_kun": [
      "い.く",
      "ゆ.く",
      "-ゆ.き",
      "-ゆき",
      "-い.き",
      "-いき",
      "おこな.う",
      "おこ.なう"
    ]
  },
  "西": {
    "freq": 259,
    "jlpt_new": 5,
    "meanings": [
      "West",
      "Spain"
    ],
    "readings_on": [
      "せい",
      "さい",
      "す"
    ],
    "readings_kun": [
      "にし"
    ]
  },
  "何": {
    "freq": 340,
    "jlpt_new": 5,
    "meanings": [
      "What"
    ],
    "readings_on": [
      "か"
    ],
    "readings_kun": [
      "なに",
      "なん",
      "なに-",
      "なん-"
    ]
  },
  "来": {
    "freq": 102,
    "jlpt_new": 5,
    "meanings": [
      "Come",
      "Due",
      "Next",
      "Cause",
      "Become"
    ],
    "readings_on": [
      "らい",
      "たい"
    ],
    "readings_kun": [
      "く.る",
      "きた.る",
      "きた.す",
      "き.たす",
      "き.たる",
      "き",
      "こ"
    ]
  },
  "学": {
    "freq": 63,
    "jlpt_new": 5,
    "meanings": [
      "Study",
      "Learning",
      "Science"
    ],
    "readings_on": [
      "がく"
    ],
    "readings_kun": [
      "まな.ぶ"
    ]
  },
  "金": {
    "freq": 53,
    "jlpt_new": 5,
    "meanings": [
      "Gold"
    ],
    "readings_on": [
      "きん",
      "こん",
      "ごん"
    ],
    "readings_kun": [
      "かね",
      "かな-",
      "-がね"
    ]
  },
  "雨": {
    "freq": 950,
    "jlpt_new": 5,
    "meanings": [
      "Rain"
    ],
    "readings_on": [
      "う"
    ],
    "readings_kun": [
      "あめ",
      "あま-",
      "-さめ"
    ]
  },
  "国": {
    "freq": 3,
    "jlpt_new": 5,
    "meanings": [
      "Country"
    ],
    "readings_on": [
      "こく"
    ],
    "readings_kun": [
      "くに"
    ]
  },
  "東": {
    "freq": 37,
    "jlpt_new": 5,
    "meanings": [
      "East"
    ],
    "readings_on": [
      "とう"
    ],
    "readings_kun": [
      "ひがし"
    ]
  },
  "長": {
    "freq": 12,
    "jlpt_new": 5,
    "meanings": [
      "Long",
      "Leader",
      "Superior",
      "Senior"
    ],
    "readings_on": [
      "ちょう"
    ],
    "readings_kun": [
      "なが.い",
      "おさ"
    ]
  },
  "前": {
    "freq": 27,
    "jlpt_new": 5,
    "meanings": [
      "In Front",
      "Before"
    ],
    "readings_on": [
      "ぜん"
    ],
    "readings_kun": [
      "まえ",
      "-まえ"
    ]
  },
  "南": {
    "freq": 341,
    "jlpt_new": 5,
    "meanings": [
      "South"
    ],
    "readings_on": [
      "なん",
      "な"
    ],
    "readings_kun": [
      "みなみ"
    ]
  },
  "後": {
    "freq": 26,
    "jlpt_new": 5,
    "meanings": [
      "Behind",
      "Back",
      "Later"
    ],
    "readings_on": [
      "ご",
      "こう"
    ],
    "readings_kun": [
      "のち",
      "うし.ろ",
      "うしろ",
      "あと",
      "おく.れる"
    ]
  },
  "食": {
    "freq": 328,
    "jlpt_new": 5,
    "meanings": [
      "Eat",
      "Food"
    ],
    "readings_on": [
      "しょく",
      "じき"
    ],
    "readings_kun": [
      "く.う",
      "く.らう",
      "た.べる",
      "は.む"
    ]
  },
  "校": {
    "freq": 294,
    "jlpt_new": 5,
    "meanings": [
      "Exam",
      "School",
      "Printing",
      "Proof",
      "Correction"
    ],
    "readings_on": [
      "こう",
      "きょう"
    ],
    "readings_kun": []
  },
  "時": {
    "freq": 16,
    "jlpt_new": 5,
    "meanings": [
      "Time",
      "Hour"
    ],
    "readings_on": [
      "じ"
    ],
    "readings_kun": [
      "とき",
      "-どき"
    ]
  },
  "高": {
    "freq": 65,
    "jlpt_new": 5,
    "meanings": [
      "Tall",
      "High",
      "Expensive"
    ],
    "readings_on": [
      "こう"
    ],
    "readings_kun": [
      "たか.い",
      "たか",
      "-だか",
      "たか.まる",
      "たか.める"
    ]
  },
  "間": {
    "freq": 33,
    "jlpt_new": 5,
    "meanings": [
      "Interval",
      "Space"
    ],
    "readings_on": [
      "かん",
      "けん"
    ],
    "readings_kun": [
      "あいだ",
      "ま",
      "あい"
    ]
  },
  "話": {
    "freq": 134,
    "jlpt_new": 5,
    "meanings": [
      "Tale",
      "Talk"
    ],
    "readings_on": [
      "わ"
    ],
    "readings_kun": [
      "はな.す",
      "はなし"
    ]
  },
  "電": {
    "freq": 268,
    "jlpt_new": 5,
    "meanings": [
      "Electricity"
    ],
    "readings_on": [
      "でん"
    ],
    "readings_kun": []
  },
  "聞": {
    "freq": 319,
    "jlpt_new": 5,
    "meanings": [
      "Hear",
      "Ask",
      "Listen"
    ],
    "readings_on": [
      "ぶん",
      "もん"
    ],
    "readings_kun": [
      "き.く",
      "き.こえる"
    ]
  },
  "語": {
    "freq": 301,
    "jlpt_new": 5,
    "meanings": [
      "Word",
      "Speech",
      "Language"
    ],
    "readings_on": [
      "ご"
    ],
    "readings_kun": [
      "かた.る",
      "かた.らう"
    ]
  },
  "読": {
    "freq": 618,
    "jlpt_new": 5,
    "meanings": [
      "Read"
    ],
    "readings_on": [
      "どく",
      "とく",
      "とう"
    ],
    "readings_kun": [
      "よ.む",
      "-よ.み"
    ]
  },
  "生": {
    "freq": 29,
    "jlpt_new": 5,
    "meanings": [
      "Life",
      "Genuine",
      "Birth"
    ],
    "readings_on": [
      "せい",
      "しょう"
    ],
    "readings_kun": [
      "い.きる",
      "い.かす",
      "い.ける",
      "う.まれる",
      "うま.れる",
      "う.まれ",
      "うまれ",
      "う.む",
      "お.う",
      "は.える",
      "は.やす",
      "き",
      "なま",
      "なま-",
      "な.る",
      "な.す",
      "む.す",
      "-う"
    ]
  },
  "書": {
    "freq": 169,
    "jlpt_new": 5,
    "meanings": [
      "Write"
    ],
    "readings_on": [
      "しょ"
    ],
    "readings_kun": [
      "か.く",
      "-が.き",
      "-がき"
    ]
  }
};
const n4Kanji = {
  "力": {
    "freq": 62,
    "jlpt_new": 4,
    "meanings": [
      "Power",
      "Strength",
      "Strong",
      "Strain",
      "Bear Up",
      "Exert"
    ],
    "readings_on": [
      "りょく",
      "りき",
      "りい"
    ],
    "readings_kun": [
      "ちから"
    ]
  },
  "口": {
    "freq": 284,
    "jlpt_new": 4,
    "meanings": [
      "Mouth"
    ],
    "readings_on": [
      "こう",
      "く"
    ],
    "readings_kun": [
      "くち"
    ]
  },
  "工": {
    "freq": 299,
    "jlpt_new": 4,
    "meanings": [
      "Craft",
      "Construction",
      "Katakana E Radical (no. 48)"
    ],
    "readings_on": [
      "こう",
      "く",
      "ぐ"
    ],
    "readings_kun": []
  },
  "夕": {
    "freq": 924,
    "jlpt_new": 4,
    "meanings": [
      "Evening"
    ],
    "readings_on": [
      "せき"
    ],
    "readings_kun": [
      "ゆう"
    ]
  },
  "手": {
    "freq": 60,
    "jlpt_new": 4,
    "meanings": [
      "Hand"
    ],
    "readings_on": [
      "しゅ",
      "ず"
    ],
    "readings_kun": [
      "て",
      "て-",
      "-て",
      "た-"
    ]
  },
  "文": {
    "freq": 190,
    "jlpt_new": 4,
    "meanings": [
      "Sentence",
      "Literature",
      "Style",
      "Art",
      "Decoration",
      "Figures",
      "Plan",
      "Literary Radical (no. 67)"
    ],
    "readings_on": [
      "ぶん",
      "もん"
    ],
    "readings_kun": [
      "ふみ",
      "あや"
    ]
  },
  "犬": {
    "freq": 1326,
    "jlpt_new": 4,
    "meanings": [
      "Dog"
    ],
    "readings_on": [
      "けん"
    ],
    "readings_kun": [
      "いぬ",
      "いぬ-"
    ]
  },
  "正": {
    "freq": 143,
    "jlpt_new": 4,
    "meanings": [
      "Correct",
      "Justice",
      "Righteous",
      "10**40"
    ],
    "readings_on": [
      "せい",
      "しょう"
    ],
    "readings_kun": [
      "ただ.しい",
      "ただ.す",
      "まさ",
      "まさ.に"
    ]
  },
  "田": {
    "freq": 90,
    "jlpt_new": 4,
    "meanings": [
      "Rice Field",
      "Rice Paddy"
    ],
    "readings_on": [
      "でん"
    ],
    "readings_kun": [
      "た"
    ]
  },
  "目": {
    "freq": 76,
    "jlpt_new": 4,
    "meanings": [
      "Eye",
      "Class",
      "Look",
      "Insight",
      "Experience",
      "Care",
      "Favor"
    ],
    "readings_on": [
      "もく",
      "ぼく"
    ],
    "readings_kun": [
      "め",
      "-め",
      "ま-"
    ]
  },
  "立": {
    "freq": 58,
    "jlpt_new": 4,
    "meanings": [
      "Stand Up",
      "Rise",
      "Set Up",
      "Erect"
    ],
    "readings_on": [
      "りつ",
      "りゅう",
      "りっとる"
    ],
    "readings_kun": [
      "た.つ",
      "-た.つ",
      "た.ち-",
      "た.てる",
      "-た.てる",
      "た.て-",
      "たて-",
      "-た.て",
      "-だ.て",
      "-だ.てる"
    ]
  },
  "元": {
    "freq": 192,
    "jlpt_new": 4,
    "meanings": [
      "Beginning",
      "Former Time",
      "Origin"
    ],
    "readings_on": [
      "げん",
      "がん"
    ],
    "readings_kun": [
      "もと"
    ]
  },
  "公": {
    "freq": 118,
    "jlpt_new": 4,
    "meanings": [
      "Public",
      "Prince",
      "Official",
      "Governmental"
    ],
    "readings_on": [
      "こう",
      "く"
    ],
    "readings_kun": [
      "おおやけ"
    ]
  },
  "切": {
    "freq": 324,
    "jlpt_new": 4,
    "meanings": [
      "Cut",
      "Cutoff",
      "Be Sharp"
    ],
    "readings_on": [
      "せつ",
      "さい"
    ],
    "readings_kun": [
      "き.る",
      "-き.る",
      "き.り",
      "-き.り",
      "-ぎ.り",
      "き.れる",
      "-き.れる",
      "き.れ",
      "-き.れ",
      "-ぎ.れ"
    ]
  },
  "少": {
    "freq": 287,
    "jlpt_new": 4,
    "meanings": [
      "Few",
      "Little"
    ],
    "readings_on": [
      "しょう"
    ],
    "readings_kun": [
      "すく.ない",
      "すこ.し"
    ]
  },
  "心": {
    "freq": 157,
    "jlpt_new": 4,
    "meanings": [
      "Heart",
      "Mind",
      "Spirit",
      "Heart Radical (no. 61)"
    ],
    "readings_on": [
      "しん"
    ],
    "readings_kun": [
      "こころ",
      "-ごころ"
    ]
  },
  "方": {
    "freq": 46,
    "jlpt_new": 4,
    "meanings": [
      "Direction",
      "Person",
      "Alternative"
    ],
    "readings_on": [
      "ほう"
    ],
    "readings_kun": [
      "かた",
      "-かた",
      "-がた"
    ]
  },
  "牛": {
    "freq": 1202,
    "jlpt_new": 4,
    "meanings": [
      "Cow"
    ],
    "readings_on": [
      "ぎゅう"
    ],
    "readings_kun": [
      "うし"
    ]
  },
  "止": {
    "freq": 310,
    "jlpt_new": 4,
    "meanings": [
      "Stop",
      "Halt"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "と.まる",
      "-ど.まり",
      "と.める",
      "-と.める",
      "-ど.め",
      "とど.める",
      "とど.め",
      "とど.まる",
      "や.める",
      "や.む",
      "-や.む",
      "よ.す",
      "-さ.す",
      "-さ.し"
    ]
  },
  "兄": {
    "freq": 1219,
    "jlpt_new": 4,
    "meanings": [
      "Elder Brother",
      "Big Brother"
    ],
    "readings_on": [
      "けい",
      "きょう"
    ],
    "readings_kun": [
      "あに"
    ]
  },
  "冬": {
    "freq": 1090,
    "jlpt_new": 4,
    "meanings": [
      "Winter"
    ],
    "readings_on": [
      "とう"
    ],
    "readings_kun": [
      "ふゆ"
    ]
  },
  "古": {
    "freq": 509,
    "jlpt_new": 4,
    "meanings": [
      "Old"
    ],
    "readings_on": [
      "こ"
    ],
    "readings_kun": [
      "ふる.い",
      "ふる-",
      "-ふる.す"
    ]
  },
  "台": {
    "freq": 262,
    "jlpt_new": 4,
    "meanings": [
      "Pedestal",
      "A Stand",
      "Counter For Machines And Vehicles"
    ],
    "readings_on": [
      "だい",
      "たい"
    ],
    "readings_kun": [
      "うてな",
      "われ",
      "つかさ"
    ]
  },
  "広": {
    "freq": 263,
    "jlpt_new": 4,
    "meanings": [
      "Wide",
      "Broad",
      "Spacious"
    ],
    "readings_on": [
      "こう"
    ],
    "readings_kun": [
      "ひろ.い",
      "ひろ.まる",
      "ひろ.める",
      "ひろ.がる",
      "ひろ.げる"
    ]
  },
  "用": {
    "freq": 107,
    "jlpt_new": 4,
    "meanings": [
      "Utilize",
      "Business",
      "Service",
      "Use",
      "Employ"
    ],
    "readings_on": [
      "よう"
    ],
    "readings_kun": [
      "もち.いる"
    ]
  },
  "世": {
    "freq": 135,
    "jlpt_new": 4,
    "meanings": [
      "Generation",
      "World",
      "Society",
      "Public"
    ],
    "readings_on": [
      "せい",
      "せ",
      "そう"
    ],
    "readings_kun": [
      "よ"
    ]
  },
  "主": {
    "freq": 95,
    "jlpt_new": 4,
    "meanings": [
      "Lord",
      "Chief",
      "Master",
      "Main Thing",
      "Principal"
    ],
    "readings_on": [
      "しゅ",
      "す",
      "しゅう"
    ],
    "readings_kun": [
      "ぬし",
      "おも",
      "あるじ"
    ]
  },
  "代": {
    "freq": 66,
    "jlpt_new": 4,
    "meanings": [
      "Substitute",
      "Change",
      "Convert",
      "Replace",
      "Period",
      "Age",
      "Counter For Decades Of Ages, Eras, Etc.",
      "Generation",
      "Charge",
      "Rate",
      "Fee"
    ],
    "readings_on": [
      "だい",
      "たい"
    ],
    "readings_kun": [
      "か.わる",
      "かわ.る",
      "かわ.り",
      "か.わり",
      "-がわ.り",
      "-が.わり",
      "か.える",
      "よ",
      "しろ"
    ]
  },
  "写": {
    "freq": 453,
    "jlpt_new": 4,
    "meanings": [
      "Copy",
      "Be Photographed",
      "Describe"
    ],
    "readings_on": [
      "しゃ",
      "じゃ"
    ],
    "readings_kun": [
      "うつ.す",
      "うつ.る",
      "うつ-",
      "うつ.し"
    ]
  },
  "去": {
    "freq": 440,
    "jlpt_new": 4,
    "meanings": [
      "Gone",
      "Past",
      "Quit",
      "Leave",
      "Elapse",
      "Eliminate",
      "Divorce"
    ],
    "readings_on": [
      "きょ",
      "こ"
    ],
    "readings_kun": [
      "さ.る",
      "-さ.る"
    ]
  },
  "字": {
    "freq": 485,
    "jlpt_new": 4,
    "meanings": [
      "Character",
      "Letter",
      "Word",
      "Section Of Village"
    ],
    "readings_on": [
      "じ"
    ],
    "readings_kun": [
      "あざ",
      "あざな",
      "-な"
    ]
  },
  "早": {
    "freq": 402,
    "jlpt_new": 4,
    "meanings": [
      "Early",
      "Fast"
    ],
    "readings_on": [
      "そう",
      "さっ"
    ],
    "readings_kun": [
      "はや.い",
      "はや",
      "はや-",
      "はや.まる",
      "はや.める",
      "さ-"
    ]
  },
  "町": {
    "freq": 292,
    "jlpt_new": 4,
    "meanings": [
      "Town",
      "Village",
      "Block",
      "Street"
    ],
    "readings_on": [
      "ちょう"
    ],
    "readings_kun": [
      "まち"
    ]
  },
  "花": {
    "freq": 578,
    "jlpt_new": 4,
    "meanings": [
      "Flower"
    ],
    "readings_on": [
      "か",
      "け"
    ],
    "readings_kun": [
      "はな"
    ]
  },
  "赤": {
    "freq": 584,
    "jlpt_new": 4,
    "meanings": [
      "Red"
    ],
    "readings_on": [
      "せき",
      "しゃく"
    ],
    "readings_kun": [
      "あか",
      "あか-",
      "あか.い",
      "あか.らむ",
      "あか.らめる"
    ]
  },
  "足": {
    "freq": 343,
    "jlpt_new": 4,
    "meanings": [
      "Leg",
      "Foot",
      "Be Sufficient",
      "Counter For Pairs Of Footwear"
    ],
    "readings_on": [
      "そく"
    ],
    "readings_kun": [
      "あし",
      "た.りる",
      "た.る",
      "た.す"
    ]
  },
  "不": {
    "freq": 101,
    "jlpt_new": 4,
    "meanings": [
      "Negative",
      "Non-",
      "Bad",
      "Ugly",
      "Clumsy"
    ],
    "readings_on": [
      "ふ",
      "ぶ"
    ],
    "readings_kun": []
  },
  "仕": {
    "freq": 439,
    "jlpt_new": 4,
    "meanings": [
      "Attend",
      "Doing",
      "Official",
      "Serve"
    ],
    "readings_on": [
      "し",
      "じ"
    ],
    "readings_kun": [
      "つか.える"
    ]
  },
  "会": {
    "freq": 4,
    "jlpt_new": 4,
    "meanings": [
      "Meeting",
      "Meet",
      "Party",
      "Association",
      "Interview",
      "Join"
    ],
    "readings_on": [
      "かい",
      "え"
    ],
    "readings_kun": [
      "あ.う",
      "あ.わせる",
      "あつ.まる"
    ]
  },
  "同": {
    "freq": 15,
    "jlpt_new": 4,
    "meanings": [
      "Same",
      "Agree",
      "Equal"
    ],
    "readings_on": [
      "どう"
    ],
    "readings_kun": [
      "おな.じ"
    ]
  },
  "多": {
    "freq": 139,
    "jlpt_new": 4,
    "meanings": [
      "Many",
      "Frequent",
      "Much"
    ],
    "readings_on": [
      "た"
    ],
    "readings_kun": [
      "おお.い",
      "まさ.に",
      "まさ.る"
    ]
  },
  "考": {
    "freq": 196,
    "jlpt_new": 4,
    "meanings": [
      "Consider",
      "Think Over"
    ],
    "readings_on": [
      "こう"
    ],
    "readings_kun": [
      "かんが.える",
      "かんが.え"
    ]
  },
  "肉": {
    "freq": 986,
    "jlpt_new": 4,
    "meanings": [
      "Meat"
    ],
    "readings_on": [
      "にく"
    ],
    "readings_kun": [
      "しし"
    ]
  },
  "自": {
    "freq": 19,
    "jlpt_new": 4,
    "meanings": [
      "Oneself"
    ],
    "readings_on": [
      "じ",
      "し"
    ],
    "readings_kun": [
      "みずか.ら",
      "おの.ずから",
      "おの.ずと"
    ]
  },
  "色": {
    "freq": 621,
    "jlpt_new": 4,
    "meanings": [
      "Color"
    ],
    "readings_on": [
      "しょく",
      "しき"
    ],
    "readings_kun": [
      "いろ"
    ]
  },
  "体": {
    "freq": 88,
    "jlpt_new": 4,
    "meanings": [
      "Body",
      "Substance",
      "Object",
      "Reality",
      "Counter For Images"
    ],
    "readings_on": [
      "たい",
      "てい"
    ],
    "readings_kun": [
      "からだ",
      "かたち"
    ]
  },
  "作": {
    "freq": 103,
    "jlpt_new": 4,
    "meanings": [
      "Make",
      "Production",
      "Prepare",
      "Build"
    ],
    "readings_on": [
      "さく",
      "さ"
    ],
    "readings_kun": [
      "つく.る",
      "つく.り",
      "-づく.り"
    ]
  },
  "図": {
    "freq": 539,
    "jlpt_new": 4,
    "meanings": [
      "Map",
      "Drawing",
      "Plan",
      "Extraordinary",
      "Audacious"
    ],
    "readings_on": [
      "ず",
      "と"
    ],
    "readings_kun": [
      "え",
      "はか.る"
    ]
  },
  "売": {
    "freq": 202,
    "jlpt_new": 4,
    "meanings": [
      "Sell"
    ],
    "readings_on": [
      "ばい"
    ],
    "readings_kun": [
      "う.る",
      "う.れる"
    ]
  },
  "弟": {
    "freq": 1161,
    "jlpt_new": 4,
    "meanings": [
      "Younger Brother",
      "Faithful Service To Elders"
    ],
    "readings_on": [
      "てい",
      "だい",
      "で"
    ],
    "readings_kun": [
      "おとうと"
    ]
  },
  "社": {
    "freq": 21,
    "jlpt_new": 4,
    "meanings": [
      "Company",
      "Firm",
      "Office",
      "Association",
      "Shrine"
    ],
    "readings_on": [
      "しゃ"
    ],
    "readings_kun": [
      "やしろ"
    ]
  },
  "言": {
    "freq": 83,
    "jlpt_new": 4,
    "meanings": [
      "Say",
      "Word"
    ],
    "readings_on": [
      "げん",
      "ごん"
    ],
    "readings_kun": [
      "い.う",
      "こと"
    ]
  },
  "走": {
    "freq": 626,
    "jlpt_new": 4,
    "meanings": [
      "Run"
    ],
    "readings_on": [
      "そう"
    ],
    "readings_kun": [
      "はし.る"
    ]
  },
  "近": {
    "freq": 194,
    "jlpt_new": 4,
    "meanings": [
      "Near",
      "Early",
      "Akin",
      "Tantamount"
    ],
    "readings_on": [
      "きん",
      "こん"
    ],
    "readings_kun": [
      "ちか.い"
    ]
  },
  "空": {
    "freq": 304,
    "jlpt_new": 4,
    "meanings": [
      "Empty",
      "Sky",
      "Void",
      "Vacant",
      "Vacuum"
    ],
    "readings_on": [
      "くう"
    ],
    "readings_kun": [
      "そら",
      "あ.く",
      "あ.き",
      "あ.ける",
      "から",
      "す.く",
      "す.かす",
      "むな.しい"
    ]
  },
  "青": {
    "freq": 589,
    "jlpt_new": 4,
    "meanings": [
      "Blue",
      "Green"
    ],
    "readings_on": [
      "せい",
      "しょう"
    ],
    "readings_kun": [
      "あお",
      "あお-",
      "あお.い"
    ]
  },
  "音": {
    "freq": 491,
    "jlpt_new": 4,
    "meanings": [
      "Sound",
      "Noise"
    ],
    "readings_on": [
      "おん",
      "いん",
      "-のん"
    ],
    "readings_kun": [
      "おと",
      "ね"
    ]
  },
  "地": {
    "freq": 40,
    "jlpt_new": 4,
    "meanings": [
      "Ground",
      "Earth"
    ],
    "readings_on": [
      "ち",
      "じ"
    ],
    "readings_kun": []
  },
  "安": {
    "freq": 144,
    "jlpt_new": 4,
    "meanings": [
      "Relax",
      "Cheap",
      "Low",
      "Quiet",
      "Rested",
      "Contented",
      "Peaceful"
    ],
    "readings_on": [
      "あん"
    ],
    "readings_kun": [
      "やす.い",
      "やす.まる",
      "やす",
      "やす.らか"
    ]
  },
  "有": {
    "freq": 282,
    "jlpt_new": 4,
    "meanings": [
      "Possess",
      "Have",
      "Exist",
      "Happen",
      "Occur",
      "Approx"
    ],
    "readings_on": [
      "ゆう",
      "う"
    ],
    "readings_kun": [
      "あ.る"
    ]
  },
  "死": {
    "freq": 229,
    "jlpt_new": 4,
    "meanings": [
      "Death",
      "Die"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "し.ぬ",
      "し.に-"
    ]
  },
  "京": {
    "freq": 74,
    "jlpt_new": 4,
    "meanings": [
      "Capital",
      "10**16"
    ],
    "readings_on": [
      "きょう",
      "けい",
      "きん"
    ],
    "readings_kun": [
      "みやこ"
    ]
  },
  "夜": {
    "freq": 487,
    "jlpt_new": 4,
    "meanings": [
      "Night",
      "Evening"
    ],
    "readings_on": [
      "や"
    ],
    "readings_kun": [
      "よ",
      "よる"
    ]
  },
  "妹": {
    "freq": 1446,
    "jlpt_new": 4,
    "meanings": [
      "Younger Sister"
    ],
    "readings_on": [
      "まい"
    ],
    "readings_kun": [
      "いもうと"
    ]
  },
  "姉": {
    "freq": 1473,
    "jlpt_new": 4,
    "meanings": [
      "Elder Sister"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "あね",
      "はは"
    ]
  },
  "店": {
    "freq": 378,
    "jlpt_new": 4,
    "meanings": [
      "Store",
      "Shop"
    ],
    "readings_on": [
      "てん"
    ],
    "readings_kun": [
      "みせ",
      "たな"
    ]
  },
  "明": {
    "freq": 67,
    "jlpt_new": 4,
    "meanings": [
      "Bright",
      "Light"
    ],
    "readings_on": [
      "めい",
      "みょう",
      "みん"
    ],
    "readings_kun": [
      "あ.かり",
      "あか.るい",
      "あか.るむ",
      "あか.らむ",
      "あき.らか",
      "あ.ける",
      "-あ.け",
      "あ.く",
      "あ.くる",
      "あ.かす"
    ]
  },
  "歩": {
    "freq": 554,
    "jlpt_new": 4,
    "meanings": [
      "Walk",
      "Counter For Steps"
    ],
    "readings_on": [
      "ほ",
      "ぶ",
      "ふ"
    ],
    "readings_kun": [
      "ある.く",
      "あゆ.む"
    ]
  },
  "画": {
    "freq": 199,
    "jlpt_new": 4,
    "meanings": [
      "Brush-stroke",
      "Picture"
    ],
    "readings_on": [
      "が",
      "かく",
      "え",
      "かい"
    ],
    "readings_kun": [
      "えが.く",
      "かく.する",
      "かぎ.る",
      "はかりごと",
      "はか.る"
    ]
  },
  "知": {
    "freq": 205,
    "jlpt_new": 4,
    "meanings": [
      "Know",
      "Wisdom"
    ],
    "readings_on": [
      "ち"
    ],
    "readings_kun": [
      "し.る",
      "し.らせる"
    ]
  },
  "室": {
    "freq": 550,
    "jlpt_new": 4,
    "meanings": [
      "Room",
      "Apartment",
      "Chamber",
      "Greenhouse",
      "Cellar"
    ],
    "readings_on": [
      "しつ"
    ],
    "readings_kun": [
      "むろ"
    ]
  },
  "思": {
    "freq": 132,
    "jlpt_new": 4,
    "meanings": [
      "Think"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "おも.う",
      "おもえら.く",
      "おぼ.す"
    ]
  },
  "海": {
    "freq": 200,
    "jlpt_new": 4,
    "meanings": [
      "Sea",
      "Ocean"
    ],
    "readings_on": [
      "かい"
    ],
    "readings_kun": [
      "うみ"
    ]
  },
  "茶": {
    "freq": 1116,
    "jlpt_new": 4,
    "meanings": [
      "Tea"
    ],
    "readings_on": [
      "ちゃ",
      "さ"
    ],
    "readings_kun": []
  },
  "以": {
    "freq": 126,
    "jlpt_new": 4,
    "meanings": [
      "By Means Of",
      "Because",
      "In View Of",
      "Compared With"
    ],
    "readings_on": [
      "い"
    ],
    "readings_kun": [
      "もっ.て"
    ]
  },
  "夏": {
    "freq": 659,
    "jlpt_new": 4,
    "meanings": [
      "Summer"
    ],
    "readings_on": [
      "か",
      "が",
      "げ"
    ],
    "readings_kun": [
      "なつ"
    ]
  },
  "家": {
    "freq": 133,
    "jlpt_new": 4,
    "meanings": [
      "House",
      "Home",
      "Family",
      "Professional",
      "Expert",
      "Performer"
    ],
    "readings_on": [
      "か",
      "け"
    ],
    "readings_kun": [
      "いえ",
      "や",
      "うち"
    ]
  },
  "紙": {
    "freq": 559,
    "jlpt_new": 4,
    "meanings": [
      "Paper"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "かみ"
    ]
  },
  "通": {
    "freq": 80,
    "jlpt_new": 4,
    "meanings": [
      "Traffic",
      "Pass Through",
      "Avenue",
      "Commute",
      "Counter For Letters, Notes, Documents, Etc."
    ],
    "readings_on": [
      "つう",
      "つ"
    ],
    "readings_kun": [
      "とお.る",
      "とお.り",
      "-とお.り",
      "-どお.り",
      "とお.す",
      "とお.し",
      "-どお.し",
      "かよ.う"
    ]
  },
  "強": {
    "freq": 112,
    "jlpt_new": 4,
    "meanings": [
      "Strong"
    ],
    "readings_on": [
      "きょう",
      "ごう"
    ],
    "readings_kun": [
      "つよ.い",
      "つよ.まる",
      "つよ.める",
      "し.いる",
      "こわ.い"
    ]
  },
  "教": {
    "freq": 166,
    "jlpt_new": 4,
    "meanings": [
      "Teach",
      "Faith",
      "Doctrine"
    ],
    "readings_on": [
      "きょう"
    ],
    "readings_kun": [
      "おし.える",
      "おそ.わる"
    ]
  },
  "理": {
    "freq": 86,
    "jlpt_new": 4,
    "meanings": [
      "Logic",
      "Arrangement",
      "Reason",
      "Justice",
      "Truth"
    ],
    "readings_on": [
      "り"
    ],
    "readings_kun": [
      "ことわり"
    ]
  },
  "週": {
    "freq": 540,
    "jlpt_new": 4,
    "meanings": [
      "Week"
    ],
    "readings_on": [
      "しゅう"
    ],
    "readings_kun": []
  },
  "魚": {
    "freq": 1208,
    "jlpt_new": 4,
    "meanings": [
      "Fish"
    ],
    "readings_on": [
      "ぎょ"
    ],
    "readings_kun": [
      "うお",
      "さかな",
      "-ざかな"
    ]
  },
  "鳥": {
    "freq": 1043,
    "jlpt_new": 4,
    "meanings": [
      "Bird",
      "Chicken"
    ],
    "readings_on": [
      "ちょう"
    ],
    "readings_kun": [
      "とり"
    ]
  },
  "黒": {
    "freq": 573,
    "jlpt_new": 4,
    "meanings": [
      "Black"
    ],
    "readings_on": [
      "こく"
    ],
    "readings_kun": [
      "くろ",
      "くろ.ずむ",
      "くろ.い"
    ]
  },
  "住": {
    "freq": 270,
    "jlpt_new": 4,
    "meanings": [
      "Dwell",
      "Reside",
      "Live",
      "Inhabit"
    ],
    "readings_on": [
      "じゅう",
      "ぢゅう",
      "ちゅう"
    ],
    "readings_kun": [
      "す.む",
      "す.まう",
      "-ず.まい"
    ]
  },
  "医": {
    "freq": 437,
    "jlpt_new": 4,
    "meanings": [
      "Doctor",
      "Medicine"
    ],
    "readings_on": [
      "い"
    ],
    "readings_kun": [
      "い.やす",
      "い.する",
      "くすし"
    ]
  },
  "究": {
    "freq": 368,
    "jlpt_new": 4,
    "meanings": [
      "Research",
      "Study"
    ],
    "readings_on": [
      "きゅう",
      "く"
    ],
    "readings_kun": [
      "きわ.める"
    ]
  },
  "者": {
    "freq": 38,
    "jlpt_new": 4,
    "meanings": [
      "Someone",
      "Person"
    ],
    "readings_on": [
      "しゃ"
    ],
    "readings_kun": [
      "もの"
    ]
  },
  "研": {
    "freq": 336,
    "jlpt_new": 4,
    "meanings": [
      "Polish",
      "Study Of",
      "Sharpen"
    ],
    "readings_on": [
      "けん"
    ],
    "readings_kun": [
      "と.ぐ"
    ]
  },
  "場": {
    "freq": 52,
    "jlpt_new": 4,
    "meanings": [
      "Location",
      "Place"
    ],
    "readings_on": [
      "じょう",
      "ちょう"
    ],
    "readings_kun": [
      "ば"
    ]
  },
  "朝": {
    "freq": 248,
    "jlpt_new": 4,
    "meanings": [
      "Morning",
      "Dynasty",
      "Regime",
      "Epoch",
      "Period",
      "(north) Korea"
    ],
    "readings_on": [
      "ちょう"
    ],
    "readings_kun": [
      "あさ"
    ]
  },
  "答": {
    "freq": 486,
    "jlpt_new": 4,
    "meanings": [
      "Solution",
      "Answer"
    ],
    "readings_on": [
      "とう"
    ],
    "readings_kun": [
      "こた.える",
      "こた.え"
    ]
  },
  "買": {
    "freq": 520,
    "jlpt_new": 4,
    "meanings": [
      "Buy"
    ],
    "readings_on": [
      "ばい"
    ],
    "readings_kun": [
      "か.う"
    ]
  },
  "道": {
    "freq": 207,
    "jlpt_new": 4,
    "meanings": [
      "Road-way",
      "Street",
      "District",
      "Journey",
      "Course",
      "Moral",
      "Teachings"
    ],
    "readings_on": [
      "どう",
      "とう"
    ],
    "readings_kun": [
      "みち",
      "いう"
    ]
  },
  "楽": {
    "freq": 373,
    "jlpt_new": 4,
    "meanings": [
      "Music",
      "Comfort",
      "Ease"
    ],
    "readings_on": [
      "がく",
      "らく",
      "ごう"
    ],
    "readings_kun": [
      "たの.しい",
      "たの.しむ",
      "この.む"
    ]
  },
  "事": {
    "freq": 18,
    "jlpt_new": 4,
    "meanings": [
      "Matter",
      "Thing",
      "Fact",
      "Business",
      "Reason",
      "Possibly"
    ],
    "readings_on": [
      "じ",
      "ず"
    ],
    "readings_kun": [
      "こと",
      "つか.う",
      "つか.える"
    ]
  },
  "使": {
    "freq": 219,
    "jlpt_new": 4,
    "meanings": [
      "Use",
      "Send On A Mission",
      "Order",
      "Messenger",
      "Envoy",
      "Ambassador",
      "Cause"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "つか.う",
      "つか.い",
      "-つか.い",
      "-づか.い"
    ]
  },
  "始": {
    "freq": 244,
    "jlpt_new": 4,
    "meanings": [
      "Commence",
      "Begin"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "はじ.める",
      "-はじ.める",
      "はじ.まる"
    ]
  },
  "服": {
    "freq": 873,
    "jlpt_new": 4,
    "meanings": [
      "Clothing",
      "Admit",
      "Obey",
      "Discharge"
    ],
    "readings_on": [
      "ふく"
    ],
    "readings_kun": []
  },
  "物": {
    "freq": 215,
    "jlpt_new": 4,
    "meanings": [
      "Thing",
      "Object",
      "Matter"
    ],
    "readings_on": [
      "ぶつ",
      "もつ"
    ],
    "readings_kun": [
      "もの",
      "もの-"
    ]
  },
  "屋": {
    "freq": 616,
    "jlpt_new": 4,
    "meanings": [
      "Roof",
      "House",
      "Shop",
      "Dealer",
      "Seller"
    ],
    "readings_on": [
      "おく"
    ],
    "readings_kun": [
      "や"
    ]
  },
  "度": {
    "freq": 110,
    "jlpt_new": 4,
    "meanings": [
      "Degrees",
      "Occurrence",
      "Time",
      "Counter For Occurrences",
      "Consider",
      "Attitude"
    ],
    "readings_on": [
      "ど",
      "と",
      "たく"
    ],
    "readings_kun": [
      "たび",
      "-た.い"
    ]
  },
  "待": {
    "freq": 391,
    "jlpt_new": 4,
    "meanings": [
      "Wait",
      "Depend On"
    ],
    "readings_on": [
      "たい"
    ],
    "readings_kun": [
      "ま.つ",
      "-ま.ち"
    ]
  },
  "持": {
    "freq": 119,
    "jlpt_new": 4,
    "meanings": [
      "Hold",
      "Have"
    ],
    "readings_on": [
      "じ"
    ],
    "readings_kun": [
      "も.つ",
      "-も.ち",
      "も.てる"
    ]
  },
  "界": {
    "freq": 158,
    "jlpt_new": 4,
    "meanings": [
      "World",
      "Boundary"
    ],
    "readings_on": [
      "かい"
    ],
    "readings_kun": []
  },
  "発": {
    "freq": 32,
    "jlpt_new": 4,
    "meanings": [
      "Departure",
      "Discharge",
      "Publish",
      "Emit",
      "Start From",
      "Disclose",
      "Counter For Gunshots"
    ],
    "readings_on": [
      "はつ",
      "ほつ"
    ],
    "readings_kun": [
      "た.つ",
      "あば.く",
      "おこ.る",
      "つか.わす",
      "はな.つ"
    ]
  },
  "送": {
    "freq": 311,
    "jlpt_new": 4,
    "meanings": [
      "Escort",
      "Send"
    ],
    "readings_on": [
      "そう"
    ],
    "readings_kun": [
      "おく.る"
    ]
  },
  "重": {
    "freq": 193,
    "jlpt_new": 4,
    "meanings": [
      "Heavy",
      "Important",
      "Esteem",
      "Respect",
      "Heap Up",
      "Pile Up",
      "Nest Of Boxes",
      "-fold"
    ],
    "readings_on": [
      "じゅう",
      "ちょう"
    ],
    "readings_kun": [
      "え",
      "おも.い",
      "おも.り",
      "おも.なう",
      "かさ.ねる",
      "かさ.なる",
      "おも"
    ]
  },
  "起": {
    "freq": 374,
    "jlpt_new": 4,
    "meanings": [
      "Rouse",
      "Wake Up",
      "Get Up"
    ],
    "readings_on": [
      "き"
    ],
    "readings_kun": [
      "お.きる",
      "お.こる",
      "お.こす",
      "おこ.す",
      "た.つ"
    ]
  },
  "院": {
    "freq": 150,
    "jlpt_new": 4,
    "meanings": [
      "Inst.",
      "Institution",
      "Temple",
      "Mansion",
      "School"
    ],
    "readings_on": [
      "いん"
    ],
    "readings_kun": []
  },
  "終": {
    "freq": 256,
    "jlpt_new": 4,
    "meanings": [
      "End",
      "Finish"
    ],
    "readings_on": [
      "しゅう"
    ],
    "readings_kun": [
      "お.わる",
      "-お.わる",
      "おわ.る",
      "お.える",
      "つい",
      "つい.に"
    ]
  },
  "習": {
    "freq": 706,
    "jlpt_new": 4,
    "meanings": [
      "Learn"
    ],
    "readings_on": [
      "しゅう",
      "じゅ"
    ],
    "readings_kun": [
      "なら.う",
      "なら.い"
    ]
  },
  "転": {
    "freq": 327,
    "jlpt_new": 4,
    "meanings": [
      "Revolve",
      "Turn Around",
      "Change"
    ],
    "readings_on": [
      "てん"
    ],
    "readings_kun": [
      "ころ.がる",
      "ころ.げる",
      "ころ.がす",
      "ころ.ぶ",
      "まろ.ぶ",
      "うたた",
      "うつ.る",
      "くる.めく"
    ]
  },
  "運": {
    "freq": 255,
    "jlpt_new": 4,
    "meanings": [
      "Carry",
      "Luck",
      "Destiny",
      "Fate",
      "Lot",
      "Transport",
      "Progress",
      "Advance"
    ],
    "readings_on": [
      "うん"
    ],
    "readings_kun": [
      "はこ.ぶ"
    ]
  },
  "開": {
    "freq": 59,
    "jlpt_new": 4,
    "meanings": [
      "Open",
      "Unfold",
      "Unseal"
    ],
    "readings_on": [
      "かい"
    ],
    "readings_kun": [
      "ひら.く",
      "ひら.き",
      "-びら.き",
      "ひら.ける",
      "あ.く",
      "あ.ける"
    ]
  },
  "集": {
    "freq": 210,
    "jlpt_new": 4,
    "meanings": [
      "Gather",
      "Meet",
      "Congregate",
      "Swarm",
      "Flock"
    ],
    "readings_on": [
      "しゅう"
    ],
    "readings_kun": [
      "あつ.まる",
      "あつ.める",
      "つど.う"
    ]
  },
  "飲": {
    "freq": 969,
    "jlpt_new": 4,
    "meanings": [
      "Drink",
      "Smoke",
      "Take"
    ],
    "readings_on": [
      "いん",
      "おん"
    ],
    "readings_kun": [
      "の.む",
      "-の.み"
    ]
  },
  "業": {
    "freq": 43,
    "jlpt_new": 4,
    "meanings": [
      "Business",
      "Vocation",
      "Arts",
      "Performance"
    ],
    "readings_on": [
      "ぎょう",
      "ごう"
    ],
    "readings_kun": [
      "わざ"
    ]
  },
  "漢": {
    "freq": 1487,
    "jlpt_new": 4,
    "meanings": [
      "Sino-",
      "China"
    ],
    "readings_on": [
      "かん"
    ],
    "readings_kun": []
  },
  "歌": {
    "freq": 519,
    "jlpt_new": 4,
    "meanings": [
      "Song",
      "Sing"
    ],
    "readings_on": [
      "か"
    ],
    "readings_kun": [
      "うた",
      "うた.う"
    ]
  },
  "親": {
    "freq": 406,
    "jlpt_new": 4,
    "meanings": [
      "Parent",
      "Intimacy",
      "Relative",
      "Familiarity",
      "Dealer (cards)"
    ],
    "readings_on": [
      "しん"
    ],
    "readings_kun": [
      "おや",
      "おや-",
      "した.しい",
      "した.しむ"
    ]
  },
  "病": {
    "freq": 384,
    "jlpt_new": 4,
    "meanings": [
      "Ill",
      "Sick"
    ],
    "readings_on": [
      "びょう",
      "へい"
    ],
    "readings_kun": [
      "や.む",
      "-や.み",
      "やまい"
    ]
  },
  "別": {
    "freq": 214,
    "jlpt_new": 4,
    "meanings": [
      "Separate",
      "Branch Off",
      "Diverge",
      "Fork",
      "Another",
      "Extra",
      "Specially"
    ],
    "readings_on": [
      "べつ"
    ],
    "readings_kun": [
      "わか.れる",
      "わ.ける"
    ]
  },
  "注": {
    "freq": 497,
    "jlpt_new": 4,
    "meanings": [
      "Pour",
      "Irrigate",
      "Shed (tears)",
      "Flow Into",
      "Concentrate On",
      "Notes",
      "Comment",
      "Annotate"
    ],
    "readings_on": [
      "ちゅう"
    ],
    "readings_kun": [
      "そそ.ぐ",
      "さ.す",
      "つ.ぐ"
    ]
  },
  "洋": {
    "freq": 763,
    "jlpt_new": 4,
    "meanings": [
      "Ocean",
      "Sea",
      "Foreign",
      "Western Style"
    ],
    "readings_on": [
      "よう"
    ],
    "readings_kun": []
  },
  "特": {
    "freq": 234,
    "jlpt_new": 4,
    "meanings": [
      "Special"
    ],
    "readings_on": [
      "とく"
    ],
    "readings_kun": []
  },
  "意": {
    "freq": 99,
    "jlpt_new": 4,
    "meanings": [
      "Idea",
      "Mind",
      "Heart",
      "Taste",
      "Thought",
      "Desire",
      "Care",
      "Liking"
    ],
    "readings_on": [
      "い"
    ],
    "readings_kun": []
  },
  "味": {
    "freq": 442,
    "jlpt_new": 4,
    "meanings": [
      "Flavor",
      "Taste"
    ],
    "readings_on": [
      "み"
    ],
    "readings_kun": [
      "あじ",
      "あじ.わう"
    ]
  },
  "勉": {
    "freq": 1066,
    "jlpt_new": 4,
    "meanings": [
      "Exertion",
      "Endeavour",
      "Encourage",
      "Strive",
      "Make Effort",
      "Diligent"
    ],
    "readings_on": [
      "べん"
    ],
    "readings_kun": [
      "つと.める"
    ]
  },
  "旅": {
    "freq": 783,
    "jlpt_new": 4,
    "meanings": [
      "Trip",
      "Travel"
    ],
    "readings_on": [
      "りょ"
    ],
    "readings_kun": [
      "たび"
    ]
  },
  "員": {
    "freq": 54,
    "jlpt_new": 4,
    "meanings": [
      "Employee",
      "Member",
      "Number",
      "The One In Charge"
    ],
    "readings_on": [
      "いん"
    ],
    "readings_kun": []
  },
  "動": {
    "freq": 73,
    "jlpt_new": 4,
    "meanings": [
      "Move",
      "Motion",
      "Change",
      "Confusion",
      "Shift",
      "Shake"
    ],
    "readings_on": [
      "どう"
    ],
    "readings_kun": [
      "うご.く",
      "うご.かす"
    ]
  },
  "悪": {
    "freq": 530,
    "jlpt_new": 4,
    "meanings": [
      "Bad",
      "Vice",
      "Rascal",
      "False",
      "Evil",
      "Wrong"
    ],
    "readings_on": [
      "あく",
      "お"
    ],
    "readings_kun": [
      "わる.い",
      "わる-",
      "あ.し",
      "にく.い",
      "-にく.い",
      "ああ",
      "いずくに",
      "いずくんぞ",
      "にく.む"
    ]
  },
  "族": {
    "freq": 393,
    "jlpt_new": 4,
    "meanings": [
      "Tribe",
      "Family"
    ],
    "readings_on": [
      "ぞく"
    ],
    "readings_kun": []
  },
  "着": {
    "freq": 376,
    "jlpt_new": 4,
    "meanings": [
      "Don",
      "Arrive",
      "Wear",
      "Counter For Suits Of Clothing"
    ],
    "readings_on": [
      "ちゃく",
      "じゃく"
    ],
    "readings_kun": [
      "き.る",
      "-ぎ",
      "き.せる",
      "-き.せ",
      "つ.く",
      "つ.ける"
    ]
  },
  "野": {
    "freq": 120,
    "jlpt_new": 4,
    "meanings": [
      "Plains",
      "Field",
      "Rustic",
      "Civilian Life"
    ],
    "readings_on": [
      "や",
      "しょ"
    ],
    "readings_kun": [
      "の",
      "の-"
    ]
  },
  "風": {
    "freq": 558,
    "jlpt_new": 4,
    "meanings": [
      "Wind",
      "Air",
      "Style",
      "Manner"
    ],
    "readings_on": [
      "ふう",
      "ふ"
    ],
    "readings_kun": [
      "かぜ",
      "かざ-",
      "-かぜ"
    ]
  },
  "新": {
    "freq": 51,
    "jlpt_new": 4,
    "meanings": [
      "New"
    ],
    "readings_on": [
      "しん"
    ],
    "readings_kun": [
      "あたら.しい",
      "あら.た",
      "あら-",
      "にい-"
    ]
  },
  "問": {
    "freq": 64,
    "jlpt_new": 4,
    "meanings": [
      "Question",
      "Ask",
      "Problem"
    ],
    "readings_on": [
      "もん"
    ],
    "readings_kun": [
      "と.う",
      "と.い",
      "とん"
    ]
  },
  "銀": {
    "freq": 395,
    "jlpt_new": 4,
    "meanings": [
      "Silver"
    ],
    "readings_on": [
      "ぎん"
    ],
    "readings_kun": [
      "しろがね"
    ]
  },
  "題": {
    "freq": 96,
    "jlpt_new": 4,
    "meanings": [
      "Topic",
      "Subject"
    ],
    "readings_on": [
      "だい"
    ],
    "readings_kun": []
  },
  "館": {
    "freq": 613,
    "jlpt_new": 4,
    "meanings": [
      "Building",
      "Mansion",
      "Large Building",
      "Palace"
    ],
    "readings_on": [
      "かん"
    ],
    "readings_kun": [
      "やかた",
      "たて"
    ]
  },
  "駅": {
    "freq": 724,
    "jlpt_new": 4,
    "meanings": [
      "Station"
    ],
    "readings_on": [
      "えき"
    ],
    "readings_kun": []
  },
  "料": {
    "freq": 295,
    "jlpt_new": 4,
    "meanings": [
      "Fee",
      "Materials"
    ],
    "readings_on": [
      "りょう"
    ],
    "readings_kun": []
  },
  "映": {
    "freq": 404,
    "jlpt_new": 4,
    "meanings": [
      "Reflect",
      "Reflection",
      "Projection"
    ],
    "readings_on": [
      "えい"
    ],
    "readings_kun": [
      "うつ.る",
      "うつ.す",
      "は.える",
      "-ば.え"
    ]
  },
  "私": {
    "freq": 242,
    "jlpt_new": 4,
    "meanings": [
      "Private",
      "I",
      "Me"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "わたくし",
      "わたし"
    ]
  },
  "帰": {
    "freq": 504,
    "jlpt_new": 4,
    "meanings": [
      "Homecoming",
      "Arrive At",
      "Lead To",
      "Result In"
    ],
    "readings_on": [
      "き"
    ],
    "readings_kun": [
      "かえ.る",
      "かえ.す",
      "おく.る",
      "とつ.ぐ"
    ]
  },
  "春": {
    "freq": 579,
    "jlpt_new": 4,
    "meanings": [
      "Springtime",
      "Spring (season)"
    ],
    "readings_on": [
      "しゅん"
    ],
    "readings_kun": [
      "はる"
    ]
  },
  "昼": {
    "freq": 1115,
    "jlpt_new": 4,
    "meanings": [
      "Daytime",
      "Noon"
    ],
    "readings_on": [
      "ちゅう"
    ],
    "readings_kun": [
      "ひる"
    ]
  },
  "秋": {
    "freq": 635,
    "jlpt_new": 4,
    "meanings": [
      "Autumn"
    ],
    "readings_on": [
      "しゅう"
    ],
    "readings_kun": [
      "あき",
      "とき"
    ]
  },
  "計": {
    "freq": 228,
    "jlpt_new": 4,
    "meanings": [
      "Plot",
      "Plan",
      "Scheme",
      "Measure"
    ],
    "readings_on": [
      "けい"
    ],
    "readings_kun": [
      "はか.る",
      "はか.らう"
    ]
  },
  "建": {
    "freq": 300,
    "jlpt_new": 4,
    "meanings": [
      "Build"
    ],
    "readings_on": [
      "けん",
      "こん"
    ],
    "readings_kun": [
      "た.てる",
      "た.て",
      "-だ.て",
      "た.つ"
    ]
  },
  "英": {
    "freq": 430,
    "jlpt_new": 4,
    "meanings": [
      "England",
      "English",
      "Hero",
      "Outstanding",
      "Calyx"
    ],
    "readings_on": [
      "えい"
    ],
    "readings_kun": [
      "はなぶさ"
    ]
  },
  "飯": {
    "freq": 1046,
    "jlpt_new": 4,
    "meanings": [
      "Meal",
      "Boiled Rice"
    ],
    "readings_on": [
      "はん"
    ],
    "readings_kun": [
      "めし"
    ]
  },
  "曜": {
    "freq": 940,
    "jlpt_new": 4,
    "meanings": [
      "Weekday"
    ],
    "readings_on": [
      "よう"
    ],
    "readings_kun": []
  },
  "品": {
    "freq": 225,
    "jlpt_new": 4,
    "meanings": [
      "Goods",
      "Refinement",
      "Dignity",
      "Article",
      "Counter For Meal Courses"
    ],
    "readings_on": [
      "ひん",
      "ほん"
    ],
    "readings_kun": [
      "しな"
    ]
  },
  "急": {
    "freq": 309,
    "jlpt_new": 4,
    "meanings": [
      "Hurry",
      "Emergency",
      "Sudden",
      "Steep"
    ],
    "readings_on": [
      "きゅう"
    ],
    "readings_kun": [
      "いそ.ぐ",
      "いそ.ぎ",
      "せ.く"
    ]
  },
  "真": {
    "freq": 279,
    "jlpt_new": 4,
    "meanings": [
      "True",
      "Reality",
      "Buddhist Sect"
    ],
    "readings_on": [
      "しん"
    ],
    "readings_kun": [
      "ま",
      "ま-",
      "まこと"
    ]
  },
  "堂": {
    "freq": 1010,
    "jlpt_new": 4,
    "meanings": [
      "Public Chamber",
      "Hall"
    ],
    "readings_on": [
      "どう"
    ],
    "readings_kun": []
  },
  "試": {
    "freq": 392,
    "jlpt_new": 4,
    "meanings": [
      "Test",
      "Try",
      "Attempt",
      "Experiment",
      "Ordeal"
    ],
    "readings_on": [
      "し"
    ],
    "readings_kun": [
      "こころ.みる",
      "ため.す"
    ]
  },
  "借": {
    "freq": 932,
    "jlpt_new": 4,
    "meanings": [
      "Borrow",
      "Rent"
    ],
    "readings_on": [
      "しゃく"
    ],
    "readings_kun": [
      "か.りる"
    ]
  },
  "験": {
    "freq": 410,
    "jlpt_new": 4,
    "meanings": [
      "Verification",
      "Effect",
      "Testing"
    ],
    "readings_on": [
      "けん",
      "げん"
    ],
    "readings_kun": [
      "あかし",
      "しるし",
      "ため.す",
      "ためし"
    ]
  },
  "質": {
    "freq": 389,
    "jlpt_new": 4,
    "meanings": [
      "Substance",
      "Quality",
      "Matter",
      "Temperament"
    ],
    "readings_on": [
      "しつ",
      "しち",
      "ち"
    ],
    "readings_kun": [
      "たち",
      "ただ.す",
      "もと",
      "わりふ"
    ]
  },
  "貸": {
    "freq": 995,
    "jlpt_new": 4,
    "meanings": [
      "Lend"
    ],
    "readings_on": [
      "たい"
    ],
    "readings_kun": [
      "か.す",
      "か.し-",
      "かし-"
    ]
  }
};
const KanjiItemScreen = ({ character, level, isOpen, onClose, freq, on: on2, kun, meanings }) => {
  const { darkMode } = useDarkMode();
  return /* @__PURE__ */ React.createElement(IonModal, { isOpen, onWillDismiss: onClose }, " ", /* @__PURE__ */ React.createElement(IonContent, null, /* @__PURE__ */ React.createElement("div", { className: darkMode ? "itemscreen-content dark" : "itemscreen-content light" }, /* @__PURE__ */ React.createElement("h2", null, character), /* @__PURE__ */ React.createElement(SectionDivider, null), /* @__PURE__ */ React.createElement("h5", null, "Meaning:"), meanings.map((m2) => /* @__PURE__ */ React.createElement("p", null, m2)), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h5", null, "Frequency: ", freq), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h5", null, "On Readings:"), on2 ? on2.map((m2) => /* @__PURE__ */ React.createElement("p", null, m2)) : "N/A", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h5", null, "Kun Readings:"), kun ? kun.map((m2) => /* @__PURE__ */ React.createElement("p", null, m2)) : "N/A", /* @__PURE__ */ React.createElement(IonProgressBar, { value: level / 20 }), /* @__PURE__ */ React.createElement(IonFooter, { style: { position: "fixed", bottom: "0", width: "100%", left: "0" } }, /* @__PURE__ */ React.createElement(IonToolbar, null, /* @__PURE__ */ React.createElement(IonButton, { onClick: onClose, style: { width: "100%", background: "white", height: "75px" }, color: "light", fill: "clear" }, /* @__PURE__ */ React.createElement(IonLabel, { style: { color: "black" } }, /* @__PURE__ */ React.createElement("b", null, "Close"))))))));
};
const LookupKanji = ({ isOpen, data, info, onClose }) => {
  let [results, setResults] = reactExports.useState(data);
  const [selectedCharacter, setSelectedCharacter] = reactExports.useState(null);
  const handleInput = (ev) => {
    let query = "";
    const target = ev.target;
    if (target)
      query = target.value.toLowerCase();
    setResults(data.filter((d2) => d2[0].toLowerCase().indexOf(query) > -1 || d2[1].join().toLowerCase().indexOf(query) > -1));
  };
  const handleCloseItem = () => {
    setSelectedCharacter(null);
  };
  return /* @__PURE__ */ React.createElement(IonModal, { isOpen, onWillDismiss: onClose }, /* @__PURE__ */ React.createElement("div", { className: "itemscreen-content" }, /* @__PURE__ */ React.createElement(IonSearchbar, { color: "light", onIonInput: (ev) => handleInput(ev) }), /* @__PURE__ */ React.createElement(IonContent, { className: "y" }, /* @__PURE__ */ React.createElement(IonList, null, results.slice(0, 20).map((result) => /* @__PURE__ */ React.createElement(IonItem, { key: result[0], button: "true", onClick: () => setSelectedCharacter(info[result[0]]) }, /* @__PURE__ */ React.createElement(IonLabel, null, result[0]), /* @__PURE__ */ React.createElement(IonNote, { color: "medium" }, result[1][0])))))), /* @__PURE__ */ React.createElement(IonFooter, { style: { position: "fixed", bottom: "0", width: "100%", left: "0" } }, /* @__PURE__ */ React.createElement(IonToolbar, null, /* @__PURE__ */ React.createElement(IonButton, { onClick: onClose, style: { width: "100%" }, color: "light", fill: "clear" }, /* @__PURE__ */ React.createElement(IonLabel, { style: { color: "black" } }, /* @__PURE__ */ React.createElement("b", null, "Close"))))), selectedCharacter !== null && /* @__PURE__ */ React.createElement(
    KanjiItemScreen,
    {
      isOpen: selectedCharacter !== null,
      onClose: handleCloseItem,
      character: selectedCharacter == null ? void 0 : selectedCharacter.character,
      pronunciation: selectedCharacter == null ? void 0 : selectedCharacter.pronunciation,
      level: selectedCharacter == null ? void 0 : selectedCharacter.level,
      freq: selectedCharacter == null ? void 0 : selectedCharacter.freq,
      meanings: selectedCharacter == null ? void 0 : selectedCharacter.meanings,
      on: selectedCharacter == null ? void 0 : selectedCharacter.readings_on,
      kun: selectedCharacter == null ? void 0 : selectedCharacter.readings_kun
    }
  ));
};
const itemsPerRow = 4;
const Kanji = (data) => {
  const [selectedCharacter, setSelectedCharacter] = reactExports.useState(null);
  const [isSearchVisible, setIsSearchVisible] = reactExports.useState(false);
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const { darkMode } = useDarkMode();
  reactExports.useEffect(() => {
    if (data && data["data"]) {
      setIsLoading(false);
    }
  }, [data]);
  const handleGridItemClick = (character) => {
    var temp;
    if (character.character in n5Kanji) {
      temp = n5Kanji[character.character];
    } else {
      temp = n4Kanji[character.character];
    }
    temp["character"] = character.character;
    temp["level"] = character.level;
    setSelectedCharacter(temp);
  };
  const toggleSearch = () => {
    setIsSearchVisible(!isSearchVisible);
  };
  const handleCloseItem = () => {
    setSelectedCharacter(null);
  };
  const objectToKeyValuePairs = (obj) => {
    return Object.entries(obj).map(([key, value]) => [
      key,
      value.meanings
    ]);
  };
  return /* @__PURE__ */ React.createElement("div", { className: darkMode ? "mainSection dark" : "mainSection light" }, /* @__PURE__ */ React.createElement(IonHeader, null, /* @__PURE__ */ React.createElement(IonToolbar, { color: "translucent" }, /* @__PURE__ */ React.createElement(IonButtons, { slot: "start" }, /* @__PURE__ */ React.createElement(IonButton, { color: "translucent", onClick: toggleSearch }, /* @__PURE__ */ React.createElement(IonIcon, { color: "primary", slot: "start", icon: search })), /* @__PURE__ */ React.createElement("h1", { style: { fontFamily: "Montserrat", margin: "auto", textAlign: "center", width: "100%" } }, "Kanji")))), /* @__PURE__ */ React.createElement(SectionDivider, null), isLoading && /* @__PURE__ */ React.createElement(Loading, null), !isLoading && /* @__PURE__ */ React.createElement(IonContent, null, /* @__PURE__ */ React.createElement("h2", null, "N5"), /* @__PURE__ */ React.createElement(SectionDivider, null), /* @__PURE__ */ React.createElement(IonGrid, { style: { marginBottom: "200px" } }, data && data["data"].filter((x2) => {
    return x2.jlpt === 5;
  }).reduce((rows, item, index) => {
    if (index % itemsPerRow === 0) {
      rows.push([]);
    }
    rows[rows.length - 1].push(item);
    return rows;
  }, []).map((row, rowIndex) => /* @__PURE__ */ React.createElement(IonRow, { key: rowIndex }, row.map((item, colIndex) => /* @__PURE__ */ React.createElement(IonCol, { key: colIndex }, /* @__PURE__ */ React.createElement(
    GridItem,
    {
      character: item.character,
      level: item.level,
      onClick: handleGridItemClick,
      pronunciation: ""
    }
  )))))), /* @__PURE__ */ React.createElement("h2", { style: { marginTop: "20px", color: "white" } }, "N4"), /* @__PURE__ */ React.createElement(SectionDivider, null), /* @__PURE__ */ React.createElement(IonGrid, { style: { marginBottom: "80px" } }, data && data["data"].filter((x2) => x2.jlpt === 4).reduce((rows, item, index) => {
    if (index % itemsPerRow === 0) {
      rows.push([]);
    }
    rows[rows.length - 1].push(item);
    return rows;
  }, []).map((row, rowIndex) => /* @__PURE__ */ React.createElement(IonRow, { key: rowIndex }, row.map((item, colIndex) => /* @__PURE__ */ React.createElement(IonCol, { key: colIndex }, /* @__PURE__ */ React.createElement(
    GridItem,
    {
      character: item.character,
      level: item.level,
      onClick: handleGridItemClick,
      pronunciation: ""
    }
  ))))))), selectedCharacter !== null && /* @__PURE__ */ React.createElement(
    KanjiItemScreen,
    {
      isOpen: selectedCharacter !== null,
      onClose: handleCloseItem,
      character: selectedCharacter == null ? void 0 : selectedCharacter.character,
      pronunciation: selectedCharacter == null ? void 0 : selectedCharacter.pronunciation,
      level: selectedCharacter == null ? void 0 : selectedCharacter.level,
      freq: selectedCharacter == null ? void 0 : selectedCharacter.freq,
      meanings: selectedCharacter == null ? void 0 : selectedCharacter.meanings,
      on: selectedCharacter == null ? void 0 : selectedCharacter.readings_on,
      kun: selectedCharacter == null ? void 0 : selectedCharacter.readings_kun
    }
  ), isSearchVisible && /* @__PURE__ */ React.createElement(LookupKanji, { isOpen: isSearchVisible, data: [
    ...objectToKeyValuePairs(n5Kanji),
    ...objectToKeyValuePairs(n4Kanji)
  ], onClose: toggleSearch, info: Object.assign({}, n4Kanji, n5Kanji) }));
};
const LEFT = "Left";
const RIGHT = "Right";
const UP = "Up";
const DOWN = "Down";
const defaultProps = {
  delta: 10,
  preventScrollOnSwipe: false,
  rotationAngle: 0,
  trackMouse: false,
  trackTouch: true,
  swipeDuration: Infinity,
  touchEventOptions: { passive: true }
};
const initialState = {
  first: true,
  initial: [0, 0],
  start: 0,
  swiping: false,
  xy: [0, 0]
};
const mouseMove = "mousemove";
const mouseUp = "mouseup";
const touchEnd = "touchend";
const touchMove = "touchmove";
const touchStart = "touchstart";
function getDirection(absX, absY, deltaX, deltaY) {
  if (absX > absY) {
    if (deltaX > 0) {
      return RIGHT;
    }
    return LEFT;
  } else if (deltaY > 0) {
    return DOWN;
  }
  return UP;
}
function rotateXYByAngle(pos, angle) {
  if (angle === 0)
    return pos;
  const angleInRadians = Math.PI / 180 * angle;
  const x2 = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);
  const y2 = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);
  return [x2, y2];
}
function getHandlers(set, handlerProps) {
  const onStart = (event) => {
    const isTouch = "touches" in event;
    if (isTouch && event.touches.length > 1)
      return;
    set((state, props) => {
      if (props.trackMouse && !isTouch) {
        document.addEventListener(mouseMove, onMove);
        document.addEventListener(mouseUp, onUp);
      }
      const { clientX, clientY } = isTouch ? event.touches[0] : event;
      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);
      props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({ event });
      return Object.assign(Object.assign(Object.assign({}, state), initialState), { initial: xy.slice(), xy, start: event.timeStamp || 0 });
    });
  };
  const onMove = (event) => {
    set((state, props) => {
      const isTouch = "touches" in event;
      if (isTouch && event.touches.length > 1) {
        return state;
      }
      if (event.timeStamp - state.start > props.swipeDuration) {
        return state.swiping ? Object.assign(Object.assign({}, state), { swiping: false }) : state;
      }
      const { clientX, clientY } = isTouch ? event.touches[0] : event;
      const [x2, y2] = rotateXYByAngle([clientX, clientY], props.rotationAngle);
      const deltaX = x2 - state.xy[0];
      const deltaY = y2 - state.xy[1];
      const absX = Math.abs(deltaX);
      const absY = Math.abs(deltaY);
      const time = (event.timeStamp || 0) - state.start;
      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);
      const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];
      const dir = getDirection(absX, absY, deltaX, deltaY);
      const delta = typeof props.delta === "number" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;
      if (absX < delta && absY < delta && !state.swiping)
        return state;
      const eventData = {
        absX,
        absY,
        deltaX,
        deltaY,
        dir,
        event,
        first: state.first,
        initial: state.initial,
        velocity,
        vxvy
      };
      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);
      props.onSwiping && props.onSwiping(eventData);
      let cancelablePageSwipe = false;
      if (props.onSwiping || props.onSwiped || props[`onSwiped${dir}`]) {
        cancelablePageSwipe = true;
      }
      if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {
        event.preventDefault();
      }
      return Object.assign(Object.assign({}, state), {
        // first is now always false
        first: false,
        eventData,
        swiping: true
      });
    });
  };
  const onEnd = (event) => {
    set((state, props) => {
      let eventData;
      if (state.swiping && state.eventData) {
        if (event.timeStamp - state.start < props.swipeDuration) {
          eventData = Object.assign(Object.assign({}, state.eventData), { event });
          props.onSwiped && props.onSwiped(eventData);
          const onSwipedDir = props[`onSwiped${eventData.dir}`];
          onSwipedDir && onSwipedDir(eventData);
        }
      } else {
        props.onTap && props.onTap({ event });
      }
      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });
      return Object.assign(Object.assign(Object.assign({}, state), initialState), { eventData });
    });
  };
  const cleanUpMouse = () => {
    document.removeEventListener(mouseMove, onMove);
    document.removeEventListener(mouseUp, onUp);
  };
  const onUp = (e2) => {
    cleanUpMouse();
    onEnd(e2);
  };
  const attachTouch = (el2, props) => {
    let cleanup = () => {
    };
    if (el2 && el2.addEventListener) {
      const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);
      const tls = [
        [touchStart, onStart, baseOptions],
        // preventScrollOnSwipe option supersedes touchEventOptions.passive
        [
          touchMove,
          onMove,
          Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? { passive: false } : {})
        ],
        [touchEnd, onEnd, baseOptions]
      ];
      tls.forEach(([e2, h2, o2]) => el2.addEventListener(e2, h2, o2));
      cleanup = () => tls.forEach(([e2, h2]) => el2.removeEventListener(e2, h2));
    }
    return cleanup;
  };
  const onRef = (el2) => {
    if (el2 === null)
      return;
    set((state, props) => {
      if (state.el === el2)
        return state;
      const addState = {};
      if (state.el && state.el !== el2 && state.cleanUpTouch) {
        state.cleanUpTouch();
        addState.cleanUpTouch = void 0;
      }
      if (props.trackTouch && el2) {
        addState.cleanUpTouch = attachTouch(el2, props);
      }
      return Object.assign(Object.assign(Object.assign({}, state), { el: el2 }), addState);
    });
  };
  const output = {
    ref: onRef
  };
  if (handlerProps.trackMouse) {
    output.onMouseDown = onStart;
  }
  return [output, attachTouch];
}
function updateTransientState(state, props, previousProps, attachTouch) {
  if (!props.trackTouch || !state.el) {
    if (state.cleanUpTouch) {
      state.cleanUpTouch();
    }
    return Object.assign(Object.assign({}, state), { cleanUpTouch: void 0 });
  }
  if (!state.cleanUpTouch) {
    return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });
  }
  if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {
    state.cleanUpTouch();
    return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });
  }
  return state;
}
function useSwipeable(options) {
  const { trackMouse } = options;
  const transientState = reactExports.useRef(Object.assign({}, initialState));
  const transientProps = reactExports.useRef(Object.assign({}, defaultProps));
  const previousProps = reactExports.useRef(Object.assign({}, transientProps.current));
  previousProps.current = Object.assign({}, transientProps.current);
  transientProps.current = Object.assign(Object.assign({}, defaultProps), options);
  let defaultKey;
  for (defaultKey in defaultProps) {
    if (transientProps.current[defaultKey] === void 0) {
      transientProps.current[defaultKey] = defaultProps[defaultKey];
    }
  }
  const [handlers, attachTouch] = reactExports.useMemo(() => getHandlers((stateSetter) => transientState.current = stateSetter(transientState.current, transientProps.current), { trackMouse }), [trackMouse]);
  transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);
  return handlers;
}
const QuizGridItem = ({ character, onClick, adjHeight = "80px", borderC = "#ffffff" }) => {
  return /* @__PURE__ */ React.createElement("div", { className: "grid-item grid-item-quiz", onClick: () => onClick({ character }), style: { height: adjHeight, borderColor: borderC } }, /* @__PURE__ */ React.createElement("b", null, character));
};
const MultipleChoiceQ = ({ onAnswer, data, type }) => {
  const [selectedAnswer, setSelectedAnswer] = reactExports.useState(null);
  const handleSelectAnswer = (selection) => {
    setSelectedAnswer(selection.character);
    setTimeout(() => {
      onAnswer(data.rightAnswer, selection.character === data.rightAnswer);
    }, 500);
  };
  const renderAnswerButton = (option, index) => {
    const isCorrect = option === data.rightAnswer;
    const isSelected = selectedAnswer === option;
    return /* @__PURE__ */ React.createElement(IonCol, { size: type === "kanji" ? "12" : "6", key: index }, /* @__PURE__ */ React.createElement(QuizGridItem, { character: option, adjHeight: type === "kanji" ? "40px" : "80px", borderC: isSelected ? isCorrect ? "green" : "red" : "#ffffff", onClick: selectedAnswer !== null ? () => null : handleSelectAnswer }));
  };
  return /* @__PURE__ */ React.createElement("div", { className: "multiple-choice question" }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("h3", null, "Select the corresponding character(s)"), /* @__PURE__ */ React.createElement(IonGrid, null, /* @__PURE__ */ React.createElement(IonRow, null, /* @__PURE__ */ React.createElement(IonCol, { size: "12" }, /* @__PURE__ */ React.createElement("div", { className: "hiragana-display" }, /* @__PURE__ */ React.createElement("h1", null, data.character)))), /* @__PURE__ */ React.createElement(IonRow, null, data.others.map((option, index) => renderAnswerButton(option, index))))));
};
const LinkingQ = ({ onAnswer, data }) => {
  const [selectedAnswers, setSelectedAnswers] = reactExports.useState({});
  const [selectedCharacter, setSelectedCharacter] = reactExports.useState(null);
  const [failAmount, setFailAmount] = reactExports.useState(0);
  const checkSelectedAnswerOption = async (option) => {
    if (selectedCharacter === null || isAnsweredCorrectly(option.wrongCharacter))
      return;
    if (selectedCharacter !== option.wrongCharacter) {
      setFailAmount(failAmount + 1);
      if (failAmount === 1)
        handleSelectAnswer({});
    } else {
      await setSelectedAnswers((prevAnswers) => Object.assign({}, prevAnswers, { [selectedCharacter]: option.wrongPronunciation }));
    }
    if (Object.keys(selectedAnswers).length === data.length - 1) {
      handleSelectAnswer(Object.assign(selectedAnswers, { [selectedCharacter]: option.wrongPronunciation }));
    }
    setSelectedCharacter(null);
  };
  const handleSelectCharacter = (option) => {
    if (!isAnsweredCorrectly(option.character))
      setSelectedCharacter(option.character);
  };
  const isAnsweredCorrectly = (character) => {
    return character in selectedAnswers;
  };
  const handleSelectAnswer = (selection) => {
    const head = document.getElementById("linkhead");
    if (Object.keys(selection).length === data.length) {
      head.style.color = "green";
      head.innerText = "Correct!";
    } else {
      head.style.color = "red";
      head.innerText = "Wrong Answer!";
    }
    setTimeout(() => {
      onAnswer(data[0].character, Object.keys(selection).length === data.length);
    }, 500);
  };
  return /* @__PURE__ */ React.createElement("div", { className: "linking question" }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("h3", { id: "linkhead" }, "Link the left characters to their respective sounds"), /* @__PURE__ */ React.createElement(IonGrid, null, data.map((option, colIndex) => /* @__PURE__ */ React.createElement(IonRow, { key: colIndex }, /* @__PURE__ */ React.createElement(IonCol, null, /* @__PURE__ */ React.createElement(
    QuizGridItem,
    {
      character: option.character,
      onClick: () => handleSelectCharacter(option),
      adjHeight: "20px",
      borderC: isAnsweredCorrectly(option.character) ? "#000000" : selectedCharacter === option.character ? "green" : "#ffffff"
    }
  )), /* @__PURE__ */ React.createElement(IonCol, null, /* @__PURE__ */ React.createElement(
    QuizGridItem,
    {
      character: option.wrongPronunciation,
      onClick: () => checkSelectedAnswerOption(option),
      adjHeight: "20px",
      borderC: isAnsweredCorrectly(option.wrongCharacter) ? "#000000" : "#ffffff"
    }
  )))))), /* @__PURE__ */ React.createElement("h3", null, 2 - failAmount, " mistakes allowed!"), /* @__PURE__ */ React.createElement(IonProgressBar, { color: failAmount === 0 ? "success" : failAmount === 1 ? "warning" : "danger", value: failAmount / 2 }));
};
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
const QuizOver = ({ userResponses, onClose, totalQuestions }) => {
  return /* @__PURE__ */ React.createElement("div", { className: "fullscreen-modal-overlay" }, /* @__PURE__ */ React.createElement("div", { className: "fullscreen-modal-content" }, /* @__PURE__ */ React.createElement("h2", null, "Quiz Over!"), /* @__PURE__ */ React.createElement("p", null, `You got ${userResponses.reduce((counter, value) => {
    if (value[1])
      counter++;
    return counter;
  }, 0)} out of ${totalQuestions} correct!`), /* @__PURE__ */ React.createElement(IonProgressBar, { color: "success", value: userResponses.reduce((counter, value) => {
    if (value[1])
      counter++;
    return counter;
  }, 0) / totalQuestions }, " "), /* @__PURE__ */ React.createElement(IonButton, { color: "primary", onClick: () => onClose() }, "Exit")));
};
const Quiz = ({ type, data, onClose }) => {
  const [currentQuestion, setCurrentQuestion] = reactExports.useState(0);
  const [userResponses, setUserResponses] = reactExports.useState([]);
  const [quizOver, setQuizOver] = reactExports.useState(false);
  const totalQuestions = 5;
  const handleAnswer = (answer, isRight) => {
    setUserResponses([...userResponses, [answer, isRight]]);
    if (currentQuestion < totalQuestions - 1) {
      setCurrentQuestion(currentQuestion + 1);
    } else {
      setQuizOver(true);
    }
  };
  const onClosetest = () => {
    setQuizOver(false);
    onClose(userResponses);
  };
  const setupMultipleChoiceQ = () => {
    const randomIndex = Math.floor(Math.random() * data.length);
    const randomEntry = data[randomIndex];
    const correctPronunciation = randomEntry.pronunciation;
    const uniquePronunciations = data.map((entry) => entry.pronunciation).filter((p2) => p2 !== correctPronunciation);
    const otherPronunciations = shuffleArray(uniquePronunciations).slice(0, 3);
    return {
      character: randomEntry.character,
      rightAnswer: correctPronunciation,
      others: shuffleArray(otherPronunciations.concat(correctPronunciation))
    };
  };
  const setupMultipleChoiceQReverse = () => {
    const randomIndex = Math.floor(Math.random() * data.length);
    const randomEntry = data[randomIndex];
    const correctCharacter = randomEntry.character;
    const uniqueCharacters = data.map((entry) => entry.character).filter((p2) => p2 !== correctCharacter);
    const otherCharacters = shuffleArray(uniqueCharacters).slice(0, 3);
    return {
      character: randomEntry.pronunciation,
      rightAnswer: correctCharacter,
      others: shuffleArray(otherCharacters.concat(correctCharacter))
    };
  };
  const setupDoubleCharacterQ = () => {
    const randomIndex = Math.floor(Math.random() * data.length);
    const randomEntry = data[randomIndex];
    const correctPronunciation1 = randomEntry.pronunciation;
    let randomIndex2 = randomIndex;
    while (randomIndex2 === randomIndex) {
      randomIndex2 = Math.floor(Math.random() * data.length);
    }
    const randomEntry2 = data[randomIndex2];
    const correctPronunciation2 = randomEntry2.pronunciation;
    const uniquePronunciations = data.map((entry) => entry.pronunciation);
    let rest = shuffleArray(uniquePronunciations).slice(0, 5);
    rest = [rest[0] + rest[1], rest[2] + rest[3], rest[4] + rest[2]];
    return {
      character: randomEntry.character + randomEntry2.character,
      rightAnswer: correctPronunciation1 + correctPronunciation2,
      others: shuffleArray(rest.concat(correctPronunciation1 + correctPronunciation2))
    };
  };
  const setupLinkingQ = () => {
    const clonedArray = data.slice();
    const selected = shuffleArray(clonedArray).slice(0, 4);
    const shuffledOptions = shuffleArray(selected.slice());
    const a2 = selected.map(({ character, pronunciation }, idx) => ({ character, pronunciation, wrongCharacter: shuffledOptions[idx].character, wrongPronunciation: shuffledOptions[idx].pronunciation }));
    return a2;
  };
  const renderQuestion = () => {
    if (quizOver)
      return null;
    switch (Math.floor(Math.random() * 4)) {
      case 0:
        return /* @__PURE__ */ React.createElement(MultipleChoiceQ, { key: currentQuestion, type, onAnswer: handleAnswer, data: setupMultipleChoiceQ() });
      case 1:
        return /* @__PURE__ */ React.createElement(LinkingQ, { key: currentQuestion, onAnswer: handleAnswer, data: setupLinkingQ() });
      case 2:
        return /* @__PURE__ */ React.createElement(MultipleChoiceQ, { key: currentQuestion, type, onAnswer: handleAnswer, data: setupMultipleChoiceQReverse() });
      case 3:
        if (type !== "kanji")
          return /* @__PURE__ */ React.createElement(MultipleChoiceQ, { key: currentQuestion, onAnswer: handleAnswer, data: setupDoubleCharacterQ() });
        return /* @__PURE__ */ React.createElement(MultipleChoiceQ, { key: currentQuestion, type, onAnswer: handleAnswer, data: setupMultipleChoiceQ() });
      default:
        return null;
    }
  };
  return /* @__PURE__ */ React.createElement("div", { className: "Quiz", style: { height: "100vh" } }, /* @__PURE__ */ React.createElement(IonHeader, null, /* @__PURE__ */ React.createElement(IonToolbar, { color: "light" }, /* @__PURE__ */ React.createElement(IonButtons, { slot: "start" }, /* @__PURE__ */ React.createElement(IonButton, { id: "present-alert", style: { width: "100%" }, color: "light", fill: "clear" }, /* @__PURE__ */ React.createElement(IonLabel, { style: { color: "black" } }, /* @__PURE__ */ React.createElement("b", null, "Quit")))), /* @__PURE__ */ React.createElement(IonButtons, { slot: "end" }, /* @__PURE__ */ React.createElement(IonButton, null, /* @__PURE__ */ React.createElement(IonTitle, null, type, " Quiz"))))), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h2", null, "Question #", currentQuestion + 1), renderQuestion(), /* @__PURE__ */ React.createElement(IonFooter, { style: { position: "fixed", bottom: "0" } }, /* @__PURE__ */ React.createElement(IonToolbar, { color: "light" }, /* @__PURE__ */ React.createElement(IonProgressBar, { color: "success", value: (currentQuestion + 1) / totalQuestions }))), /* @__PURE__ */ React.createElement(
    IonAlert,
    {
      cssClass: "my-custom-class",
      header: "Are you sure?",
      trigger: "present-alert",
      buttons: [
        {
          text: "Cancel",
          role: "cancel",
          handler: () => {
            return null;
          }
        },
        {
          text: "OK",
          role: "confirm",
          handler: () => {
            onClose();
          }
        }
      ],
      onDidDismiss: ({ detail }) => console.log(`Dismissed with role: ${detail.role}`)
    }
  ), userResponses.length === 5 && /* @__PURE__ */ React.createElement(QuizOver, { onClose: onClosetest, userResponses, totalQuestions }));
};
const Settings = ({ restart }) => {
  const { darkMode, toggleDarkMode } = useDarkMode();
  return /* @__PURE__ */ React.createElement("div", { className: darkMode ? "mainSection dark" : "mainSection light" }, /* @__PURE__ */ React.createElement(IonPage, { className: darkMode ? "mainSection dark" : "mainSection light" }, /* @__PURE__ */ React.createElement("h1", null, "Settings"), /* @__PURE__ */ React.createElement(SectionDivider, null), /* @__PURE__ */ React.createElement(IonContent, { className: "ion-padding" }, /* @__PURE__ */ React.createElement(IonList, { inset: true }, /* @__PURE__ */ React.createElement(IonItem, { className: "settings-item" }, /* @__PURE__ */ React.createElement(IonToggle, { checked: darkMode, onIonChange: toggleDarkMode, justify: "space-between", color: "primary" }, /* @__PURE__ */ React.createElement("h2", { style: darkMode ? { color: "white" } : { color: "black" } }, "Dark Mode")))), /* @__PURE__ */ React.createElement(IonList, { inset: true }, /* @__PURE__ */ React.createElement(IonButton, { id: "present-alert-1", expand: "block", fill: "outline", color: darkMode ? "light" : "dark" }, /* @__PURE__ */ React.createElement("h2", null, "Restart Progression"))))), /* @__PURE__ */ React.createElement(
    IonAlert,
    {
      cssClass: "my-custom-class",
      header: "Are you sure?",
      trigger: "present-alert-1",
      buttons: [
        {
          text: "Cancel",
          role: "cancel",
          handler: () => {
            return null;
          }
        },
        {
          text: "OK",
          role: "confirm",
          handler: () => {
            restart();
          }
        }
      ],
      onDidDismiss: ({ detail }) => console.log(`Dismissed with role: ${detail.role}`)
    }
  ));
};
function App2({ katakanaData: katakanaData2, hiraganaData: hiraganaData2, kanjiData, reload, currentPageInherited, restart }) {
  const [activeQuiz, setActiveQuiz] = reactExports.useState(false);
  const [quizLoading, setQuizLoading] = reactExports.useState([false, 5]);
  const pages = ["hiragana", "katakana", "kanji", "settings"];
  const [currentPage, setCurrentPage] = reactExports.useState(currentPageInherited);
  const { darkMode } = useDarkMode();
  const handleSwipe = useSwipeable({
    onSwipedLeft: () => {
      if (activeQuiz)
        return;
      const currentIndex = pages.indexOf(currentPage);
      const nextPage = currentIndex < pages.length - 1 ? pages[currentIndex + 1] : pages[0];
      setCurrentPage(nextPage);
    },
    onSwipedRight: () => {
      if (activeQuiz)
        return;
      const currentIndex = pages.indexOf(currentPage);
      const nextPage = currentIndex === 0 ? pages[pages.length - 1] : pages[currentIndex - 1];
      setCurrentPage(nextPage);
    }
  });
  const startQuiz = () => {
    if (currentPage !== "kanji")
      setActiveQuiz(true);
    else {
      setQuizLoading([true, 5]);
    }
  };
  const endQuiz = (userResponses) => {
    setActiveQuiz(false);
    reload(userResponses, currentPage);
  };
  const filterQuizData = () => {
    switch (currentPage) {
      case "hiragana":
        return hiraganaData2.values.filter((item) => item.level > 0);
      case "katakana":
        return katakanaData2.values.filter((item) => item.level > 0);
      case "kanji":
        return kanjiData.values.filter((x2) => x2.jlpt === quizLoading[1]).filter((item) => item.level > 0);
    }
  };
  const startKanji = (alertData) => {
    var value = alertData === void 0 ? 5 : alertData;
    setQuizLoading([false, value]);
    setActiveQuiz(true);
  };
  const renderKanji = () => {
    return /* @__PURE__ */ React.createElement(
      IonAlert,
      {
        isOpen: quizLoading[0],
        header: "Select quiz type",
        buttons: [
          {
            text: "Cancel",
            role: "cancel",
            handler: () => {
              setQuizLoading([false, 5]);
            }
          },
          {
            text: "OK",
            role: "confirm",
            handler: (alertData) => {
              startKanji(alertData);
            }
          }
        ],
        inputs: [
          {
            label: "N5",
            type: "radio",
            value: 5
          },
          {
            label: "N4",
            type: "radio",
            value: 4
          }
        ]
      }
    );
  };
  return /* @__PURE__ */ React.createElement(IonApp, null, "        ", /* @__PURE__ */ React.createElement("div", { className: "App", ...handleSwipe }, !activeQuiz && currentPage === "hiragana" && /* @__PURE__ */ React.createElement(Hiragana, { data: hiraganaData2.values }), !activeQuiz && currentPage === "katakana" && /* @__PURE__ */ React.createElement(Katakana, { data: katakanaData2.values }), !activeQuiz && currentPage === "kanji" && /* @__PURE__ */ React.createElement(Kanji, { data: kanjiData.values }), !activeQuiz && currentPage === "settings" && /* @__PURE__ */ React.createElement(Settings, { restart }), !activeQuiz && /* @__PURE__ */ React.createElement(IonFooter, { style: { position: "fixed", bottom: "0", width: "inherit" } }, currentPage !== "settings" && /* @__PURE__ */ React.createElement(IonToolbar, { id: "quizbtn" }, /* @__PURE__ */ React.createElement(IonButton, { onClick: startQuiz, style: { width: "100%" }, id: "quizbtn", fill: "clear" }, /* @__PURE__ */ React.createElement(IonLabel, { style: { color: "black" } }, /* @__PURE__ */ React.createElement("b", null, "Quiz ", currentPage)))), /* @__PURE__ */ React.createElement(IonSegment, { color: "primary", className: darkMode ? "dark-segment" : "light-segment", value: currentPage, style: { height: "100px" } }, /* @__PURE__ */ React.createElement(IonSegmentButton, { value: "hiragana", style: { width: "90%", height: "90%" }, onClick: () => setCurrentPage("hiragana") }, /* @__PURE__ */ React.createElement("b", null, " あ")), /* @__PURE__ */ React.createElement(IonSegmentButton, { value: "katakana", style: { width: "90%", height: "90%" }, onClick: () => setCurrentPage("katakana") }, /* @__PURE__ */ React.createElement("b", null, "ア")), /* @__PURE__ */ React.createElement(IonSegmentButton, { value: "kanji", style: { width: "90%", height: "90%" }, onClick: () => setCurrentPage("kanji") }, /* @__PURE__ */ React.createElement("b", null, "川")), /* @__PURE__ */ React.createElement(IonSegmentButton, { value: "settings", style: { width: "90%", height: "90%" }, onClick: () => setCurrentPage("settings") }, /* @__PURE__ */ React.createElement(IonIcon, { icon: settings })))), activeQuiz && /* @__PURE__ */ React.createElement(
    Quiz,
    {
      type: currentPage,
      data: filterQuizData(),
      onClose: endQuiz
    }
  ), quizLoading[0] && renderKanji()));
}
class SQLiteConnection {
  constructor(sqlite) {
    this.sqlite = sqlite;
    this._connectionDict = /* @__PURE__ */ new Map();
  }
  async initWebStore() {
    try {
      await this.sqlite.initWebStore();
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async saveToStore(database) {
    try {
      await this.sqlite.saveToStore({ database });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async saveToLocalDisk(database) {
    try {
      await this.sqlite.saveToLocalDisk({ database });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getFromLocalDiskToStore(overwrite) {
    const mOverwrite = overwrite != null ? overwrite : true;
    try {
      await this.sqlite.getFromLocalDiskToStore({ overwrite: mOverwrite });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async echo(value) {
    try {
      const res = await this.sqlite.echo({ value });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isSecretStored() {
    try {
      const res = await this.sqlite.isSecretStored();
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async setEncryptionSecret(passphrase) {
    try {
      await this.sqlite.setEncryptionSecret({ passphrase });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async changeEncryptionSecret(passphrase, oldpassphrase) {
    try {
      await this.sqlite.changeEncryptionSecret({
        passphrase,
        oldpassphrase
      });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async clearEncryptionSecret() {
    try {
      await this.sqlite.clearEncryptionSecret();
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async checkEncryptionSecret(passphrase) {
    try {
      const res = await this.sqlite.checkEncryptionSecret({
        passphrase
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async addUpgradeStatement(database, toVersion, statements) {
    const upgrade = {
      toVersion,
      statements
    };
    try {
      if (database.endsWith(".db"))
        database = database.slice(0, -3);
      await this.sqlite.addUpgradeStatement({
        database,
        upgrade: [upgrade]
      });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async createConnection(database, encrypted, mode, version2, readonly) {
    try {
      if (database.endsWith(".db"))
        database = database.slice(0, -3);
      await this.sqlite.createConnection({
        database,
        encrypted,
        mode,
        version: version2,
        readonly
      });
      const conn = new SQLiteDBConnection(database, readonly, this.sqlite);
      const connName = readonly ? `RO_${database}` : `RW_${database}`;
      this._connectionDict.set(connName, conn);
      return Promise.resolve(conn);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async closeConnection(database, readonly) {
    try {
      if (database.endsWith(".db"))
        database = database.slice(0, -3);
      await this.sqlite.closeConnection({ database, readonly });
      const connName = readonly ? `RO_${database}` : `RW_${database}`;
      this._connectionDict.delete(connName);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isConnection(database, readonly) {
    const res = {};
    if (database.endsWith(".db"))
      database = database.slice(0, -3);
    const connName = readonly ? `RO_${database}` : `RW_${database}`;
    res.result = this._connectionDict.has(connName);
    return Promise.resolve(res);
  }
  async retrieveConnection(database, readonly) {
    if (database.endsWith(".db"))
      database = database.slice(0, -3);
    const connName = readonly ? `RO_${database}` : `RW_${database}`;
    if (this._connectionDict.has(connName)) {
      const conn = this._connectionDict.get(connName);
      if (typeof conn != "undefined")
        return Promise.resolve(conn);
      else {
        return Promise.reject(`Connection ${database} is undefined`);
      }
    } else {
      return Promise.reject(`Connection ${database} does not exist`);
    }
  }
  async getNCDatabasePath(path2, database) {
    try {
      const databasePath = await this.sqlite.getNCDatabasePath({
        path: path2,
        database
      });
      return Promise.resolve(databasePath);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async createNCConnection(databasePath, version2) {
    try {
      await this.sqlite.createNCConnection({
        databasePath,
        version: version2
      });
      const conn = new SQLiteDBConnection(databasePath, true, this.sqlite);
      const connName = `RO_${databasePath})`;
      this._connectionDict.set(connName, conn);
      return Promise.resolve(conn);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async closeNCConnection(databasePath) {
    try {
      await this.sqlite.closeNCConnection({ databasePath });
      const connName = `RO_${databasePath})`;
      this._connectionDict.delete(connName);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isNCConnection(databasePath) {
    const res = {};
    const connName = `RO_${databasePath})`;
    res.result = this._connectionDict.has(connName);
    return Promise.resolve(res);
  }
  async retrieveNCConnection(databasePath) {
    if (this._connectionDict.has(databasePath)) {
      const connName = `RO_${databasePath})`;
      const conn = this._connectionDict.get(connName);
      if (typeof conn != "undefined")
        return Promise.resolve(conn);
      else {
        return Promise.reject(`Connection ${databasePath} is undefined`);
      }
    } else {
      return Promise.reject(`Connection ${databasePath} does not exist`);
    }
  }
  async isNCDatabase(databasePath) {
    try {
      const res = await this.sqlite.isNCDatabase({ databasePath });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async retrieveAllConnections() {
    return this._connectionDict;
  }
  async closeAllConnections() {
    const delDict = /* @__PURE__ */ new Map();
    try {
      for (const key of this._connectionDict.keys()) {
        const database = key.substring(3);
        const readonly = key.substring(0, 3) === "RO_" ? true : false;
        await this.sqlite.closeConnection({ database, readonly });
        delDict.set(key, null);
      }
      for (const key of delDict.keys()) {
        this._connectionDict.delete(key);
      }
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async checkConnectionsConsistency() {
    try {
      const keys = [...this._connectionDict.keys()];
      const openModes = [];
      const dbNames = [];
      for (const key of keys) {
        openModes.push(key.substring(0, 2));
        dbNames.push(key.substring(3));
      }
      const res = await this.sqlite.checkConnectionsConsistency({
        dbNames,
        openModes
      });
      if (!res.result)
        this._connectionDict = /* @__PURE__ */ new Map();
      return Promise.resolve(res);
    } catch (err) {
      this._connectionDict = /* @__PURE__ */ new Map();
      return Promise.reject(err);
    }
  }
  async importFromJson(jsonstring) {
    try {
      const ret = await this.sqlite.importFromJson({ jsonstring });
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isJsonValid(jsonstring) {
    try {
      const ret = await this.sqlite.isJsonValid({ jsonstring });
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async copyFromAssets(overwrite) {
    const mOverwrite = overwrite != null ? overwrite : true;
    try {
      await this.sqlite.copyFromAssets({ overwrite: mOverwrite });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getFromHTTPRequest(url, overwrite) {
    const mOverwrite = overwrite != null ? overwrite : true;
    try {
      await this.sqlite.getFromHTTPRequest({ url, overwrite: mOverwrite });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isDatabaseEncrypted(database) {
    if (database.endsWith(".db"))
      database = database.slice(0, -3);
    try {
      const res = await this.sqlite.isDatabaseEncrypted({ database });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isInConfigEncryption() {
    try {
      const res = await this.sqlite.isInConfigEncryption();
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isInConfigBiometricAuth() {
    try {
      const res = await this.sqlite.isInConfigBiometricAuth();
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isDatabase(database) {
    if (database.endsWith(".db"))
      database = database.slice(0, -3);
    try {
      const res = await this.sqlite.isDatabase({ database });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getDatabaseList() {
    try {
      const res = await this.sqlite.getDatabaseList();
      const values = res.values;
      values.sort();
      const ret = { values };
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getMigratableDbList(folderPath) {
    const path2 = folderPath ? folderPath : "default";
    try {
      const res = await this.sqlite.getMigratableDbList({
        folderPath: path2
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async addSQLiteSuffix(folderPath, dbNameList) {
    const path2 = folderPath ? folderPath : "default";
    const dbList = dbNameList ? dbNameList : [];
    try {
      const res = await this.sqlite.addSQLiteSuffix({
        folderPath: path2,
        dbNameList: dbList
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async deleteOldDatabases(folderPath, dbNameList) {
    const path2 = folderPath ? folderPath : "default";
    const dbList = dbNameList ? dbNameList : [];
    try {
      const res = await this.sqlite.deleteOldDatabases({
        folderPath: path2,
        dbNameList: dbList
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async moveDatabasesAndAddSuffix(folderPath, dbNameList) {
    const path2 = folderPath ? folderPath : "default";
    const dbList = dbNameList ? dbNameList : [];
    return this.sqlite.moveDatabasesAndAddSuffix({
      folderPath: path2,
      dbNameList: dbList
    });
  }
}
class SQLiteDBConnection {
  constructor(dbName, readonly, sqlite) {
    this.dbName = dbName;
    this.readonly = readonly;
    this.sqlite = sqlite;
  }
  getConnectionDBName() {
    return this.dbName;
  }
  getConnectionReadOnly() {
    return this.readonly;
  }
  async open() {
    try {
      await this.sqlite.open({
        database: this.dbName,
        readonly: this.readonly
      });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async close() {
    try {
      await this.sqlite.close({
        database: this.dbName,
        readonly: this.readonly
      });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async beginTransaction() {
    try {
      const changes = await this.sqlite.beginTransaction({
        database: this.dbName
      });
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async commitTransaction() {
    try {
      const changes = await this.sqlite.commitTransaction({
        database: this.dbName
      });
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async rollbackTransaction() {
    try {
      const changes = await this.sqlite.rollbackTransaction({
        database: this.dbName
      });
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isTransactionActive() {
    try {
      const result = await this.sqlite.isTransactionActive({
        database: this.dbName
      });
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async loadExtension(path2) {
    try {
      await this.sqlite.loadExtension({
        database: this.dbName,
        path: path2,
        readonly: this.readonly
      });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async enableLoadExtension(toggle) {
    try {
      await this.sqlite.enableLoadExtension({
        database: this.dbName,
        toggle,
        readonly: this.readonly
      });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getUrl() {
    try {
      const res = await this.sqlite.getUrl({
        database: this.dbName,
        readonly: this.readonly
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getVersion() {
    try {
      const version2 = await this.sqlite.getVersion({
        database: this.dbName,
        readonly: this.readonly
      });
      return Promise.resolve(version2);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getTableList() {
    try {
      const res = await this.sqlite.getTableList({
        database: this.dbName,
        readonly: this.readonly
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async execute(statements, transaction = true, isSQL92 = true) {
    try {
      if (!this.readonly) {
        const res = await this.sqlite.execute({
          database: this.dbName,
          statements,
          transaction,
          readonly: false,
          isSQL92
        });
        return Promise.resolve(res);
      } else {
        return Promise.reject("not allowed in read-only mode");
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async query(statement, values, isSQL92 = true) {
    let res;
    try {
      if (values && values.length > 0) {
        res = await this.sqlite.query({
          database: this.dbName,
          statement,
          values,
          readonly: this.readonly,
          isSql92: true
        });
      } else {
        res = await this.sqlite.query({
          database: this.dbName,
          statement,
          values: [],
          readonly: this.readonly,
          isSQL92
        });
      }
      res = await this.reorderRows(res);
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async run(statement, values, transaction = true, returnMode = "no", isSQL92 = true) {
    let res;
    try {
      if (!this.readonly) {
        if (values && values.length > 0) {
          res = await this.sqlite.run({
            database: this.dbName,
            statement,
            values,
            transaction,
            readonly: false,
            returnMode,
            isSQL92: true
          });
        } else {
          res = await this.sqlite.run({
            database: this.dbName,
            statement,
            values: [],
            transaction,
            readonly: false,
            returnMode,
            isSQL92
          });
        }
        res.changes = await this.reorderRows(res.changes);
        return Promise.resolve(res);
      } else {
        return Promise.reject("not allowed in read-only mode");
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async executeSet(set, transaction = true, returnMode = "no", isSQL92 = true) {
    let res;
    try {
      if (!this.readonly) {
        res = await this.sqlite.executeSet({
          database: this.dbName,
          set,
          transaction,
          readonly: false,
          returnMode,
          isSQL92
        });
        res.changes = await this.reorderRows(res.changes);
        return Promise.resolve(res);
      } else {
        return Promise.reject("not allowed in read-only mode");
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isExists() {
    try {
      const res = await this.sqlite.isDBExists({
        database: this.dbName,
        readonly: this.readonly
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isTable(table) {
    try {
      const res = await this.sqlite.isTableExists({
        database: this.dbName,
        table,
        readonly: this.readonly
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isDBOpen() {
    try {
      const res = await this.sqlite.isDBOpen({
        database: this.dbName,
        readonly: this.readonly
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async delete() {
    try {
      if (!this.readonly) {
        await this.sqlite.deleteDatabase({
          database: this.dbName,
          readonly: false
        });
        return Promise.resolve();
      } else {
        return Promise.reject("not allowed in read-only mode");
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async createSyncTable() {
    try {
      if (!this.readonly) {
        const res = await this.sqlite.createSyncTable({
          database: this.dbName,
          readonly: false
        });
        return Promise.resolve(res);
      } else {
        return Promise.reject("not allowed in read-only mode");
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async setSyncDate(syncdate) {
    try {
      if (!this.readonly) {
        await this.sqlite.setSyncDate({
          database: this.dbName,
          syncdate,
          readonly: false
        });
        return Promise.resolve();
      } else {
        return Promise.reject("not allowed in read-only mode");
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getSyncDate() {
    try {
      const res = await this.sqlite.getSyncDate({
        database: this.dbName,
        readonly: this.readonly
      });
      let retDate = "";
      if (res.syncDate > 0)
        retDate = new Date(res.syncDate * 1e3).toISOString();
      return Promise.resolve(retDate);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async exportToJson(mode, encrypted = false) {
    try {
      const res = await this.sqlite.exportToJson({
        database: this.dbName,
        jsonexportmode: mode,
        readonly: this.readonly,
        encrypted
      });
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async deleteExportedRows() {
    try {
      if (!this.readonly) {
        await this.sqlite.deleteExportedRows({
          database: this.dbName,
          readonly: false
        });
        return Promise.resolve();
      } else {
        return Promise.reject("not allowed in read-only mode");
      }
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async executeTransaction(txn, isSQL92 = true) {
    let changes = 0;
    let isActive = false;
    if (!this.readonly) {
      try {
        await this.sqlite.beginTransaction({
          database: this.dbName
        });
        isActive = await this.sqlite.isTransactionActive({
          database: this.dbName
        });
        if (!isActive) {
          return Promise.reject("After Begin Transaction, no transaction active");
        }
      } catch (err) {
        return Promise.reject(err);
      }
      try {
        for (const task of txn) {
          if (task.values && task.values.length > 0) {
            const retMode = task.statement.toUpperCase().includes("RETURNING") ? "all" : "no";
            const ret = await this.sqlite.run({
              database: this.dbName,
              statement: task.statement,
              values: task.values,
              transaction: false,
              readonly: false,
              returnMode: retMode,
              isSQL92
            });
            if (ret.changes.changes <= 0) {
              throw new Error("Error in transaction method run ");
            }
            changes += ret.changes.changes;
          } else {
            const ret = await this.sqlite.execute({
              database: this.dbName,
              statements: task.statement,
              transaction: false,
              readonly: false
            });
            isActive = await this.sqlite.isTransactionActive({
              database: this.dbName
            });
            if (ret.changes.changes < 0) {
              throw new Error("Error in transaction method execute ");
            }
            changes += ret.changes.changes;
          }
        }
        isActive = await this.sqlite.isTransactionActive({
          database: this.dbName
        });
        if (isActive) {
          const retC = await this.sqlite.commitTransaction({
            database: this.dbName
          });
          changes += retC.changes.changes;
        }
        const retChanges = { changes: { changes } };
        return Promise.resolve(retChanges);
      } catch (err) {
        const msg = err.message ? err.message : err;
        isActive = await this.sqlite.isTransactionActive({
          database: this.dbName
        });
        if (isActive) {
          await this.sqlite.rollbackTransaction({
            database: this.dbName
          });
        }
        return Promise.reject(msg);
      }
    } else {
      return Promise.reject("not allowed in read-only mode");
    }
  }
  async reorderRows(res) {
    const retRes = res;
    if ((res == null ? void 0 : res.values) && typeof res.values[0] === "object") {
      if (Object.keys(res.values[0]).includes("ios_columns")) {
        const columnList = res.values[0]["ios_columns"];
        const iosRes = [];
        for (let i = 1; i < res.values.length; i++) {
          const rowJson = res.values[i];
          const resRowJson = {};
          for (const item of columnList) {
            resRowJson[item] = rowJson[item];
          }
          iosRes.push(resRowJson);
        }
        retRes["values"] = iosRes;
      }
    }
    return Promise.resolve(retRes);
  }
}
const CapacitorSQLite = registerPlugin("CapacitorSQLite", {
  web: () => __vitePreload(() => import("./web-D4k7sIlc.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((m2) => new m2.CapacitorSQLiteWeb()),
  electron: () => window.CapacitorCustomPlatform.plugins.CapacitorSQLite
});
const katakanaData = [
  { character: "ア", pronunciation: "a", "level": 1 },
  { character: "イ", pronunciation: "i", "level": 1 },
  { character: "ウ", pronunciation: "u", "level": 1 },
  { character: "エ", pronunciation: "e", "level": 1 },
  { character: "オ", pronunciation: "o", "level": 1 },
  { character: "カ", pronunciation: "ka", "level": 0 },
  { character: "キ", pronunciation: "ki", "level": 0 },
  { character: "ク", pronunciation: "ku", "level": 0 },
  { character: "ケ", pronunciation: "ke", "level": 0 },
  { character: "コ", pronunciation: "ko", "level": 0 },
  { character: "サ", pronunciation: "sa", "level": 0 },
  { character: "シ", pronunciation: "shi", "level": 0 },
  { character: "ス", pronunciation: "su", "level": 0 },
  { character: "セ", pronunciation: "se", "level": 0 },
  { character: "ソ", pronunciation: "so", "level": 0 },
  { character: "タ", pronunciation: "ta", "level": 0 },
  { character: "チ", pronunciation: "chi", "level": 0 },
  { character: "ツ", pronunciation: "tsu", "level": 0 },
  { character: "テ", pronunciation: "te", "level": 0 },
  { character: "ト", pronunciation: "to", "level": 0 },
  { character: "ナ", pronunciation: "na", "level": 0 },
  { character: "ニ", pronunciation: "ni", "level": 0 },
  { character: "ヌ", pronunciation: "nu", "level": 0 },
  { character: "ネ", pronunciation: "ne", "level": 0 },
  { character: "ノ", pronunciation: "no", "level": 0 },
  { character: "ハ", pronunciation: "ha", "level": 0 },
  { character: "ヒ", pronunciation: "hi", "level": 0 },
  { character: "フ", pronunciation: "fu", "level": 0 },
  { character: "ヘ", pronunciation: "he", "level": 0 },
  { character: "ホ", pronunciation: "ho", "level": 0 },
  { character: "マ", pronunciation: "ma", "level": 0 },
  { character: "ミ", pronunciation: "mi", "level": 0 },
  { character: "ム", pronunciation: "mu", "level": 0 },
  { character: "メ", pronunciation: "me", "level": 0 },
  { character: "モ", pronunciation: "mo", "level": 0 },
  { character: "ヤ", pronunciation: "ya", "level": 0 },
  { character: "ユ", pronunciation: "yu", "level": 0 },
  { character: "ヨ", pronunciation: "yo", "level": 0 },
  { character: "ラ", pronunciation: "ra", "level": 0 },
  { character: "リ", pronunciation: "ri", "level": 0 },
  { character: "ル", pronunciation: "ru", "level": 0 },
  { character: "レ", pronunciation: "re", "level": 0 },
  { character: "ロ", pronunciation: "ro", "level": 0 },
  { character: "ワ", pronunciation: "wa", "level": 0 },
  { character: "ヲ", pronunciation: "wo", "level": 0 },
  { character: "ン", pronunciation: "n", "level": 0 },
  { character: "ガ", pronunciation: "ga", level: 0 },
  { character: "ギ", pronunciation: "gi", level: 0 },
  { character: "グ", pronunciation: "gu", level: 0 },
  { character: "ゲ", pronunciation: "ge", level: 0 },
  { character: "ゴ", pronunciation: "go", level: 0 },
  { character: "ザ", pronunciation: "za", level: 0 },
  { character: "ジ", pronunciation: "ji", level: 0 },
  { character: "ズ", pronunciation: "zu", level: 0 },
  { character: "ゼ", pronunciation: "ze", level: 0 },
  { character: "ゾ", pronunciation: "zo", level: 0 },
  { character: "ダ", pronunciation: "da", level: 0 },
  { character: "ヂ", pronunciation: "ji", level: 0 },
  { character: "ヅ", pronunciation: "zu", level: 0 },
  { character: "デ", pronunciation: "de", level: 0 },
  { character: "ド", pronunciation: "do", level: 0 },
  { character: "パ", pronunciation: "pa", level: 0 },
  { character: "ピ", pronunciation: "pi", level: 0 },
  { character: "プ", pronunciation: "pu", level: 0 },
  { character: "ペ", pronunciation: "pe", level: 0 },
  { character: "ポ", pronunciation: "po", level: 0 },
  { character: "キャ", pronunciation: "kya", level: 0 },
  { character: "キュ", pronunciation: "kyu", level: 0 },
  { character: "キョ", pronunciation: "kyo", level: 0 },
  { character: "シャ", pronunciation: "sha", level: 0 },
  { character: "シュ", pronunciation: "shu", level: 0 },
  { character: "ショ", pronunciation: "sho", level: 0 },
  { character: "チャ", pronunciation: "cha", level: 0 },
  { character: "チュ", pronunciation: "chu", level: 0 },
  { character: "チョ", pronunciation: "cho", level: 0 },
  { character: "ニャ", pronunciation: "nya", level: 0 },
  { character: "ニュ", pronunciation: "nyu", level: 0 },
  { character: "ニョ", pronunciation: "nyo", level: 0 },
  { character: "ヒャ", pronunciation: "hya", level: 0 },
  { character: "ヒュ", pronunciation: "hyu", level: 0 },
  { character: "ヒョ", pronunciation: "hyo", level: 0 },
  { character: "ミャ", pronunciation: "mya", level: 0 },
  { character: "ミュ", pronunciation: "myu", level: 0 },
  { character: "ミョ", pronunciation: "myo", level: 0 },
  { character: "リャ", pronunciation: "rya", level: 0 },
  { character: "リュ", pronunciation: "ryu", level: 0 },
  { character: "リョ", pronunciation: "ryo", level: 0 }
];
const hiraganaData = [
  { character: "あ", pronunciation: "a", "level": 1 },
  { character: "い", pronunciation: "i", "level": 1 },
  { character: "う", pronunciation: "u", "level": 1 },
  { character: "え", pronunciation: "e", "level": 1 },
  { character: "お", pronunciation: "o", "level": 1 },
  { character: "か", pronunciation: "ka", "level": 0 },
  { character: "き", pronunciation: "ki", "level": 0 },
  { character: "く", pronunciation: "ku", "level": 0 },
  { character: "け", pronunciation: "ke", "level": 0 },
  { character: "こ", pronunciation: "ko", "level": 0 },
  { character: "さ", pronunciation: "sa", "level": 0 },
  { character: "し", pronunciation: "shi", "level": 0 },
  { character: "す", pronunciation: "su", "level": 0 },
  { character: "せ", pronunciation: "se", "level": 0 },
  { character: "そ", pronunciation: "so", "level": 0 },
  { character: "た", pronunciation: "ta", "level": 0 },
  { character: "ち", pronunciation: "chi", "level": 0 },
  { character: "つ", pronunciation: "tsu", "level": 0 },
  { character: "て", pronunciation: "te", "level": 0 },
  { character: "と", pronunciation: "to", "level": 0 },
  { character: "な", pronunciation: "na", "level": 0 },
  { character: "に", pronunciation: "ni", "level": 0 },
  { character: "ぬ", pronunciation: "nu", "level": 0 },
  { character: "ね", pronunciation: "ne", "level": 0 },
  { character: "の", pronunciation: "no", "level": 0 },
  { character: "は", pronunciation: "ha", "level": 0 },
  { character: "ひ", pronunciation: "hi", "level": 0 },
  { character: "ふ", pronunciation: "fu", "level": 0 },
  { character: "へ", pronunciation: "he", "level": 0 },
  { character: "ほ", pronunciation: "ho", "level": 0 },
  { character: "ま", pronunciation: "ma", "level": 0 },
  { character: "み", pronunciation: "mi", "level": 0 },
  { character: "む", pronunciation: "mu", "level": 0 },
  { character: "め", pronunciation: "me", "level": 0 },
  { character: "も", pronunciation: "mo", "level": 0 },
  { character: "や", pronunciation: "ya", "level": 0 },
  { character: "ゆ", pronunciation: "yu", "level": 0 },
  { character: "よ", pronunciation: "yo", "level": 0 },
  { character: "ら", pronunciation: "ra", "level": 0 },
  { character: "り", pronunciation: "ri", "level": 0 },
  { character: "る", pronunciation: "ru", "level": 0 },
  { character: "れ", pronunciation: "re", "level": 0 },
  { character: "ろ", pronunciation: "ro", "level": 0 },
  { character: "わ", pronunciation: "wa", "level": 0 },
  { character: "を", pronunciation: "wo", "level": 0 },
  { character: "ん", pronunciation: "n", "level": 0 },
  { character: "が", pronunciation: "ga", "level": 0 },
  { character: "ぎ", pronunciation: "gi", "level": 0 },
  { character: "ぐ", pronunciation: "gu", "level": 0 },
  { character: "げ", pronunciation: "ge", "level": 0 },
  { character: "ご", pronunciation: "go", "level": 0 },
  { character: "ざ", pronunciation: "za", "level": 0 },
  { character: "じ", pronunciation: "ji", "level": 0 },
  { character: "ず", pronunciation: "zu", "level": 0 },
  { character: "ぜ", pronunciation: "ze", "level": 0 },
  { character: "ぞ", pronunciation: "zo", "level": 0 },
  { character: "だ", pronunciation: "da", "level": 0 },
  { character: "ぢ", pronunciation: "ji", "level": 0 },
  { character: "づ", pronunciation: "zu", "level": 0 },
  { character: "で", pronunciation: "de", "level": 0 },
  { character: "ど", pronunciation: "do", "level": 0 },
  { character: "ぱ", pronunciation: "pa", level: 0 },
  { character: "ぴ", pronunciation: "pi", level: 0 },
  { character: "ぷ", pronunciation: "pu", level: 0 },
  { character: "ぺ", pronunciation: "pe", level: 0 },
  { character: "ぽ", pronunciation: "po", level: 0 },
  { character: "きゃ", pronunciation: "kya", level: 0 },
  { character: "きゅ", pronunciation: "kyu", level: 0 },
  { character: "きょ", pronunciation: "kyo", level: 0 },
  { character: "しゃ", pronunciation: "sha", level: 0 },
  { character: "しゅ", pronunciation: "shu", level: 0 },
  { character: "しょ", pronunciation: "sho", level: 0 },
  { character: "ちゃ", pronunciation: "cha", level: 0 },
  { character: "ちゅ", pronunciation: "chu", level: 0 },
  { character: "ちょ", pronunciation: "cho", level: 0 },
  { character: "にゃ", pronunciation: "nya", level: 0 },
  { character: "にゅ", pronunciation: "nyu", level: 0 },
  { character: "にょ", pronunciation: "nyo", level: 0 },
  { character: "ひゃ", pronunciation: "hya", level: 0 },
  { character: "ひゅ", pronunciation: "hyu", level: 0 },
  { character: "ひょ", pronunciation: "hyo", level: 0 },
  { character: "みゃ", pronunciation: "mya", level: 0 },
  { character: "みゅ", pronunciation: "myu", level: 0 },
  { character: "みょ", pronunciation: "myo", level: 0 },
  { character: "りゃ", pronunciation: "rya", level: 0 },
  { character: "りゅ", pronunciation: "ryu", level: 0 },
  { character: "りょ", pronunciation: "ryo", level: 0 }
];
const useSQLiteDB = () => {
  const db2 = reactExports.useRef();
  const sqlite = reactExports.useRef();
  const [initialized, setInitialized] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const initializeDB = async () => {
      if (sqlite.current)
        return;
      sqlite.current = new SQLiteConnection(CapacitorSQLite);
      const ret = await sqlite.current.checkConnectionsConsistency();
      const isConn = (await sqlite.current.isConnection("db_vite", false)).result;
      if (ret.result && isConn) {
        db2.current = await sqlite.current.retrieveConnection("db_vite", false);
      } else {
        db2.current = await sqlite.current.createConnection(
          "db_vite",
          false,
          "no-encryption",
          1,
          false
        );
      }
    };
    initializeDB().then(() => {
      initializeTables().then(() => setInitialized(true));
    });
  }, []);
  const initializeTables = async () => {
    await performSQLAction(async (db22) => {
      const queryCreateTable = `
            CREATE TABLE IF NOT EXISTS charProgressionHiragana (
            character TEXT PRIMARY KEY NOT NULL,
            level INTEGER NOT NULL,
            pronunciation TEXT
            );`;
      await (db22 == null ? void 0 : db22.execute(queryCreateTable));
    });
    try {
      await performSQLAction(
        async (db22) => {
          const respSelect2 = await (db22 == null ? void 0 : db22.query(`SELECT * FROM charProgressionHiragana`));
          if (respSelect2 !== void 0 && respSelect2.values.length === 0) {
            const values = hiraganaData.map((element) => `('${element.character}', ${element.level}, '${element.pronunciation}')`).join(",");
            try {
              await performSQLAction(
                async (db3) => {
                  await (db3 == null ? void 0 : db3.query(`INSERT INTO charProgressionHiragana (character,level, pronunciation) VALUES ${values};`));
                }
              );
            } catch (error) {
              console.log(error.message);
            }
          }
        }
      );
    } catch (error) {
      console.log(error.message);
    }
    await performSQLAction(async (db22) => {
      const queryCreateTable = `
            CREATE TABLE IF NOT EXISTS charProgressionKatakana (
            character TEXT PRIMARY KEY NOT NULL,
            level INTEGER NOT NULL,
            pronunciation TEXT
            );
        `;
      await (db22 == null ? void 0 : db22.execute(queryCreateTable));
    });
    try {
      await performSQLAction(
        async (db22) => {
          const respSelect2 = await (db22 == null ? void 0 : db22.query(`SELECT * FROM charProgressionKatakana`));
          if (respSelect2 !== void 0 && respSelect2.values.length === 0) {
            const values = katakanaData.map((element) => `('${element.character}', ${element.level},'${element.pronunciation}')`).join(",");
            try {
              await performSQLAction(
                async (db3) => {
                  await (db3 == null ? void 0 : db3.query(`INSERT INTO charProgressionKatakana (character,level,pronunciation) VALUES ${values};`));
                }
              );
            } catch (error) {
              console.log(error.message);
            }
          }
        }
      );
    } catch (error) {
      console.log(error.message);
    }
    await performSQLAction(async (db22) => {
      const queryCreateTable = `
            CREATE TABLE IF NOT EXISTS charProgressionKanji (
            character TEXT PRIMARY KEY NOT NULL,
            level INTEGER NOT NULL,
            jlpt INTEGER NOT NULL,
            pronunciation TEXT NOT NULL
            );
        `;
      await (db22 == null ? void 0 : db22.execute(queryCreateTable));
    });
    try {
      await performSQLAction(
        async (db22) => {
          const respSelect2 = await (db22 == null ? void 0 : db22.query(`SELECT * FROM charProgressionKanji`));
          if (respSelect2 !== void 0 && respSelect2.values.length === 0) {
            var values = Object.keys(n5Kanji).slice(0, 5).map((element) => `('${element}', 1,5,'${n5Kanji[element].meanings[0]}')`).join(",");
            values += ",";
            values += Object.keys(n5Kanji).slice(5).map((element) => `('${element}', 0,5,'${n5Kanji[element].meanings[0]}')`).join(",");
            values += ",";
            values += Object.keys(n4Kanji).slice(0, 5).map((element) => `('${element}', 1,4,'${n4Kanji[element].meanings[0]}')`).join(",");
            values += ",";
            values += Object.keys(n4Kanji).slice(5).map((element) => `('${element}', 0,4,'${n4Kanji[element].meanings[0]}')`).join(",");
            try {
              await performSQLAction(
                async (db3) => {
                  await (db3 == null ? void 0 : db3.query(`INSERT INTO charProgressionKanji (character,level,jlpt,pronunciation) VALUES ${values};`));
                }
              );
            } catch (error) {
              console.log(error.message);
            }
          }
        }
      );
    } catch (error) {
      console.log(error.message);
    }
  };
  const performSQLAction = async (action, cleanup) => {
    var _a, _b, _c, _d;
    try {
      await ((_a = db2.current) == null ? void 0 : _a.open());
      await action(db2.current);
    } catch (error) {
      console.log(error);
    } finally {
      try {
        ((_c = await ((_b = db2.current) == null ? void 0 : _b.isDBOpen())) == null ? void 0 : _c.result) && await ((_d = db2.current) == null ? void 0 : _d.close());
        cleanup && await cleanup();
      } catch {
      }
    }
  };
  const dropTables = async () => {
    await performSQLAction(async (db22) => {
      const queryDropTable = `
            DROP TABLE IF EXISTS charProgressionKanji;;
            DROP TABLE IF EXISTS charProgressionKatakana;;
            DROP TABLE IF EXISTS charProgressionHiragana;`;
      await (db22 == null ? void 0 : db22.execute(queryDropTable));
    });
  };
  const restartDB = async () => {
    try {
      setInitialized(false);
      await dropTables();
      await initializeTables();
      setInitialized(true);
    } catch (error) {
      console.log(error);
    }
  };
  return { performSQLAction, initialized, restartDB };
};
function Main() {
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const { performSQLAction, initialized, restartDB } = useSQLiteDB();
  const [katakanaData2, setKatakanaData] = reactExports.useState({});
  const [hiraganaData2, setHiraganaData] = reactExports.useState({});
  const [kanjiData, setKanjiData] = reactExports.useState({});
  const [currentPage, setCurrentPage] = reactExports.useState("hiragana");
  reactExports.useEffect(() => {
    const loadDataAsync = async () => {
      await loadData();
      setIsLoading(false);
    };
    if (initialized) {
      loadDataAsync();
    }
  }, [initialized]);
  const loadData = async () => {
    try {
      performSQLAction(async (db2) => {
        const hiragana = JSON.stringify(await (db2 == null ? void 0 : db2.query(`SELECT * FROM charProgressionHiragana`)));
        const katakana = JSON.stringify(await (db2 == null ? void 0 : db2.query(`SELECT * FROM charProgressionKatakana`)));
        const kanji = JSON.stringify(await (db2 == null ? void 0 : db2.query(`SELECT * FROM charProgressionKanji`)));
        setKatakanaData(JSON.parse(katakana));
        setHiraganaData(JSON.parse(hiragana));
        setKanjiData(JSON.parse(kanji));
      });
    } catch (error) {
      console.log(error.message);
    }
  };
  const doUnlockCharactersIfNewLevel = async (table) => {
    try {
      await performSQLAction(async (db2) => {
        const unlockedCount = await (db2 == null ? void 0 : db2.query(`SELECT count(*) AS count FROM ${table} WHERE level > 0`));
        const levelCount = await (db2 == null ? void 0 : db2.query(`SELECT sum(level) AS count FROM ${table} WHERE level > 0`));
        if (levelCount.values[0].count / unlockedCount.values[0].count > 10) {
          const newChars = await (db2 == null ? void 0 : db2.query(`SELECT character FROM ${table} WHERE level = 0`));
          const toUnlock = newChars.values.slice(0, 5);
          for (let i = 0; i < toUnlock.length; i++) {
            await (db2 == null ? void 0 : db2.query(`UPDATE ${table} SET level = 1 WHERE character = '${toUnlock[i].character}' ;`));
          }
        }
      });
    } catch (error) {
      console.log(error.message);
    }
  };
  const reload = async (userResponses, currentPage2) => {
    setIsLoading(true);
    try {
      await performSQLAction(async (db2) => {
        for (let i = 0; i < userResponses.length; i++) {
          if (userResponses[i][1] === void 0)
            continue;
          let count = ["+1", 0, 20];
          if (!userResponses[i][1])
            count = ["-1", 1, 21];
          const table = `charProgression${currentPage2.charAt(0).toUpperCase() + currentPage2.slice(1)}`;
          const addLevel = count[0];
          const character = userResponses[i][0];
          const pronunciation = userResponses[i][0];
          const minLevel = count[1];
          const maxLevel = count[2];
          await (db2 == null ? void 0 : db2.query(`UPDATE ${table}
                                        SET level = level ${addLevel}
                                      WHERE (character = '${character}' OR pronunciation = '${pronunciation}')
                                        AND ${minLevel} < level
                                        AND level < ${maxLevel};`));
        }
      });
    } catch (error) {
      console.log(error.message);
    }
    await doUnlockCharactersIfNewLevel(`charProgression${currentPage2.charAt(0).toUpperCase() + currentPage2.slice(1)}`);
    await loadData();
    setCurrentPage(currentPage2);
    setIsLoading(false);
  };
  const restart = async () => {
    setIsLoading(true);
    await restartDB();
    setCurrentPage(currentPage);
    setIsLoading(false);
  };
  return /* @__PURE__ */ React.createElement(DarkModeProvider, null, /* @__PURE__ */ React.createElement("div", { className: "App" }, isLoading ? /* @__PURE__ */ React.createElement(Loading, null) : /* @__PURE__ */ React.createElement(App2, { katakanaData: katakanaData2, hiraganaData: hiraganaData2, kanjiData, currentPageInherited: currentPage, reload, restart })));
}
const global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item2(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var env = {};
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop() {
}
var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance$1 = global$1.performance || {};
var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance$1) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1 = {
  nextTick,
  title,
  browser,
  env,
  argv,
  version,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
const process = browser$1;
const __dirname = "/Volumes/Development_Lacie/Development/new/jeep-sqlite/node_modules/sql.js/dist";
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i = 0, j = 0; i < l2; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset + i];
  i += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i], i += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i], i += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
  }
  buffer[offset + i - d2] |= s2 * 128;
}
var toString = {}.toString;
var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var INSPECT_MAX_BYTES = 50;
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
Buffer._augment = function(arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
Buffer.from = function(value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};
if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
Buffer.alloc = function(size, fill2, encoding) {
  return alloc(null, size, fill2, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer.isBuffer = isBuffer;
function internalIsBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer.compare = function compare(a2, b2) {
  if (!internalIsBuffer(a2) || !internalIsBuffer(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b2)
    return 0;
  var x2 = a2.length;
  var y2 = b2.length;
  for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
    if (a2[i] !== b2[i]) {
      x2 = a2[i];
      y2 = b2[i];
      break;
    }
  }
  if (x2 < y2)
    return -1;
  if (y2 < x2)
    return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === void 0) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.prototype._isBuffer = true;
function swap(b2, n2, m2) {
  var i = b2[n2];
  b2[n2] = b2[m2];
  b2[m2] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString2() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.equals = function equals(b2) {
  if (!internalIsBuffer(b2))
    throw new TypeError("Argument must be a Buffer");
  if (this === b2)
    return true;
  return Buffer.compare(this, b2) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = "";
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
    if (this.length > max)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x2 = thisEnd - thisStart;
  var y2 = end - start;
  var len = Math.min(x2, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x2 = thisCopy[i];
      y2 = targetCopy[i];
      break;
    }
  }
  if (x2 < y2)
    return -1;
  if (y2 < x2)
    return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write2(string, offset, length, encoding) {
  if (offset === void 0) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length;
      length = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length);
      case "ascii":
        return asciiWrite(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset, length);
      case "base64":
        return base64Write(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength2, this.length);
  }
  var val = this[offset + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset + --byteLength2] * mul;
  }
  return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var i = byteLength2;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset + --i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 255, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset] = value & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 127, -128);
  if (!Buffer.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }
  return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n2) {
  if (n2 < 16)
    return "0" + n2.toString(16);
  return n2.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c2, hi2, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i);
    hi2 = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi2);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var sqlWasm = { exports: {} };
const empty = {};
const empty$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": empty
});
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(empty$1);
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === ".") {
      parts.splice(i, 1);
    } else if (last === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path2 = i >= 0 ? arguments[i] : "/";
    if (typeof path2 !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path2) {
      continue;
    }
    resolvedPath = path2 + "/" + resolvedPath;
    resolvedAbsolute = path2.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p2) {
    return !!p2;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function normalize(path2) {
  var isPathAbsolute = isAbsolute(path2), trailingSlash = substr(path2, -1) === "/";
  path2 = normalizeArray(filter(path2.split("/"), function(p2) {
    return !!p2;
  }), !isPathAbsolute).join("/");
  if (!path2 && !isPathAbsolute) {
    path2 = ".";
  }
  if (path2 && trailingSlash) {
    path2 += "/";
  }
  return (isPathAbsolute ? "/" : "") + path2;
}
function isAbsolute(path2) {
  return path2.charAt(0) === "/";
}
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p2, index) {
    if (typeof p2 !== "string") {
      throw new TypeError("Arguments to path.join must be strings");
    }
    return p2;
  }).join("/"));
}
function relative(from2, to) {
  from2 = resolve(from2).substr(1);
  to = resolve(to).substr(1);
  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== "")
        break;
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== "")
        break;
    }
    if (start > end)
      return [];
    return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from2.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
}
var sep = "/";
var delimiter = ":";
function dirname(path2) {
  var result = splitPath(path2), root = result[0], dir = result[1];
  if (!root && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
}
function basename(path2, ext) {
  var f2 = splitPath(path2)[2];
  if (ext && f2.substr(-1 * ext.length) === ext) {
    f2 = f2.substr(0, f2.length - ext.length);
  }
  return f2;
}
function extname(path2) {
  return splitPath(path2)[3];
}
const path = {
  extname,
  basename,
  dirname,
  sep,
  delimiter,
  relative,
  join,
  isAbsolute,
  normalize,
  resolve
};
function filter(xs, f2) {
  if (xs.filter)
    return xs.filter(f2);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f2(xs[i], i, xs))
      res.push(xs[i]);
  }
  return res;
}
var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
  return str.substr(start, len);
} : function(str, start, len) {
  if (start < 0)
    start = str.length + start;
  return str.substr(start, len);
};
const path$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  resolve,
  normalize,
  isAbsolute,
  join,
  relative,
  sep,
  delimiter,
  dirname,
  basename,
  extname,
  "default": path
});
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(path$1);
(function(module, exports) {
  var initSqlJsPromise = void 0;
  var initSqlJs2 = function(moduleConfig) {
    if (initSqlJsPromise) {
      return initSqlJsPromise;
    }
    initSqlJsPromise = new Promise(function(resolveModule, reject) {
      var Module = typeof moduleConfig !== "undefined" ? moduleConfig : {};
      var originalOnAbortFunction = Module["onAbort"];
      Module["onAbort"] = function(errorThatCausedAbort) {
        reject(new Error(errorThatCausedAbort));
        if (originalOnAbortFunction) {
          originalOnAbortFunction(errorThatCausedAbort);
        }
      };
      Module["postRun"] = Module["postRun"] || [];
      Module["postRun"].push(function() {
        resolveModule(Module);
      });
      module = void 0;
      var f2;
      f2 || (f2 = typeof Module !== "undefined" ? Module : {});
      f2.onRuntimeInitialized = function() {
        function a2(g, l2) {
          switch (typeof l2) {
            case "boolean":
              mc2(g, l2 ? 1 : 0);
              break;
            case "number":
              nc2(g, l2);
              break;
            case "string":
              oc2(g, l2, -1, -1);
              break;
            case "object":
              if (null === l2)
                lb2(g);
              else if (null != l2.length) {
                var n2 = aa2(l2, ba);
                pc2(g, n2, l2.length, -1);
                ca2(n2);
              } else
                Aa2(g, "Wrong API use : tried to return a value of an unknown type (" + l2 + ").", -1);
              break;
            default:
              lb2(g);
          }
        }
        function b2(g, l2) {
          for (var n2 = [], t2 = 0; t2 < g; t2 += 1) {
            var w2 = m2(l2 + 4 * t2, "i32"), z2 = qc2(w2);
            if (1 === z2 || 2 === z2)
              w2 = rc2(w2);
            else if (3 === z2)
              w2 = sc2(w2);
            else if (4 === z2) {
              z2 = w2;
              w2 = tc2(z2);
              z2 = uc2(z2);
              for (var N2 = new Uint8Array(w2), L2 = 0; L2 < w2; L2 += 1)
                N2[L2] = p2[z2 + L2];
              w2 = N2;
            } else
              w2 = null;
            n2.push(w2);
          }
          return n2;
        }
        function c2(g, l2) {
          this.La = g;
          this.db = l2;
          this.Ja = 1;
          this.fb = [];
        }
        function d2(g, l2) {
          this.db = l2;
          l2 = da2(g) + 1;
          this.Ya = ea2(l2);
          if (null === this.Ya)
            throw Error("Unable to allocate memory for the SQL string");
          fa2(g, q2, this.Ya, l2);
          this.eb = this.Ya;
          this.Ua = this.ib = null;
        }
        function e2(g) {
          this.filename = "dbfile_" + (4294967295 * Math.random() >>> 0);
          if (null != g) {
            var l2 = this.filename, n2 = "/", t2 = l2;
            n2 && (n2 = "string" == typeof n2 ? n2 : ha2(n2), t2 = l2 ? u2(n2 + "/" + l2) : n2);
            l2 = ia2(true, true);
            t2 = ja2(t2, (void 0 !== l2 ? l2 : 438) & 4095 | 32768, 0);
            if (g) {
              if ("string" == typeof g) {
                n2 = Array(g.length);
                for (var w2 = 0, z2 = g.length; w2 < z2; ++w2)
                  n2[w2] = g.charCodeAt(w2);
                g = n2;
              }
              ka2(t2, l2 | 146);
              n2 = la2(t2, 577);
              ma2(n2, g, 0, g.length, 0);
              na(n2);
              ka2(t2, l2);
            }
          }
          this.handleError(r2(this.filename, h2));
          this.db = m2(h2, "i32");
          ob2(this.db);
          this.Za = {};
          this.Na = {};
        }
        var h2 = x2(4), k2 = f2.cwrap, r2 = k2("sqlite3_open", "number", ["string", "number"]), y2 = k2("sqlite3_close_v2", "number", ["number"]), v2 = k2("sqlite3_exec", "number", ["number", "string", "number", "number", "number"]), F2 = k2(
          "sqlite3_changes",
          "number",
          ["number"]
        ), H2 = k2("sqlite3_prepare_v2", "number", ["number", "string", "number", "number", "number"]), pb2 = k2("sqlite3_sql", "string", ["number"]), vc2 = k2("sqlite3_normalized_sql", "string", ["number"]), qb2 = k2("sqlite3_prepare_v2", "number", ["number", "number", "number", "number", "number"]), wc2 = k2("sqlite3_bind_text", "number", ["number", "number", "number", "number", "number"]), rb2 = k2("sqlite3_bind_blob", "number", ["number", "number", "number", "number", "number"]), xc2 = k2("sqlite3_bind_double", "number", ["number", "number", "number"]), yc2 = k2("sqlite3_bind_int", "number", ["number", "number", "number"]), zc2 = k2("sqlite3_bind_parameter_index", "number", ["number", "string"]), Ac2 = k2("sqlite3_step", "number", ["number"]), Bc2 = k2("sqlite3_errmsg", "string", ["number"]), Cc2 = k2("sqlite3_column_count", "number", ["number"]), Dc2 = k2("sqlite3_data_count", "number", ["number"]), Ec2 = k2("sqlite3_column_double", "number", ["number", "number"]), sb2 = k2("sqlite3_column_text", "string", ["number", "number"]), Fc2 = k2("sqlite3_column_blob", "number", ["number", "number"]), Gc2 = k2(
          "sqlite3_column_bytes",
          "number",
          ["number", "number"]
        ), Hc2 = k2("sqlite3_column_type", "number", ["number", "number"]), Ic2 = k2("sqlite3_column_name", "string", ["number", "number"]), Jc2 = k2("sqlite3_reset", "number", ["number"]), Kc2 = k2("sqlite3_clear_bindings", "number", ["number"]), Lc2 = k2("sqlite3_finalize", "number", ["number"]), tb2 = k2("sqlite3_create_function_v2", "number", "number string number number number number number number number".split(" ")), qc2 = k2("sqlite3_value_type", "number", ["number"]), tc2 = k2("sqlite3_value_bytes", "number", ["number"]), sc2 = k2(
          "sqlite3_value_text",
          "string",
          ["number"]
        ), uc2 = k2("sqlite3_value_blob", "number", ["number"]), rc2 = k2("sqlite3_value_double", "number", ["number"]), nc2 = k2("sqlite3_result_double", "", ["number", "number"]), lb2 = k2("sqlite3_result_null", "", ["number"]), oc2 = k2("sqlite3_result_text", "", ["number", "string", "number", "number"]), pc2 = k2("sqlite3_result_blob", "", ["number", "number", "number", "number"]), mc2 = k2("sqlite3_result_int", "", ["number", "number"]), Aa2 = k2("sqlite3_result_error", "", ["number", "string", "number"]), ub2 = k2(
          "sqlite3_aggregate_context",
          "number",
          ["number", "number"]
        ), ob2 = k2("RegisterExtensionFunctions", "number", ["number"]);
        c2.prototype.bind = function(g) {
          if (!this.La)
            throw "Statement closed";
          this.reset();
          return Array.isArray(g) ? this.wb(g) : null != g && "object" === typeof g ? this.xb(g) : true;
        };
        c2.prototype.step = function() {
          if (!this.La)
            throw "Statement closed";
          this.Ja = 1;
          var g = Ac2(this.La);
          switch (g) {
            case 100:
              return true;
            case 101:
              return false;
            default:
              throw this.db.handleError(g);
          }
        };
        c2.prototype.rb = function(g) {
          null == g && (g = this.Ja, this.Ja += 1);
          return Ec2(this.La, g);
        };
        c2.prototype.Ab = function(g) {
          null == g && (g = this.Ja, this.Ja += 1);
          g = sb2(this.La, g);
          if ("function" !== typeof BigInt)
            throw Error("BigInt is not supported");
          return BigInt(g);
        };
        c2.prototype.Bb = function(g) {
          null == g && (g = this.Ja, this.Ja += 1);
          return sb2(this.La, g);
        };
        c2.prototype.getBlob = function(g) {
          null == g && (g = this.Ja, this.Ja += 1);
          var l2 = Gc2(this.La, g);
          g = Fc2(this.La, g);
          for (var n2 = new Uint8Array(l2), t2 = 0; t2 < l2; t2 += 1)
            n2[t2] = p2[g + t2];
          return n2;
        };
        c2.prototype.get = function(g, l2) {
          l2 = l2 || {};
          null != g && this.bind(g) && this.step();
          g = [];
          for (var n2 = Dc2(this.La), t2 = 0; t2 < n2; t2 += 1)
            switch (Hc2(this.La, t2)) {
              case 1:
                var w2 = l2.useBigInt ? this.Ab(t2) : this.rb(t2);
                g.push(w2);
                break;
              case 2:
                g.push(this.rb(t2));
                break;
              case 3:
                g.push(this.Bb(t2));
                break;
              case 4:
                g.push(this.getBlob(t2));
                break;
              default:
                g.push(null);
            }
          return g;
        };
        c2.prototype.getColumnNames = function() {
          for (var g = [], l2 = Cc2(this.La), n2 = 0; n2 < l2; n2 += 1)
            g.push(Ic2(this.La, n2));
          return g;
        };
        c2.prototype.getAsObject = function(g, l2) {
          g = this.get(g, l2);
          l2 = this.getColumnNames();
          for (var n2 = {}, t2 = 0; t2 < l2.length; t2 += 1)
            n2[l2[t2]] = g[t2];
          return n2;
        };
        c2.prototype.getSQL = function() {
          return pb2(this.La);
        };
        c2.prototype.getNormalizedSQL = function() {
          return vc2(this.La);
        };
        c2.prototype.run = function(g) {
          null != g && this.bind(g);
          this.step();
          return this.reset();
        };
        c2.prototype.nb = function(g, l2) {
          null == l2 && (l2 = this.Ja, this.Ja += 1);
          g = oa2(g);
          var n2 = aa2(g, ba);
          this.fb.push(n2);
          this.db.handleError(wc2(this.La, l2, n2, g.length - 1, 0));
        };
        c2.prototype.vb = function(g, l2) {
          null == l2 && (l2 = this.Ja, this.Ja += 1);
          var n2 = aa2(g, ba);
          this.fb.push(n2);
          this.db.handleError(rb2(this.La, l2, n2, g.length, 0));
        };
        c2.prototype.mb = function(g, l2) {
          null == l2 && (l2 = this.Ja, this.Ja += 1);
          this.db.handleError((g === (g | 0) ? yc2 : xc2)(this.La, l2, g));
        };
        c2.prototype.yb = function(g) {
          null == g && (g = this.Ja, this.Ja += 1);
          rb2(this.La, g, 0, 0, 0);
        };
        c2.prototype.ob = function(g, l2) {
          null == l2 && (l2 = this.Ja, this.Ja += 1);
          switch (typeof g) {
            case "string":
              this.nb(g, l2);
              return;
            case "number":
              this.mb(g, l2);
              return;
            case "bigint":
              this.nb(g.toString(), l2);
              return;
            case "boolean":
              this.mb(g + 0, l2);
              return;
            case "object":
              if (null === g) {
                this.yb(l2);
                return;
              }
              if (null != g.length) {
                this.vb(g, l2);
                return;
              }
          }
          throw "Wrong API use : tried to bind a value of an unknown type (" + g + ").";
        };
        c2.prototype.xb = function(g) {
          var l2 = this;
          Object.keys(g).forEach(function(n2) {
            var t2 = zc2(l2.La, n2);
            0 !== t2 && l2.ob(g[n2], t2);
          });
          return true;
        };
        c2.prototype.wb = function(g) {
          for (var l2 = 0; l2 < g.length; l2 += 1)
            this.ob(g[l2], l2 + 1);
          return true;
        };
        c2.prototype.reset = function() {
          this.freemem();
          return 0 === Kc2(this.La) && 0 === Jc2(this.La);
        };
        c2.prototype.freemem = function() {
          for (var g; void 0 !== (g = this.fb.pop()); )
            ca2(g);
        };
        c2.prototype.free = function() {
          this.freemem();
          var g = 0 === Lc2(this.La);
          delete this.db.Za[this.La];
          this.La = 0;
          return g;
        };
        d2.prototype.next = function() {
          if (null === this.Ya)
            return { done: true };
          null !== this.Ua && (this.Ua.free(), this.Ua = null);
          if (!this.db.db)
            throw this.gb(), Error("Database closed");
          var g = pa2(), l2 = x2(4);
          qa2(h2);
          qa2(l2);
          try {
            this.db.handleError(qb2(this.db.db, this.eb, -1, h2, l2));
            this.eb = m2(l2, "i32");
            var n2 = m2(h2, "i32");
            if (0 === n2)
              return this.gb(), { done: true };
            this.Ua = new c2(n2, this.db);
            this.db.Za[n2] = this.Ua;
            return { value: this.Ua, done: false };
          } catch (t2) {
            throw this.ib = ra2(this.eb), this.gb(), t2;
          } finally {
            sa2(g);
          }
        };
        d2.prototype.gb = function() {
          ca2(this.Ya);
          this.Ya = null;
        };
        d2.prototype.getRemainingSQL = function() {
          return null !== this.ib ? this.ib : ra2(this.eb);
        };
        "function" === typeof Symbol && "symbol" === typeof Symbol.iterator && (d2.prototype[Symbol.iterator] = function() {
          return this;
        });
        e2.prototype.run = function(g, l2) {
          if (!this.db)
            throw "Database closed";
          if (l2) {
            g = this.prepare(g, l2);
            try {
              g.step();
            } finally {
              g.free();
            }
          } else
            this.handleError(v2(this.db, g, 0, 0, h2));
          return this;
        };
        e2.prototype.exec = function(g, l2, n2) {
          if (!this.db)
            throw "Database closed";
          var t2 = pa2(), w2 = null;
          try {
            var z2 = ta2(g), N2 = x2(4);
            for (g = []; 0 !== m2(z2, "i8"); ) {
              qa2(h2);
              qa2(N2);
              this.handleError(qb2(
                this.db,
                z2,
                -1,
                h2,
                N2
              ));
              var L2 = m2(h2, "i32");
              z2 = m2(N2, "i32");
              if (0 !== L2) {
                var K2 = null;
                w2 = new c2(L2, this);
                for (null != l2 && w2.bind(l2); w2.step(); )
                  null === K2 && (K2 = { columns: w2.getColumnNames(), values: [] }, g.push(K2)), K2.values.push(w2.get(null, n2));
                w2.free();
              }
            }
            return g;
          } catch (O2) {
            throw w2 && w2.free(), O2;
          } finally {
            sa2(t2);
          }
        };
        e2.prototype.each = function(g, l2, n2, t2, w2) {
          "function" === typeof l2 && (t2 = n2, n2 = l2, l2 = void 0);
          g = this.prepare(g, l2);
          try {
            for (; g.step(); )
              n2(g.getAsObject(null, w2));
          } finally {
            g.free();
          }
          if ("function" === typeof t2)
            return t2();
        };
        e2.prototype.prepare = function(g, l2) {
          qa2(h2);
          this.handleError(H2(this.db, g, -1, h2, 0));
          g = m2(h2, "i32");
          if (0 === g)
            throw "Nothing to prepare";
          var n2 = new c2(g, this);
          null != l2 && n2.bind(l2);
          return this.Za[g] = n2;
        };
        e2.prototype.iterateStatements = function(g) {
          return new d2(g, this);
        };
        e2.prototype["export"] = function() {
          Object.values(this.Za).forEach(function(l2) {
            l2.free();
          });
          Object.values(this.Na).forEach(ua2);
          this.Na = {};
          this.handleError(y2(this.db));
          var g = va2(this.filename);
          this.handleError(r2(this.filename, h2));
          this.db = m2(h2, "i32");
          ob2(this.db);
          return g;
        };
        e2.prototype.close = function() {
          null !== this.db && (Object.values(this.Za).forEach(function(g) {
            g.free();
          }), Object.values(this.Na).forEach(ua2), this.Na = {}, this.handleError(y2(this.db)), wa2("/" + this.filename), this.db = null);
        };
        e2.prototype.handleError = function(g) {
          if (0 === g)
            return null;
          g = Bc2(this.db);
          throw Error(g);
        };
        e2.prototype.getRowsModified = function() {
          return F2(this.db);
        };
        e2.prototype.create_function = function(g, l2) {
          Object.prototype.hasOwnProperty.call(this.Na, g) && (ua2(this.Na[g]), delete this.Na[g]);
          var n2 = xa(function(t2, w2, z2) {
            w2 = b2(w2, z2);
            try {
              var N2 = l2.apply(
                null,
                w2
              );
            } catch (L2) {
              Aa2(t2, L2, -1);
              return;
            }
            a2(t2, N2);
          }, "viii");
          this.Na[g] = n2;
          this.handleError(tb2(this.db, g, l2.length, 1, 0, n2, 0, 0, 0));
          return this;
        };
        e2.prototype.create_aggregate = function(g, l2) {
          var n2 = l2.init || function() {
            return null;
          }, t2 = l2.finalize || function(K2) {
            return K2;
          }, w2 = l2.step;
          if (!w2)
            throw "An aggregate function must have a step function in " + g;
          var z2 = {};
          Object.hasOwnProperty.call(this.Na, g) && (ua2(this.Na[g]), delete this.Na[g]);
          l2 = g + "__finalize";
          Object.hasOwnProperty.call(this.Na, l2) && (ua2(this.Na[l2]), delete this.Na[l2]);
          var N2 = xa(function(K2, O2, Ua2) {
            var X2 = ub2(K2, 1);
            Object.hasOwnProperty.call(z2, X2) || (z2[X2] = n2());
            O2 = b2(O2, Ua2);
            O2 = [z2[X2]].concat(O2);
            try {
              z2[X2] = w2.apply(null, O2);
            } catch (Nc2) {
              delete z2[X2], Aa2(K2, Nc2, -1);
            }
          }, "viii"), L2 = xa(function(K2) {
            var O2 = ub2(K2, 1);
            try {
              var Ua2 = t2(z2[O2]);
            } catch (X2) {
              delete z2[O2];
              Aa2(K2, X2, -1);
              return;
            }
            a2(K2, Ua2);
            delete z2[O2];
          }, "vi");
          this.Na[g] = N2;
          this.Na[l2] = L2;
          this.handleError(tb2(this.db, g, w2.length - 1, 1, 0, 0, N2, L2, 0));
          return this;
        };
        f2.Database = e2;
      };
      var ya2 = Object.assign({}, f2), za2 = "./this.program", Ba2 = "object" == typeof window, Ca2 = "function" == typeof importScripts, Da2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, A2 = "", Ea2, Fa2, Ga2;
      if (Da2) {
        var fs = require$$0, Ha2 = require$$1;
        A2 = Ca2 ? Ha2.dirname(A2) + "/" : __dirname + "/";
        Ea2 = (a2, b2) => {
          a2 = Ia2(a2) ? new URL(a2) : Ha2.normalize(a2);
          return fs.readFileSync(a2, b2 ? void 0 : "utf8");
        };
        Ga2 = (a2) => {
          a2 = Ea2(a2, true);
          a2.buffer || (a2 = new Uint8Array(a2));
          return a2;
        };
        Fa2 = (a2, b2, c2, d2 = true) => {
          a2 = Ia2(a2) ? new URL(a2) : Ha2.normalize(a2);
          fs.readFile(a2, d2 ? void 0 : "utf8", (e2, h2) => {
            e2 ? c2(e2) : b2(d2 ? h2.buffer : h2);
          });
        };
        !f2.thisProgram && 1 < process.argv.length && (za2 = process.argv[1].replace(/\\/g, "/"));
        module.exports = f2;
        f2.inspect = () => "[Emscripten Module object]";
      } else if (Ba2 || Ca2)
        Ca2 ? A2 = self.location.href : "undefined" != typeof document && document.currentScript && (A2 = document.currentScript.src), A2 = 0 !== A2.indexOf("blob:") ? A2.substr(0, A2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", Ea2 = (a2) => {
          var b2 = new XMLHttpRequest();
          b2.open("GET", a2, false);
          b2.send(null);
          return b2.responseText;
        }, Ca2 && (Ga2 = (a2) => {
          var b2 = new XMLHttpRequest();
          b2.open("GET", a2, false);
          b2.responseType = "arraybuffer";
          b2.send(null);
          return new Uint8Array(b2.response);
        }), Fa2 = (a2, b2, c2) => {
          var d2 = new XMLHttpRequest();
          d2.open(
            "GET",
            a2,
            true
          );
          d2.responseType = "arraybuffer";
          d2.onload = () => {
            200 == d2.status || 0 == d2.status && d2.response ? b2(d2.response) : c2();
          };
          d2.onerror = c2;
          d2.send(null);
        };
      var Ja2 = f2.print || console.log.bind(console), B2 = f2.printErr || console.error.bind(console);
      Object.assign(f2, ya2);
      ya2 = null;
      f2.thisProgram && (za2 = f2.thisProgram);
      var Ka2;
      f2.wasmBinary && (Ka2 = f2.wasmBinary);
      "object" != typeof WebAssembly && C2("no native wasm support detected");
      var La2, Ma2 = false, p2, q2, Na2, D2, E2, Oa2, Pa2;
      function Qa2() {
        var a2 = La2.buffer;
        f2.HEAP8 = p2 = new Int8Array(a2);
        f2.HEAP16 = Na2 = new Int16Array(a2);
        f2.HEAPU8 = q2 = new Uint8Array(a2);
        f2.HEAPU16 = new Uint16Array(a2);
        f2.HEAP32 = D2 = new Int32Array(a2);
        f2.HEAPU32 = E2 = new Uint32Array(a2);
        f2.HEAPF32 = Oa2 = new Float32Array(a2);
        f2.HEAPF64 = Pa2 = new Float64Array(a2);
      }
      var Ra2 = [], Sa2 = [], Ta2 = [];
      function Va2() {
        var a2 = f2.preRun.shift();
        Ra2.unshift(a2);
      }
      var G2 = 0, Xa2 = null;
      function C2(a2) {
        var _a;
        (_a = f2.onAbort) == null ? void 0 : _a.call(f2, a2);
        a2 = "Aborted(" + a2 + ")";
        B2(a2);
        Ma2 = true;
        throw new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
      }
      var Ya2 = (a2) => a2.startsWith("data:application/octet-stream;base64,"), Ia2 = (a2) => a2.startsWith("file://"), Za2;
      Za2 = "sql-wasm.wasm";
      if (!Ya2(Za2)) {
        var $a = Za2;
        Za2 = f2.locateFile ? f2.locateFile($a, A2) : A2 + $a;
      }
      function ab2(a2) {
        if (a2 == Za2 && Ka2)
          return new Uint8Array(Ka2);
        if (Ga2)
          return Ga2(a2);
        throw "both async and sync fetching of the wasm failed";
      }
      function bb2(a2) {
        if (!Ka2 && (Ba2 || Ca2)) {
          if ("function" == typeof fetch && !Ia2(a2))
            return fetch(a2, { credentials: "same-origin" }).then((b2) => {
              if (!b2.ok)
                throw "failed to load wasm binary file at '" + a2 + "'";
              return b2.arrayBuffer();
            }).catch(() => ab2(a2));
          if (Fa2)
            return new Promise((b2, c2) => {
              Fa2(a2, (d2) => b2(new Uint8Array(d2)), c2);
            });
        }
        return Promise.resolve().then(() => ab2(a2));
      }
      function cb2(a2, b2, c2) {
        return bb2(a2).then((d2) => WebAssembly.instantiate(d2, b2)).then((d2) => d2).then(c2, (d2) => {
          B2(`failed to asynchronously prepare wasm: ${d2}`);
          C2(d2);
        });
      }
      function db2(a2, b2) {
        var c2 = Za2;
        Ka2 || "function" != typeof WebAssembly.instantiateStreaming || Ya2(c2) || Ia2(c2) || Da2 || "function" != typeof fetch ? cb2(c2, a2, b2) : fetch(c2, { credentials: "same-origin" }).then((d2) => WebAssembly.instantiateStreaming(d2, a2).then(b2, function(e2) {
          B2(`wasm streaming compile failed: ${e2}`);
          B2("falling back to ArrayBuffer instantiation");
          return cb2(c2, a2, b2);
        }));
      }
      var I2, J2, eb2 = (a2) => {
        for (; 0 < a2.length; )
          a2.shift()(f2);
      };
      function m2(a2, b2 = "i8") {
        b2.endsWith("*") && (b2 = "*");
        switch (b2) {
          case "i1":
            return p2[a2 >> 0];
          case "i8":
            return p2[a2 >> 0];
          case "i16":
            return Na2[a2 >> 1];
          case "i32":
            return D2[a2 >> 2];
          case "i64":
            C2("to do getValue(i64) use WASM_BIGINT");
          case "float":
            return Oa2[a2 >> 2];
          case "double":
            return Pa2[a2 >> 3];
          case "*":
            return E2[a2 >> 2];
          default:
            C2(`invalid type for getValue: ${b2}`);
        }
      }
      function qa2(a2) {
        var b2 = "i32";
        b2.endsWith("*") && (b2 = "*");
        switch (b2) {
          case "i1":
            p2[a2 >> 0] = 0;
            break;
          case "i8":
            p2[a2 >> 0] = 0;
            break;
          case "i16":
            Na2[a2 >> 1] = 0;
            break;
          case "i32":
            D2[a2 >> 2] = 0;
            break;
          case "i64":
            C2("to do setValue(i64) use WASM_BIGINT");
          case "float":
            Oa2[a2 >> 2] = 0;
            break;
          case "double":
            Pa2[a2 >> 3] = 0;
            break;
          case "*":
            E2[a2 >> 2] = 0;
            break;
          default:
            C2(`invalid type for setValue: ${b2}`);
        }
      }
      var fb2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, M2 = (a2, b2, c2) => {
        var d2 = b2 + c2;
        for (c2 = b2; a2[c2] && !(c2 >= d2); )
          ++c2;
        if (16 < c2 - b2 && a2.buffer && fb2)
          return fb2.decode(a2.subarray(b2, c2));
        for (d2 = ""; b2 < c2; ) {
          var e2 = a2[b2++];
          if (e2 & 128) {
            var h2 = a2[b2++] & 63;
            if (192 == (e2 & 224))
              d2 += String.fromCharCode((e2 & 31) << 6 | h2);
            else {
              var k2 = a2[b2++] & 63;
              e2 = 224 == (e2 & 240) ? (e2 & 15) << 12 | h2 << 6 | k2 : (e2 & 7) << 18 | h2 << 12 | k2 << 6 | a2[b2++] & 63;
              65536 > e2 ? d2 += String.fromCharCode(e2) : (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023));
            }
          } else
            d2 += String.fromCharCode(e2);
        }
        return d2;
      }, ra2 = (a2, b2) => a2 ? M2(q2, a2, b2) : "", gb2 = (a2, b2) => {
        for (var c2 = 0, d2 = a2.length - 1; 0 <= d2; d2--) {
          var e2 = a2[d2];
          "." === e2 ? a2.splice(d2, 1) : ".." === e2 ? (a2.splice(d2, 1), c2++) : c2 && (a2.splice(d2, 1), c2--);
        }
        if (b2)
          for (; c2; c2--)
            a2.unshift("..");
        return a2;
      }, u2 = (a2) => {
        var b2 = "/" === a2.charAt(0), c2 = "/" === a2.substr(-1);
        (a2 = gb2(a2.split("/").filter((d2) => !!d2), !b2).join("/")) || b2 || (a2 = ".");
        a2 && c2 && (a2 += "/");
        return (b2 ? "/" : "") + a2;
      }, hb2 = (a2) => {
        var b2 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a2).slice(1);
        a2 = b2[0];
        b2 = b2[1];
        if (!a2 && !b2)
          return ".";
        b2 && (b2 = b2.substr(0, b2.length - 1));
        return a2 + b2;
      }, ib2 = (a2) => {
        if ("/" === a2)
          return "/";
        a2 = u2(a2);
        a2 = a2.replace(/\/$/, "");
        var b2 = a2.lastIndexOf("/");
        return -1 === b2 ? a2 : a2.substr(b2 + 1);
      }, jb2 = () => {
        if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
          return (c2) => crypto.getRandomValues(c2);
        if (Da2)
          try {
            var a2 = require("crypto");
            if (a2.randomFillSync)
              return (c2) => a2.randomFillSync(c2);
            var b2 = a2.randomBytes;
            return (c2) => (c2.set(b2(c2.byteLength)), c2);
          } catch (c2) {
          }
        C2("initRandomDevice");
      }, kb2 = (a2) => (kb2 = jb2())(a2);
      function mb2() {
        for (var a2 = "", b2 = false, c2 = arguments.length - 1; -1 <= c2 && !b2; c2--) {
          b2 = 0 <= c2 ? arguments[c2] : "/";
          if ("string" != typeof b2)
            throw new TypeError("Arguments to path.resolve must be strings");
          if (!b2)
            return "";
          a2 = b2 + "/" + a2;
          b2 = "/" === b2.charAt(0);
        }
        a2 = gb2(a2.split("/").filter((d2) => !!d2), !b2).join("/");
        return (b2 ? "/" : "") + a2 || ".";
      }
      var nb2 = [], da2 = (a2) => {
        for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
          var d2 = a2.charCodeAt(c2);
          127 >= d2 ? b2++ : 2047 >= d2 ? b2 += 2 : 55296 <= d2 && 57343 >= d2 ? (b2 += 4, ++c2) : b2 += 3;
        }
        return b2;
      }, fa2 = (a2, b2, c2, d2) => {
        if (!(0 < d2))
          return 0;
        var e2 = c2;
        d2 = c2 + d2 - 1;
        for (var h2 = 0; h2 < a2.length; ++h2) {
          var k2 = a2.charCodeAt(h2);
          if (55296 <= k2 && 57343 >= k2) {
            var r2 = a2.charCodeAt(++h2);
            k2 = 65536 + ((k2 & 1023) << 10) | r2 & 1023;
          }
          if (127 >= k2) {
            if (c2 >= d2)
              break;
            b2[c2++] = k2;
          } else {
            if (2047 >= k2) {
              if (c2 + 1 >= d2)
                break;
              b2[c2++] = 192 | k2 >> 6;
            } else {
              if (65535 >= k2) {
                if (c2 + 2 >= d2)
                  break;
                b2[c2++] = 224 | k2 >> 12;
              } else {
                if (c2 + 3 >= d2)
                  break;
                b2[c2++] = 240 | k2 >> 18;
                b2[c2++] = 128 | k2 >> 12 & 63;
              }
              b2[c2++] = 128 | k2 >> 6 & 63;
            }
            b2[c2++] = 128 | k2 & 63;
          }
        }
        b2[c2] = 0;
        return c2 - e2;
      };
      function oa2(a2, b2) {
        var c2 = Array(da2(a2) + 1);
        a2 = fa2(a2, c2, 0, c2.length);
        b2 && (c2.length = a2);
        return c2;
      }
      var vb2 = [];
      function wb2(a2, b2) {
        vb2[a2] = { input: [], output: [], Xa: b2 };
        xb2(a2, yb2);
      }
      var yb2 = { open(a2) {
        var b2 = vb2[a2.node.rdev];
        if (!b2)
          throw new P2(43);
        a2.tty = b2;
        a2.seekable = false;
      }, close(a2) {
        a2.tty.Xa.fsync(a2.tty);
      }, fsync(a2) {
        a2.tty.Xa.fsync(a2.tty);
      }, read(a2, b2, c2, d2) {
        if (!a2.tty || !a2.tty.Xa.sb)
          throw new P2(60);
        for (var e2 = 0, h2 = 0; h2 < d2; h2++) {
          try {
            var k2 = a2.tty.Xa.sb(a2.tty);
          } catch (r2) {
            throw new P2(29);
          }
          if (void 0 === k2 && 0 === e2)
            throw new P2(6);
          if (null === k2 || void 0 === k2)
            break;
          e2++;
          b2[c2 + h2] = k2;
        }
        e2 && (a2.node.timestamp = Date.now());
        return e2;
      }, write(a2, b2, c2, d2) {
        if (!a2.tty || !a2.tty.Xa.jb)
          throw new P2(60);
        try {
          for (var e2 = 0; e2 < d2; e2++)
            a2.tty.Xa.jb(a2.tty, b2[c2 + e2]);
        } catch (h2) {
          throw new P2(29);
        }
        d2 && (a2.node.timestamp = Date.now());
        return e2;
      } }, zb2 = { sb() {
        a: {
          if (!nb2.length) {
            var a2 = null;
            if (Da2) {
              var b2 = Buffer.alloc(256), c2 = 0, d2 = process.stdin.fd;
              try {
                c2 = fs.readSync(d2, b2);
              } catch (e2) {
                if (e2.toString().includes("EOF"))
                  c2 = 0;
                else
                  throw e2;
              }
              0 < c2 ? a2 = b2.slice(0, c2).toString("utf-8") : a2 = null;
            } else
              "undefined" != typeof window && "function" == typeof window.prompt ? (a2 = window.prompt("Input: "), null !== a2 && (a2 += "\n")) : "function" == typeof readline && (a2 = readline(), null !== a2 && (a2 += "\n"));
            if (!a2) {
              a2 = null;
              break a;
            }
            nb2 = oa2(a2, true);
          }
          a2 = nb2.shift();
        }
        return a2;
      }, jb(a2, b2) {
        null === b2 || 10 === b2 ? (Ja2(M2(a2.output, 0)), a2.output = []) : 0 != b2 && a2.output.push(b2);
      }, fsync(a2) {
        a2.output && 0 < a2.output.length && (Ja2(M2(a2.output, 0)), a2.output = []);
      }, Mb() {
        return { Ib: 25856, Kb: 5, Hb: 191, Jb: 35387, Gb: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      }, Nb() {
        return 0;
      }, Ob() {
        return [24, 80];
      } }, Ab2 = { jb(a2, b2) {
        null === b2 || 10 === b2 ? (B2(M2(a2.output, 0)), a2.output = []) : 0 != b2 && a2.output.push(b2);
      }, fsync(a2) {
        a2.output && 0 < a2.output.length && (B2(M2(a2.output, 0)), a2.output = []);
      } };
      function Bb2(a2, b2) {
        var c2 = a2.Ia ? a2.Ia.length : 0;
        c2 >= b2 || (b2 = Math.max(b2, c2 * (1048576 > c2 ? 2 : 1.125) >>> 0), 0 != c2 && (b2 = Math.max(b2, 256)), c2 = a2.Ia, a2.Ia = new Uint8Array(b2), 0 < a2.Ma && a2.Ia.set(c2.subarray(0, a2.Ma), 0));
      }
      var Q2 = {
        Qa: null,
        Ra() {
          return Q2.createNode(null, "/", 16895, 0);
        },
        createNode(a2, b2, c2, d2) {
          if (24576 === (c2 & 61440) || 4096 === (c2 & 61440))
            throw new P2(63);
          Q2.Qa || (Q2.Qa = { dir: { node: { Pa: Q2.Ga.Pa, Oa: Q2.Ga.Oa, lookup: Q2.Ga.lookup, ab: Q2.Ga.ab, rename: Q2.Ga.rename, unlink: Q2.Ga.unlink, rmdir: Q2.Ga.rmdir, readdir: Q2.Ga.readdir, symlink: Q2.Ga.symlink }, stream: { Ta: Q2.Ha.Ta } }, file: { node: { Pa: Q2.Ga.Pa, Oa: Q2.Ga.Oa }, stream: { Ta: Q2.Ha.Ta, read: Q2.Ha.read, write: Q2.Ha.write, lb: Q2.Ha.lb, bb: Q2.Ha.bb, cb: Q2.Ha.cb } }, link: {
            node: { Pa: Q2.Ga.Pa, Oa: Q2.Ga.Oa, readlink: Q2.Ga.readlink },
            stream: {}
          }, pb: { node: { Pa: Q2.Ga.Pa, Oa: Q2.Ga.Oa }, stream: Cb2 } });
          c2 = Db2(a2, b2, c2, d2);
          R2(c2.mode) ? (c2.Ga = Q2.Qa.dir.node, c2.Ha = Q2.Qa.dir.stream, c2.Ia = {}) : 32768 === (c2.mode & 61440) ? (c2.Ga = Q2.Qa.file.node, c2.Ha = Q2.Qa.file.stream, c2.Ma = 0, c2.Ia = null) : 40960 === (c2.mode & 61440) ? (c2.Ga = Q2.Qa.link.node, c2.Ha = Q2.Qa.link.stream) : 8192 === (c2.mode & 61440) && (c2.Ga = Q2.Qa.pb.node, c2.Ha = Q2.Qa.pb.stream);
          c2.timestamp = Date.now();
          a2 && (a2.Ia[b2] = c2, a2.timestamp = c2.timestamp);
          return c2;
        },
        Lb(a2) {
          return a2.Ia ? a2.Ia.subarray ? a2.Ia.subarray(0, a2.Ma) : new Uint8Array(a2.Ia) : new Uint8Array(0);
        },
        Ga: { Pa(a2) {
          var b2 = {};
          b2.dev = 8192 === (a2.mode & 61440) ? a2.id : 1;
          b2.ino = a2.id;
          b2.mode = a2.mode;
          b2.nlink = 1;
          b2.uid = 0;
          b2.gid = 0;
          b2.rdev = a2.rdev;
          R2(a2.mode) ? b2.size = 4096 : 32768 === (a2.mode & 61440) ? b2.size = a2.Ma : 40960 === (a2.mode & 61440) ? b2.size = a2.link.length : b2.size = 0;
          b2.atime = new Date(a2.timestamp);
          b2.mtime = new Date(a2.timestamp);
          b2.ctime = new Date(a2.timestamp);
          b2.zb = 4096;
          b2.blocks = Math.ceil(b2.size / b2.zb);
          return b2;
        }, Oa(a2, b2) {
          void 0 !== b2.mode && (a2.mode = b2.mode);
          void 0 !== b2.timestamp && (a2.timestamp = b2.timestamp);
          if (void 0 !== b2.size && (b2 = b2.size, a2.Ma != b2))
            if (0 == b2)
              a2.Ia = null, a2.Ma = 0;
            else {
              var c2 = a2.Ia;
              a2.Ia = new Uint8Array(b2);
              c2 && a2.Ia.set(c2.subarray(0, Math.min(b2, a2.Ma)));
              a2.Ma = b2;
            }
        }, lookup() {
          throw Eb2[44];
        }, ab(a2, b2, c2, d2) {
          return Q2.createNode(a2, b2, c2, d2);
        }, rename(a2, b2, c2) {
          if (R2(a2.mode)) {
            try {
              var d2 = Fb2(b2, c2);
            } catch (h2) {
            }
            if (d2)
              for (var e2 in d2.Ia)
                throw new P2(55);
          }
          delete a2.parent.Ia[a2.name];
          a2.parent.timestamp = Date.now();
          a2.name = c2;
          b2.Ia[c2] = a2;
          b2.timestamp = a2.parent.timestamp;
          a2.parent = b2;
        }, unlink(a2, b2) {
          delete a2.Ia[b2];
          a2.timestamp = Date.now();
        }, rmdir(a2, b2) {
          var c2 = Fb2(a2, b2), d2;
          for (d2 in c2.Ia)
            throw new P2(55);
          delete a2.Ia[b2];
          a2.timestamp = Date.now();
        }, readdir(a2) {
          var b2 = [".", ".."], c2;
          for (c2 of Object.keys(a2.Ia))
            b2.push(c2);
          return b2;
        }, symlink(a2, b2, c2) {
          a2 = Q2.createNode(a2, b2, 41471, 0);
          a2.link = c2;
          return a2;
        }, readlink(a2) {
          if (40960 !== (a2.mode & 61440))
            throw new P2(28);
          return a2.link;
        } },
        Ha: {
          read(a2, b2, c2, d2, e2) {
            var h2 = a2.node.Ia;
            if (e2 >= a2.node.Ma)
              return 0;
            a2 = Math.min(a2.node.Ma - e2, d2);
            if (8 < a2 && h2.subarray)
              b2.set(h2.subarray(e2, e2 + a2), c2);
            else
              for (d2 = 0; d2 < a2; d2++)
                b2[c2 + d2] = h2[e2 + d2];
            return a2;
          },
          write(a2, b2, c2, d2, e2, h2) {
            b2.buffer === p2.buffer && (h2 = false);
            if (!d2)
              return 0;
            a2 = a2.node;
            a2.timestamp = Date.now();
            if (b2.subarray && (!a2.Ia || a2.Ia.subarray)) {
              if (h2)
                return a2.Ia = b2.subarray(c2, c2 + d2), a2.Ma = d2;
              if (0 === a2.Ma && 0 === e2)
                return a2.Ia = b2.slice(c2, c2 + d2), a2.Ma = d2;
              if (e2 + d2 <= a2.Ma)
                return a2.Ia.set(b2.subarray(c2, c2 + d2), e2), d2;
            }
            Bb2(a2, e2 + d2);
            if (a2.Ia.subarray && b2.subarray)
              a2.Ia.set(b2.subarray(c2, c2 + d2), e2);
            else
              for (h2 = 0; h2 < d2; h2++)
                a2.Ia[e2 + h2] = b2[c2 + h2];
            a2.Ma = Math.max(a2.Ma, e2 + d2);
            return d2;
          },
          Ta(a2, b2, c2) {
            1 === c2 ? b2 += a2.position : 2 === c2 && 32768 === (a2.node.mode & 61440) && (b2 += a2.node.Ma);
            if (0 > b2)
              throw new P2(28);
            return b2;
          },
          lb(a2, b2, c2) {
            Bb2(a2.node, b2 + c2);
            a2.node.Ma = Math.max(a2.node.Ma, b2 + c2);
          },
          bb(a2, b2, c2, d2, e2) {
            if (32768 !== (a2.node.mode & 61440))
              throw new P2(43);
            a2 = a2.node.Ia;
            if (e2 & 2 || a2.buffer !== p2.buffer) {
              if (0 < c2 || c2 + b2 < a2.length)
                a2.subarray ? a2 = a2.subarray(c2, c2 + b2) : a2 = Array.prototype.slice.call(a2, c2, c2 + b2);
              c2 = true;
              b2 = 65536 * Math.ceil(b2 / 65536);
              (e2 = Gb2(65536, b2)) ? (q2.fill(0, e2, e2 + b2), b2 = e2) : b2 = 0;
              if (!b2)
                throw new P2(48);
              p2.set(a2, b2);
            } else
              c2 = false, b2 = a2.byteOffset;
            return { Db: b2, ub: c2 };
          },
          cb(a2, b2, c2, d2) {
            Q2.Ha.write(a2, b2, 0, d2, c2, false);
            return 0;
          }
        }
      }, ia2 = (a2, b2) => {
        var c2 = 0;
        a2 && (c2 |= 365);
        b2 && (c2 |= 146);
        return c2;
      }, Hb2 = null, Ib2 = {}, Jb2 = [], Kb2 = 1, S2 = null, Lb2 = true, P2 = null, Eb2 = {};
      function T2(a2, b2 = {}) {
        a2 = mb2(a2);
        if (!a2)
          return { path: "", node: null };
        b2 = Object.assign({ qb: true, kb: 0 }, b2);
        if (8 < b2.kb)
          throw new P2(32);
        a2 = a2.split("/").filter((k2) => !!k2);
        for (var c2 = Hb2, d2 = "/", e2 = 0; e2 < a2.length; e2++) {
          var h2 = e2 === a2.length - 1;
          if (h2 && b2.parent)
            break;
          c2 = Fb2(c2, a2[e2]);
          d2 = u2(d2 + "/" + a2[e2]);
          c2.Va && (!h2 || h2 && b2.qb) && (c2 = c2.Va.root);
          if (!h2 || b2.Sa) {
            for (h2 = 0; 40960 === (c2.mode & 61440); )
              if (c2 = Mb(d2), d2 = mb2(hb2(d2), c2), c2 = T2(d2, { kb: b2.kb + 1 }).node, 40 < h2++)
                throw new P2(32);
          }
        }
        return { path: d2, node: c2 };
      }
      function ha2(a2) {
        for (var b2; ; ) {
          if (a2 === a2.parent)
            return a2 = a2.Ra.tb, b2 ? "/" !== a2[a2.length - 1] ? `${a2}/${b2}` : a2 + b2 : a2;
          b2 = b2 ? `${a2.name}/${b2}` : a2.name;
          a2 = a2.parent;
        }
      }
      function Nb2(a2, b2) {
        for (var c2 = 0, d2 = 0; d2 < b2.length; d2++)
          c2 = (c2 << 5) - c2 + b2.charCodeAt(d2) | 0;
        return (a2 + c2 >>> 0) % S2.length;
      }
      function Ob2(a2) {
        var b2 = Nb2(a2.parent.id, a2.name);
        if (S2[b2] === a2)
          S2[b2] = a2.Wa;
        else
          for (b2 = S2[b2]; b2; ) {
            if (b2.Wa === a2) {
              b2.Wa = a2.Wa;
              break;
            }
            b2 = b2.Wa;
          }
      }
      function Fb2(a2, b2) {
        var c2;
        if (c2 = (c2 = Pb2(a2, "x")) ? c2 : a2.Ga.lookup ? 0 : 2)
          throw new P2(c2, a2);
        for (c2 = S2[Nb2(a2.id, b2)]; c2; c2 = c2.Wa) {
          var d2 = c2.name;
          if (c2.parent.id === a2.id && d2 === b2)
            return c2;
        }
        return a2.Ga.lookup(a2, b2);
      }
      function Db2(a2, b2, c2, d2) {
        a2 = new Qb2(a2, b2, c2, d2);
        b2 = Nb2(a2.parent.id, a2.name);
        a2.Wa = S2[b2];
        return S2[b2] = a2;
      }
      function R2(a2) {
        return 16384 === (a2 & 61440);
      }
      function Rb2(a2) {
        var b2 = ["r", "w", "rw"][a2 & 3];
        a2 & 512 && (b2 += "w");
        return b2;
      }
      function Pb2(a2, b2) {
        if (Lb2)
          return 0;
        if (!b2.includes("r") || a2.mode & 292) {
          if (b2.includes("w") && !(a2.mode & 146) || b2.includes("x") && !(a2.mode & 73))
            return 2;
        } else
          return 2;
        return 0;
      }
      function Sb2(a2, b2) {
        try {
          return Fb2(a2, b2), 20;
        } catch (c2) {
        }
        return Pb2(a2, "wx");
      }
      function Tb2(a2, b2, c2) {
        try {
          var d2 = Fb2(a2, b2);
        } catch (e2) {
          return e2.Ka;
        }
        if (a2 = Pb2(a2, "wx"))
          return a2;
        if (c2) {
          if (!R2(d2.mode))
            return 54;
          if (d2 === d2.parent || "/" === ha2(d2))
            return 10;
        } else if (R2(d2.mode))
          return 31;
        return 0;
      }
      function Ub2() {
        for (var a2 = 0; 4096 >= a2; a2++)
          if (!Jb2[a2])
            return a2;
        throw new P2(33);
      }
      function U2(a2) {
        a2 = Jb2[a2];
        if (!a2)
          throw new P2(8);
        return a2;
      }
      function Vb2(a2, b2 = -1) {
        Wb2 || (Wb2 = function() {
          this.$a = {};
        }, Wb2.prototype = {}, Object.defineProperties(Wb2.prototype, { object: { get() {
          return this.node;
        }, set(c2) {
          this.node = c2;
        } }, flags: { get() {
          return this.$a.flags;
        }, set(c2) {
          this.$a.flags = c2;
        } }, position: { get() {
          return this.$a.position;
        }, set(c2) {
          this.$a.position = c2;
        } } }));
        a2 = Object.assign(new Wb2(), a2);
        -1 == b2 && (b2 = Ub2());
        a2.fd = b2;
        return Jb2[b2] = a2;
      }
      var Cb2 = { open(a2) {
        var _a, _b;
        a2.Ha = Ib2[a2.node.rdev].Ha;
        (_b = (_a = a2.Ha).open) == null ? void 0 : _b.call(_a, a2);
      }, Ta() {
        throw new P2(70);
      } };
      function xb2(a2, b2) {
        Ib2[a2] = { Ha: b2 };
      }
      function Xb2(a2, b2) {
        var c2 = "/" === b2, d2 = !b2;
        if (c2 && Hb2)
          throw new P2(10);
        if (!c2 && !d2) {
          var e2 = T2(b2, { qb: false });
          b2 = e2.path;
          e2 = e2.node;
          if (e2.Va)
            throw new P2(10);
          if (!R2(e2.mode))
            throw new P2(54);
        }
        b2 = { type: a2, Pb: {}, tb: b2, Cb: [] };
        a2 = a2.Ra(b2);
        a2.Ra = b2;
        b2.root = a2;
        c2 ? Hb2 = a2 : e2 && (e2.Va = b2, e2.Ra && e2.Ra.Cb.push(b2));
      }
      function ja2(a2, b2, c2) {
        var d2 = T2(a2, { parent: true }).node;
        a2 = ib2(a2);
        if (!a2 || "." === a2 || ".." === a2)
          throw new P2(28);
        var e2 = Sb2(d2, a2);
        if (e2)
          throw new P2(e2);
        if (!d2.Ga.ab)
          throw new P2(63);
        return d2.Ga.ab(d2, a2, b2, c2);
      }
      function V2(a2, b2) {
        return ja2(a2, (void 0 !== b2 ? b2 : 511) & 1023 | 16384, 0);
      }
      function Yb2(a2, b2, c2) {
        "undefined" == typeof c2 && (c2 = b2, b2 = 438);
        ja2(a2, b2 | 8192, c2);
      }
      function Zb2(a2, b2) {
        if (!mb2(a2))
          throw new P2(44);
        var c2 = T2(b2, { parent: true }).node;
        if (!c2)
          throw new P2(44);
        b2 = ib2(b2);
        var d2 = Sb2(c2, b2);
        if (d2)
          throw new P2(d2);
        if (!c2.Ga.symlink)
          throw new P2(63);
        c2.Ga.symlink(c2, b2, a2);
      }
      function $b2(a2) {
        var b2 = T2(a2, { parent: true }).node;
        a2 = ib2(a2);
        var c2 = Fb2(b2, a2), d2 = Tb2(b2, a2, true);
        if (d2)
          throw new P2(d2);
        if (!b2.Ga.rmdir)
          throw new P2(63);
        if (c2.Va)
          throw new P2(10);
        b2.Ga.rmdir(b2, a2);
        Ob2(c2);
      }
      function wa2(a2) {
        var b2 = T2(a2, { parent: true }).node;
        if (!b2)
          throw new P2(44);
        a2 = ib2(a2);
        var c2 = Fb2(b2, a2), d2 = Tb2(b2, a2, false);
        if (d2)
          throw new P2(d2);
        if (!b2.Ga.unlink)
          throw new P2(63);
        if (c2.Va)
          throw new P2(10);
        b2.Ga.unlink(b2, a2);
        Ob2(c2);
      }
      function Mb(a2) {
        a2 = T2(a2).node;
        if (!a2)
          throw new P2(44);
        if (!a2.Ga.readlink)
          throw new P2(28);
        return mb2(ha2(a2.parent), a2.Ga.readlink(a2));
      }
      function ac2(a2, b2) {
        a2 = T2(a2, { Sa: !b2 }).node;
        if (!a2)
          throw new P2(44);
        if (!a2.Ga.Pa)
          throw new P2(63);
        return a2.Ga.Pa(a2);
      }
      function bc2(a2) {
        return ac2(a2, true);
      }
      function ka2(a2, b2) {
        a2 = "string" == typeof a2 ? T2(a2, { Sa: true }).node : a2;
        if (!a2.Ga.Oa)
          throw new P2(63);
        a2.Ga.Oa(a2, { mode: b2 & 4095 | a2.mode & -4096, timestamp: Date.now() });
      }
      function cc2(a2, b2) {
        if (0 > b2)
          throw new P2(28);
        a2 = "string" == typeof a2 ? T2(a2, { Sa: true }).node : a2;
        if (!a2.Ga.Oa)
          throw new P2(63);
        if (R2(a2.mode))
          throw new P2(31);
        if (32768 !== (a2.mode & 61440))
          throw new P2(28);
        var c2 = Pb2(a2, "w");
        if (c2)
          throw new P2(c2);
        a2.Ga.Oa(a2, { size: b2, timestamp: Date.now() });
      }
      function la2(a2, b2, c2) {
        if ("" === a2)
          throw new P2(44);
        if ("string" == typeof b2) {
          var d2 = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[b2];
          if ("undefined" == typeof d2)
            throw Error(`Unknown file open mode: ${b2}`);
          b2 = d2;
        }
        c2 = b2 & 64 ? ("undefined" == typeof c2 ? 438 : c2) & 4095 | 32768 : 0;
        if ("object" == typeof a2)
          var e2 = a2;
        else {
          a2 = u2(a2);
          try {
            e2 = T2(a2, { Sa: !(b2 & 131072) }).node;
          } catch (h2) {
          }
        }
        d2 = false;
        if (b2 & 64)
          if (e2) {
            if (b2 & 128)
              throw new P2(20);
          } else
            e2 = ja2(a2, c2, 0), d2 = true;
        if (!e2)
          throw new P2(44);
        8192 === (e2.mode & 61440) && (b2 &= -513);
        if (b2 & 65536 && !R2(e2.mode))
          throw new P2(54);
        if (!d2 && (c2 = e2 ? 40960 === (e2.mode & 61440) ? 32 : R2(e2.mode) && ("r" !== Rb2(b2) || b2 & 512) ? 31 : Pb2(e2, Rb2(b2)) : 44))
          throw new P2(c2);
        b2 & 512 && !d2 && cc2(e2, 0);
        b2 &= -131713;
        e2 = Vb2({ node: e2, path: ha2(e2), flags: b2, seekable: true, position: 0, Ha: e2.Ha, Fb: [], error: false });
        e2.Ha.open && e2.Ha.open(e2);
        !f2.logReadFiles || b2 & 1 || (dc2 || (dc2 = {}), a2 in dc2 || (dc2[a2] = 1));
        return e2;
      }
      function na(a2) {
        if (null === a2.fd)
          throw new P2(8);
        a2.hb && (a2.hb = null);
        try {
          a2.Ha.close && a2.Ha.close(a2);
        } catch (b2) {
          throw b2;
        } finally {
          Jb2[a2.fd] = null;
        }
        a2.fd = null;
      }
      function ec2(a2, b2, c2) {
        if (null === a2.fd)
          throw new P2(8);
        if (!a2.seekable || !a2.Ha.Ta)
          throw new P2(70);
        if (0 != c2 && 1 != c2 && 2 != c2)
          throw new P2(28);
        a2.position = a2.Ha.Ta(a2, b2, c2);
        a2.Fb = [];
      }
      function fc2(a2, b2, c2, d2, e2) {
        if (0 > d2 || 0 > e2)
          throw new P2(28);
        if (null === a2.fd)
          throw new P2(8);
        if (1 === (a2.flags & 2097155))
          throw new P2(8);
        if (R2(a2.node.mode))
          throw new P2(31);
        if (!a2.Ha.read)
          throw new P2(28);
        var h2 = "undefined" != typeof e2;
        if (!h2)
          e2 = a2.position;
        else if (!a2.seekable)
          throw new P2(70);
        b2 = a2.Ha.read(a2, b2, c2, d2, e2);
        h2 || (a2.position += b2);
        return b2;
      }
      function ma2(a2, b2, c2, d2, e2) {
        if (0 > d2 || 0 > e2)
          throw new P2(28);
        if (null === a2.fd)
          throw new P2(8);
        if (0 === (a2.flags & 2097155))
          throw new P2(8);
        if (R2(a2.node.mode))
          throw new P2(31);
        if (!a2.Ha.write)
          throw new P2(28);
        a2.seekable && a2.flags & 1024 && ec2(a2, 0, 2);
        var h2 = "undefined" != typeof e2;
        if (!h2)
          e2 = a2.position;
        else if (!a2.seekable)
          throw new P2(70);
        b2 = a2.Ha.write(a2, b2, c2, d2, e2, void 0);
        h2 || (a2.position += b2);
        return b2;
      }
      function va2(a2) {
        var c2;
        var d2 = la2(a2, d2 || 0);
        a2 = ac2(a2).size;
        var e2 = new Uint8Array(a2);
        fc2(d2, e2, 0, a2, 0);
        c2 = e2;
        na(d2);
        return c2;
      }
      function gc2() {
        P2 || (P2 = function(a2, b2) {
          this.name = "ErrnoError";
          this.node = b2;
          this.Eb = function(c2) {
            this.Ka = c2;
          };
          this.Eb(a2);
          this.message = "FS error";
        }, P2.prototype = Error(), P2.prototype.constructor = P2, [44].forEach((a2) => {
          Eb2[a2] = new P2(a2);
          Eb2[a2].stack = "<generic error, no stack>";
        }));
      }
      var hc2;
      function ic2(a2, b2, c2) {
        a2 = u2("/dev/" + a2);
        var d2 = ia2(!!b2, !!c2);
        jc2 || (jc2 = 64);
        var e2 = jc2++ << 8 | 0;
        xb2(e2, { open(h2) {
          h2.seekable = false;
        }, close() {
          var _a;
          ((_a = c2 == null ? void 0 : c2.buffer) == null ? void 0 : _a.length) && c2(10);
        }, read(h2, k2, r2, y2) {
          for (var v2 = 0, F2 = 0; F2 < y2; F2++) {
            try {
              var H2 = b2();
            } catch (pb2) {
              throw new P2(29);
            }
            if (void 0 === H2 && 0 === v2)
              throw new P2(6);
            if (null === H2 || void 0 === H2)
              break;
            v2++;
            k2[r2 + F2] = H2;
          }
          v2 && (h2.node.timestamp = Date.now());
          return v2;
        }, write(h2, k2, r2, y2) {
          for (var v2 = 0; v2 < y2; v2++)
            try {
              c2(k2[r2 + v2]);
            } catch (F2) {
              throw new P2(29);
            }
          y2 && (h2.node.timestamp = Date.now());
          return v2;
        } });
        Yb2(a2, d2, e2);
      }
      var jc2, W2 = {}, Wb2, dc2;
      function kc2(a2, b2, c2) {
        if ("/" === b2.charAt(0))
          return b2;
        a2 = -100 === a2 ? "/" : U2(a2).path;
        if (0 == b2.length) {
          if (!c2)
            throw new P2(44);
          return a2;
        }
        return u2(a2 + "/" + b2);
      }
      function lc2(a2, b2, c2) {
        try {
          var d2 = a2(b2);
        } catch (h2) {
          if (h2 && h2.node && u2(b2) !== u2(ha2(h2.node)))
            return -54;
          throw h2;
        }
        D2[c2 >> 2] = d2.dev;
        D2[c2 + 4 >> 2] = d2.mode;
        E2[c2 + 8 >> 2] = d2.nlink;
        D2[c2 + 12 >> 2] = d2.uid;
        D2[c2 + 16 >> 2] = d2.gid;
        D2[c2 + 20 >> 2] = d2.rdev;
        J2 = [d2.size >>> 0, (I2 = d2.size, 1 <= +Math.abs(I2) ? 0 < I2 ? +Math.floor(I2 / 4294967296) >>> 0 : ~~+Math.ceil((I2 - +(~~I2 >>> 0)) / 4294967296) >>> 0 : 0)];
        D2[c2 + 24 >> 2] = J2[0];
        D2[c2 + 28 >> 2] = J2[1];
        D2[c2 + 32 >> 2] = 4096;
        D2[c2 + 36 >> 2] = d2.blocks;
        a2 = d2.atime.getTime();
        b2 = d2.mtime.getTime();
        var e2 = d2.ctime.getTime();
        J2 = [Math.floor(a2 / 1e3) >>> 0, (I2 = Math.floor(a2 / 1e3), 1 <= +Math.abs(I2) ? 0 < I2 ? +Math.floor(I2 / 4294967296) >>> 0 : ~~+Math.ceil((I2 - +(~~I2 >>> 0)) / 4294967296) >>> 0 : 0)];
        D2[c2 + 40 >> 2] = J2[0];
        D2[c2 + 44 >> 2] = J2[1];
        E2[c2 + 48 >> 2] = a2 % 1e3 * 1e3;
        J2 = [Math.floor(b2 / 1e3) >>> 0, (I2 = Math.floor(b2 / 1e3), 1 <= +Math.abs(I2) ? 0 < I2 ? +Math.floor(I2 / 4294967296) >>> 0 : ~~+Math.ceil((I2 - +(~~I2 >>> 0)) / 4294967296) >>> 0 : 0)];
        D2[c2 + 56 >> 2] = J2[0];
        D2[c2 + 60 >> 2] = J2[1];
        E2[c2 + 64 >> 2] = b2 % 1e3 * 1e3;
        J2 = [Math.floor(e2 / 1e3) >>> 0, (I2 = Math.floor(e2 / 1e3), 1 <= +Math.abs(I2) ? 0 < I2 ? +Math.floor(I2 / 4294967296) >>> 0 : ~~+Math.ceil((I2 - +(~~I2 >>> 0)) / 4294967296) >>> 0 : 0)];
        D2[c2 + 72 >> 2] = J2[0];
        D2[c2 + 76 >> 2] = J2[1];
        E2[c2 + 80 >> 2] = e2 % 1e3 * 1e3;
        J2 = [d2.ino >>> 0, (I2 = d2.ino, 1 <= +Math.abs(I2) ? 0 < I2 ? +Math.floor(I2 / 4294967296) >>> 0 : ~~+Math.ceil((I2 - +(~~I2 >>> 0)) / 4294967296) >>> 0 : 0)];
        D2[c2 + 88 >> 2] = J2[0];
        D2[c2 + 92 >> 2] = J2[1];
        return 0;
      }
      var Mc2 = void 0;
      function Oc2() {
        var a2 = D2[+Mc2 >> 2];
        Mc2 += 4;
        return a2;
      }
      var Pc2 = (a2, b2) => b2 + 2097152 >>> 0 < 4194305 - !!a2 ? (a2 >>> 0) + 4294967296 * b2 : NaN, Qc2 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Rc2 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Sc2 = (a2) => {
        var b2 = da2(a2) + 1, c2 = ea2(b2);
        c2 && fa2(a2, q2, c2, b2);
        return c2;
      }, Tc2 = {}, Vc2 = () => {
        if (!Uc2) {
          var a2 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: za2 || "./this.program" }, b2;
          for (b2 in Tc2)
            void 0 === Tc2[b2] ? delete a2[b2] : a2[b2] = Tc2[b2];
          var c2 = [];
          for (b2 in a2)
            c2.push(`${b2}=${a2[b2]}`);
          Uc2 = c2;
        }
        return Uc2;
      }, Uc2, ta2 = (a2) => {
        var b2 = da2(a2) + 1, c2 = x2(b2);
        fa2(a2, q2, c2, b2);
        return c2;
      }, Wc2 = (a2, b2, c2, d2) => {
        var e2 = { string: (v2) => {
          var F2 = 0;
          null !== v2 && void 0 !== v2 && 0 !== v2 && (F2 = ta2(v2));
          return F2;
        }, array: (v2) => {
          var F2 = x2(v2.length);
          p2.set(v2, F2);
          return F2;
        } };
        a2 = f2["_" + a2];
        var h2 = [], k2 = 0;
        if (d2)
          for (var r2 = 0; r2 < d2.length; r2++) {
            var y2 = e2[c2[r2]];
            y2 ? (0 === k2 && (k2 = pa2()), h2[r2] = y2(d2[r2])) : h2[r2] = d2[r2];
          }
        c2 = a2.apply(null, h2);
        return c2 = function(v2) {
          0 !== k2 && sa2(k2);
          return "string" === b2 ? v2 ? M2(q2, v2) : "" : "boolean" === b2 ? !!v2 : v2;
        }(c2);
      }, ba = 0, aa2 = (a2, b2) => {
        b2 = 1 == b2 ? x2(a2.length) : ea2(a2.length);
        a2.subarray || a2.slice || (a2 = new Uint8Array(a2));
        q2.set(a2, b2);
        return b2;
      }, Xc2, Yc2 = [], Y2, ua2 = (a2) => {
        Xc2.delete(Y2.get(a2));
        Y2.set(a2, null);
        Yc2.push(a2);
      }, xa = (a2, b2) => {
        if (!Xc2) {
          Xc2 = /* @__PURE__ */ new WeakMap();
          var c2 = Y2.length;
          if (Xc2)
            for (var d2 = 0; d2 < 0 + c2; d2++) {
              var e2 = Y2.get(d2);
              e2 && Xc2.set(e2, d2);
            }
        }
        if (c2 = Xc2.get(a2) || 0)
          return c2;
        if (Yc2.length)
          c2 = Yc2.pop();
        else {
          try {
            Y2.grow(1);
          } catch (r2) {
            if (!(r2 instanceof RangeError))
              throw r2;
            throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
          }
          c2 = Y2.length - 1;
        }
        try {
          Y2.set(c2, a2);
        } catch (r2) {
          if (!(r2 instanceof TypeError))
            throw r2;
          if ("function" == typeof WebAssembly.Function) {
            d2 = WebAssembly.Function;
            e2 = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" };
            for (var h2 = { parameters: [], results: "v" == b2[0] ? [] : [e2[b2[0]]] }, k2 = 1; k2 < b2.length; ++k2)
              h2.parameters.push(e2[b2[k2]]);
            b2 = new d2(h2, a2);
          } else {
            d2 = [1];
            e2 = b2.slice(0, 1);
            b2 = b2.slice(1);
            h2 = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
            d2.push(96);
            k2 = b2.length;
            128 > k2 ? d2.push(k2) : d2.push(k2 % 128 | 128, k2 >> 7);
            for (k2 = 0; k2 < b2.length; ++k2)
              d2.push(h2[b2[k2]]);
            "v" == e2 ? d2.push(0) : d2.push(1, h2[e2]);
            b2 = [0, 97, 115, 109, 1, 0, 0, 0, 1];
            e2 = d2.length;
            128 > e2 ? b2.push(e2) : b2.push(e2 % 128 | 128, e2 >> 7);
            b2.push.apply(b2, d2);
            b2.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
            b2 = new WebAssembly.Module(new Uint8Array(b2));
            b2 = new WebAssembly.Instance(b2, { e: { f: a2 } }).exports.f;
          }
          Y2.set(c2, b2);
        }
        Xc2.set(a2, c2);
        return c2;
      };
      function Qb2(a2, b2, c2, d2) {
        a2 || (a2 = this);
        this.parent = a2;
        this.Ra = a2.Ra;
        this.Va = null;
        this.id = Kb2++;
        this.name = b2;
        this.mode = c2;
        this.Ga = {};
        this.Ha = {};
        this.rdev = d2;
      }
      Object.defineProperties(Qb2.prototype, { read: { get: function() {
        return 365 === (this.mode & 365);
      }, set: function(a2) {
        a2 ? this.mode |= 365 : this.mode &= -366;
      } }, write: { get: function() {
        return 146 === (this.mode & 146);
      }, set: function(a2) {
        a2 ? this.mode |= 146 : this.mode &= -147;
      } } });
      gc2();
      S2 = Array(4096);
      Xb2(Q2, "/");
      V2("/tmp");
      V2("/home");
      V2("/home/web_user");
      (function() {
        V2("/dev");
        xb2(259, { read: () => 0, write: (d2, e2, h2, k2) => k2 });
        Yb2("/dev/null", 259);
        wb2(1280, zb2);
        wb2(1536, Ab2);
        Yb2("/dev/tty", 1280);
        Yb2("/dev/tty1", 1536);
        var a2 = new Uint8Array(1024), b2 = 0, c2 = () => {
          0 === b2 && (b2 = kb2(a2).byteLength);
          return a2[--b2];
        };
        ic2("random", c2);
        ic2("urandom", c2);
        V2("/dev/shm");
        V2("/dev/shm/tmp");
      })();
      (function() {
        V2("/proc");
        var a2 = V2("/proc/self");
        V2("/proc/self/fd");
        Xb2({ Ra() {
          var b2 = Db2(a2, "fd", 16895, 73);
          b2.Ga = { lookup(c2, d2) {
            var e2 = U2(+d2);
            c2 = { parent: null, Ra: { tb: "fake" }, Ga: { readlink: () => e2.path } };
            return c2.parent = c2;
          } };
          return b2;
        } }, "/proc/self/fd");
      })();
      var $c2 = {
        a: (a2, b2, c2, d2) => {
          C2(`Assertion failed: ${a2 ? M2(q2, a2) : ""}, at: ` + [b2 ? b2 ? M2(q2, b2) : "" : "unknown filename", c2, d2 ? d2 ? M2(q2, d2) : "" : "unknown function"]);
        },
        h: function(a2, b2) {
          try {
            return a2 = a2 ? M2(q2, a2) : "", ka2(a2, b2), 0;
          } catch (c2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== c2.name)
              throw c2;
            return -c2.Ka;
          }
        },
        H: function(a2, b2, c2) {
          try {
            b2 = b2 ? M2(q2, b2) : "";
            b2 = kc2(a2, b2);
            if (c2 & -8)
              return -28;
            var d2 = T2(b2, { Sa: true }).node;
            if (!d2)
              return -44;
            a2 = "";
            c2 & 4 && (a2 += "r");
            c2 & 2 && (a2 += "w");
            c2 & 1 && (a2 += "x");
            return a2 && Pb2(d2, a2) ? -2 : 0;
          } catch (e2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== e2.name)
              throw e2;
            return -e2.Ka;
          }
        },
        i: function(a2, b2) {
          try {
            var c2 = U2(a2);
            ka2(c2.node, b2);
            return 0;
          } catch (d2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== d2.name)
              throw d2;
            return -d2.Ka;
          }
        },
        g: function(a2) {
          try {
            var b2 = U2(a2).node;
            var c2 = "string" == typeof b2 ? T2(b2, { Sa: true }).node : b2;
            if (!c2.Ga.Oa)
              throw new P2(63);
            c2.Ga.Oa(c2, { timestamp: Date.now() });
            return 0;
          } catch (d2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== d2.name)
              throw d2;
            return -d2.Ka;
          }
        },
        b: function(a2, b2, c2) {
          Mc2 = c2;
          try {
            var d2 = U2(a2);
            switch (b2) {
              case 0:
                var e2 = Oc2();
                if (0 > e2)
                  return -28;
                for (; Jb2[e2]; )
                  e2++;
                return Vb2(d2, e2).fd;
              case 1:
              case 2:
                return 0;
              case 3:
                return d2.flags;
              case 4:
                return e2 = Oc2(), d2.flags |= e2, 0;
              case 5:
                return e2 = Oc2(), Na2[e2 + 0 >> 1] = 2, 0;
              case 6:
              case 7:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                return D2[Zc2() >> 2] = 28, -1;
              default:
                return -28;
            }
          } catch (h2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== h2.name)
              throw h2;
            return -h2.Ka;
          }
        },
        f: function(a2, b2) {
          try {
            var c2 = U2(a2);
            return lc2(ac2, c2.path, b2);
          } catch (d2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== d2.name)
              throw d2;
            return -d2.Ka;
          }
        },
        n: function(a2, b2, c2) {
          b2 = Pc2(b2, c2);
          try {
            if (isNaN(b2))
              return 61;
            var d2 = U2(a2);
            if (0 === (d2.flags & 2097155))
              throw new P2(28);
            cc2(d2.node, b2);
            return 0;
          } catch (e2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== e2.name)
              throw e2;
            return -e2.Ka;
          }
        },
        C: function(a2, b2) {
          try {
            if (0 === b2)
              return -28;
            var c2 = da2("/") + 1;
            if (b2 < c2)
              return -68;
            fa2("/", q2, a2, b2);
            return c2;
          } catch (d2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== d2.name)
              throw d2;
            return -d2.Ka;
          }
        },
        F: function(a2, b2) {
          try {
            return a2 = a2 ? M2(q2, a2) : "", lc2(bc2, a2, b2);
          } catch (c2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== c2.name)
              throw c2;
            return -c2.Ka;
          }
        },
        z: function(a2, b2, c2) {
          try {
            return b2 = b2 ? M2(q2, b2) : "", b2 = kc2(a2, b2), b2 = u2(b2), "/" === b2[b2.length - 1] && (b2 = b2.substr(
              0,
              b2.length - 1
            )), V2(b2, c2), 0;
          } catch (d2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== d2.name)
              throw d2;
            return -d2.Ka;
          }
        },
        E: function(a2, b2, c2, d2) {
          try {
            b2 = b2 ? M2(q2, b2) : "";
            var e2 = d2 & 256;
            b2 = kc2(a2, b2, d2 & 4096);
            return lc2(e2 ? bc2 : ac2, b2, c2);
          } catch (h2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== h2.name)
              throw h2;
            return -h2.Ka;
          }
        },
        y: function(a2, b2, c2, d2) {
          Mc2 = d2;
          try {
            b2 = b2 ? M2(q2, b2) : "";
            b2 = kc2(a2, b2);
            var e2 = d2 ? Oc2() : 0;
            return la2(b2, c2, e2).fd;
          } catch (h2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== h2.name)
              throw h2;
            return -h2.Ka;
          }
        },
        w: function(a2, b2, c2, d2) {
          try {
            b2 = b2 ? M2(q2, b2) : "";
            b2 = kc2(a2, b2);
            if (0 >= d2)
              return -28;
            var e2 = Mb(b2), h2 = Math.min(d2, da2(e2)), k2 = p2[c2 + h2];
            fa2(e2, q2, c2, d2 + 1);
            p2[c2 + h2] = k2;
            return h2;
          } catch (r2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== r2.name)
              throw r2;
            return -r2.Ka;
          }
        },
        v: function(a2) {
          try {
            return a2 = a2 ? M2(q2, a2) : "", $b2(a2), 0;
          } catch (b2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== b2.name)
              throw b2;
            return -b2.Ka;
          }
        },
        G: function(a2, b2) {
          try {
            return a2 = a2 ? M2(q2, a2) : "", lc2(ac2, a2, b2);
          } catch (c2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== c2.name)
              throw c2;
            return -c2.Ka;
          }
        },
        r: function(a2, b2, c2) {
          try {
            return b2 = b2 ? M2(q2, b2) : "", b2 = kc2(a2, b2), 0 === c2 ? wa2(b2) : 512 === c2 ? $b2(b2) : C2("Invalid flags passed to unlinkat"), 0;
          } catch (d2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== d2.name)
              throw d2;
            return -d2.Ka;
          }
        },
        q: function(a2, b2, c2) {
          try {
            b2 = b2 ? M2(q2, b2) : "";
            b2 = kc2(a2, b2, true);
            if (c2) {
              var d2 = E2[c2 >> 2] + 4294967296 * D2[c2 + 4 >> 2], e2 = D2[c2 + 8 >> 2];
              h2 = 1e3 * d2 + e2 / 1e6;
              c2 += 16;
              d2 = E2[c2 >> 2] + 4294967296 * D2[c2 + 4 >> 2];
              e2 = D2[c2 + 8 >> 2];
              k2 = 1e3 * d2 + e2 / 1e6;
            } else
              var h2 = Date.now(), k2 = h2;
            a2 = h2;
            var r2 = T2(b2, { Sa: true }).node;
            r2.Ga.Oa(r2, { timestamp: Math.max(a2, k2) });
            return 0;
          } catch (y2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== y2.name)
              throw y2;
            return -y2.Ka;
          }
        },
        l: function(a2, b2, c2) {
          a2 = new Date(1e3 * Pc2(a2, b2));
          D2[c2 >> 2] = a2.getSeconds();
          D2[c2 + 4 >> 2] = a2.getMinutes();
          D2[c2 + 8 >> 2] = a2.getHours();
          D2[c2 + 12 >> 2] = a2.getDate();
          D2[c2 + 16 >> 2] = a2.getMonth();
          D2[c2 + 20 >> 2] = a2.getFullYear() - 1900;
          D2[c2 + 24 >> 2] = a2.getDay();
          b2 = a2.getFullYear();
          D2[c2 + 28 >> 2] = (0 !== b2 % 4 || 0 === b2 % 100 && 0 !== b2 % 400 ? Rc2 : Qc2)[a2.getMonth()] + a2.getDate() - 1 | 0;
          D2[c2 + 36 >> 2] = -(60 * a2.getTimezoneOffset());
          b2 = new Date(a2.getFullYear(), 6, 1).getTimezoneOffset();
          var d2 = new Date(a2.getFullYear(), 0, 1).getTimezoneOffset();
          D2[c2 + 32 >> 2] = (b2 != d2 && a2.getTimezoneOffset() == Math.min(d2, b2)) | 0;
        },
        j: function(a2, b2, c2, d2, e2, h2, k2, r2) {
          e2 = Pc2(e2, h2);
          try {
            if (isNaN(e2))
              return 61;
            var y2 = U2(d2);
            if (0 !== (b2 & 2) && 0 === (c2 & 2) && 2 !== (y2.flags & 2097155))
              throw new P2(2);
            if (1 === (y2.flags & 2097155))
              throw new P2(2);
            if (!y2.Ha.bb)
              throw new P2(43);
            var v2 = y2.Ha.bb(y2, a2, e2, b2, c2);
            var F2 = v2.Db;
            D2[k2 >> 2] = v2.ub;
            E2[r2 >> 2] = F2;
            return 0;
          } catch (H2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== H2.name)
              throw H2;
            return -H2.Ka;
          }
        },
        k: function(a2, b2, c2, d2, e2, h2, k2) {
          h2 = Pc2(h2, k2);
          try {
            if (isNaN(h2))
              return 61;
            var r2 = U2(e2);
            if (c2 & 2) {
              if (32768 !== (r2.node.mode & 61440))
                throw new P2(43);
              if (!(d2 & 2)) {
                var y2 = q2.slice(a2, a2 + b2);
                r2.Ha.cb && r2.Ha.cb(r2, y2, h2, b2, d2);
              }
            }
          } catch (v2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== v2.name)
              throw v2;
            return -v2.Ka;
          }
        },
        s: (a2, b2, c2) => {
          function d2(y2) {
            return (y2 = y2.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? y2[1] : "GMT";
          }
          var e2 = (/* @__PURE__ */ new Date()).getFullYear(), h2 = new Date(e2, 0, 1), k2 = new Date(e2, 6, 1);
          e2 = h2.getTimezoneOffset();
          var r2 = k2.getTimezoneOffset();
          E2[a2 >> 2] = 60 * Math.max(e2, r2);
          D2[b2 >> 2] = Number(e2 != r2);
          a2 = d2(h2);
          b2 = d2(k2);
          a2 = Sc2(a2);
          b2 = Sc2(b2);
          r2 < e2 ? (E2[c2 >> 2] = a2, E2[c2 + 4 >> 2] = b2) : (E2[c2 >> 2] = b2, E2[c2 + 4 >> 2] = a2);
        },
        d: () => Date.now(),
        t: () => 2147483648,
        c: () => performance.now(),
        o: (a2) => {
          var b2 = q2.length;
          a2 >>>= 0;
          if (2147483648 < a2)
            return false;
          for (var c2 = 1; 4 >= c2; c2 *= 2) {
            var d2 = b2 * (1 + 0.2 / c2);
            d2 = Math.min(d2, a2 + 100663296);
            var e2 = Math;
            d2 = Math.max(a2, d2);
            a: {
              e2 = (e2.min.call(e2, 2147483648, d2 + (65536 - d2 % 65536) % 65536) - La2.buffer.byteLength + 65535) / 65536;
              try {
                La2.grow(e2);
                Qa2();
                var h2 = 1;
                break a;
              } catch (k2) {
              }
              h2 = void 0;
            }
            if (h2)
              return true;
          }
          return false;
        },
        A: (a2, b2) => {
          var c2 = 0;
          Vc2().forEach((d2, e2) => {
            var h2 = b2 + c2;
            e2 = E2[a2 + 4 * e2 >> 2] = h2;
            for (h2 = 0; h2 < d2.length; ++h2)
              p2[e2++ >> 0] = d2.charCodeAt(h2);
            p2[e2 >> 0] = 0;
            c2 += d2.length + 1;
          });
          return 0;
        },
        B: (a2, b2) => {
          var c2 = Vc2();
          E2[a2 >> 2] = c2.length;
          var d2 = 0;
          c2.forEach((e2) => d2 += e2.length + 1);
          E2[b2 >> 2] = d2;
          return 0;
        },
        e: function(a2) {
          try {
            var b2 = U2(a2);
            na(b2);
            return 0;
          } catch (c2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== c2.name)
              throw c2;
            return c2.Ka;
          }
        },
        p: function(a2, b2) {
          try {
            var c2 = U2(a2);
            p2[b2 >> 0] = c2.tty ? 2 : R2(c2.mode) ? 3 : 40960 === (c2.mode & 61440) ? 7 : 4;
            Na2[b2 + 2 >> 1] = 0;
            J2 = [0, (I2 = 0, 1 <= +Math.abs(I2) ? 0 < I2 ? +Math.floor(I2 / 4294967296) >>> 0 : ~~+Math.ceil((I2 - +(~~I2 >>> 0)) / 4294967296) >>> 0 : 0)];
            D2[b2 + 8 >> 2] = J2[0];
            D2[b2 + 12 >> 2] = J2[1];
            J2 = [0, (I2 = 0, 1 <= +Math.abs(I2) ? 0 < I2 ? +Math.floor(I2 / 4294967296) >>> 0 : ~~+Math.ceil((I2 - +(~~I2 >>> 0)) / 4294967296) >>> 0 : 0)];
            D2[b2 + 16 >> 2] = J2[0];
            D2[b2 + 20 >> 2] = J2[1];
            return 0;
          } catch (d2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== d2.name)
              throw d2;
            return d2.Ka;
          }
        },
        x: function(a2, b2, c2, d2) {
          try {
            a: {
              var e2 = U2(a2);
              a2 = b2;
              for (var h2, k2 = b2 = 0; k2 < c2; k2++) {
                var r2 = E2[a2 >> 2], y2 = E2[a2 + 4 >> 2];
                a2 += 8;
                var v2 = fc2(e2, p2, r2, y2, h2);
                if (0 > v2) {
                  var F2 = -1;
                  break a;
                }
                b2 += v2;
                if (v2 < y2)
                  break;
                "undefined" !== typeof h2 && (h2 += v2);
              }
              F2 = b2;
            }
            E2[d2 >> 2] = F2;
            return 0;
          } catch (H2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== H2.name)
              throw H2;
            return H2.Ka;
          }
        },
        m: function(a2, b2, c2, d2, e2) {
          b2 = Pc2(b2, c2);
          try {
            if (isNaN(b2))
              return 61;
            var h2 = U2(a2);
            ec2(h2, b2, d2);
            J2 = [h2.position >>> 0, (I2 = h2.position, 1 <= +Math.abs(I2) ? 0 < I2 ? +Math.floor(I2 / 4294967296) >>> 0 : ~~+Math.ceil((I2 - +(~~I2 >>> 0)) / 4294967296) >>> 0 : 0)];
            D2[e2 >> 2] = J2[0];
            D2[e2 + 4 >> 2] = J2[1];
            h2.hb && 0 === b2 && 0 === d2 && (h2.hb = null);
            return 0;
          } catch (k2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== k2.name)
              throw k2;
            return k2.Ka;
          }
        },
        D: function(a2) {
          var _a;
          try {
            var b2 = U2(a2);
            return ((_a = b2.Ha) == null ? void 0 : _a.fsync) ? b2.Ha.fsync(b2) : 0;
          } catch (c2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== c2.name)
              throw c2;
            return c2.Ka;
          }
        },
        u: function(a2, b2, c2, d2) {
          try {
            a: {
              var e2 = U2(a2);
              a2 = b2;
              for (var h2, k2 = b2 = 0; k2 < c2; k2++) {
                var r2 = E2[a2 >> 2], y2 = E2[a2 + 4 >> 2];
                a2 += 8;
                var v2 = ma2(e2, p2, r2, y2, h2);
                if (0 > v2) {
                  var F2 = -1;
                  break a;
                }
                b2 += v2;
                "undefined" !== typeof h2 && (h2 += v2);
              }
              F2 = b2;
            }
            E2[d2 >> 2] = F2;
            return 0;
          } catch (H2) {
            if ("undefined" == typeof W2 || "ErrnoError" !== H2.name)
              throw H2;
            return H2.Ka;
          }
        }
      }, Z2 = function() {
        var _a;
        function a2(c2) {
          var _a2;
          Z2 = c2.exports;
          La2 = Z2.I;
          Qa2();
          Y2 = Z2.Aa;
          Sa2.unshift(Z2.J);
          G2--;
          (_a2 = f2.monitorRunDependencies) == null ? void 0 : _a2.call(f2, G2);
          0 == G2 && (Xa2 && (c2 = Xa2, Xa2 = null, c2()));
          return Z2;
        }
        var b2 = { a: $c2 };
        G2++;
        (_a = f2.monitorRunDependencies) == null ? void 0 : _a.call(f2, G2);
        if (f2.instantiateWasm)
          try {
            return f2.instantiateWasm(b2, a2);
          } catch (c2) {
            return B2(`Module.instantiateWasm callback failed with error: ${c2}`), false;
          }
        db2(b2, function(c2) {
          a2(c2.instance);
        });
        return {};
      }();
      f2._sqlite3_free = (a2) => (f2._sqlite3_free = Z2.K)(a2);
      f2._sqlite3_value_text = (a2) => (f2._sqlite3_value_text = Z2.L)(a2);
      var Zc2 = () => (Zc2 = Z2.M)();
      f2._sqlite3_prepare_v2 = (a2, b2, c2, d2, e2) => (f2._sqlite3_prepare_v2 = Z2.N)(a2, b2, c2, d2, e2);
      f2._sqlite3_step = (a2) => (f2._sqlite3_step = Z2.O)(a2);
      f2._sqlite3_finalize = (a2) => (f2._sqlite3_finalize = Z2.P)(a2);
      f2._sqlite3_reset = (a2) => (f2._sqlite3_reset = Z2.Q)(a2);
      f2._sqlite3_clear_bindings = (a2) => (f2._sqlite3_clear_bindings = Z2.R)(a2);
      f2._sqlite3_value_blob = (a2) => (f2._sqlite3_value_blob = Z2.S)(a2);
      f2._sqlite3_value_bytes = (a2) => (f2._sqlite3_value_bytes = Z2.T)(a2);
      f2._sqlite3_value_double = (a2) => (f2._sqlite3_value_double = Z2.U)(a2);
      f2._sqlite3_value_int = (a2) => (f2._sqlite3_value_int = Z2.V)(a2);
      f2._sqlite3_value_type = (a2) => (f2._sqlite3_value_type = Z2.W)(a2);
      f2._sqlite3_result_blob = (a2, b2, c2, d2) => (f2._sqlite3_result_blob = Z2.X)(a2, b2, c2, d2);
      f2._sqlite3_result_double = (a2, b2) => (f2._sqlite3_result_double = Z2.Y)(a2, b2);
      f2._sqlite3_result_error = (a2, b2, c2) => (f2._sqlite3_result_error = Z2.Z)(a2, b2, c2);
      f2._sqlite3_result_int = (a2, b2) => (f2._sqlite3_result_int = Z2._)(a2, b2);
      f2._sqlite3_result_int64 = (a2, b2, c2) => (f2._sqlite3_result_int64 = Z2.$)(a2, b2, c2);
      f2._sqlite3_result_null = (a2) => (f2._sqlite3_result_null = Z2.aa)(a2);
      f2._sqlite3_result_text = (a2, b2, c2, d2) => (f2._sqlite3_result_text = Z2.ba)(a2, b2, c2, d2);
      f2._sqlite3_aggregate_context = (a2, b2) => (f2._sqlite3_aggregate_context = Z2.ca)(a2, b2);
      f2._sqlite3_column_count = (a2) => (f2._sqlite3_column_count = Z2.da)(a2);
      f2._sqlite3_data_count = (a2) => (f2._sqlite3_data_count = Z2.ea)(a2);
      f2._sqlite3_column_blob = (a2, b2) => (f2._sqlite3_column_blob = Z2.fa)(a2, b2);
      f2._sqlite3_column_bytes = (a2, b2) => (f2._sqlite3_column_bytes = Z2.ga)(a2, b2);
      f2._sqlite3_column_double = (a2, b2) => (f2._sqlite3_column_double = Z2.ha)(a2, b2);
      f2._sqlite3_column_text = (a2, b2) => (f2._sqlite3_column_text = Z2.ia)(a2, b2);
      f2._sqlite3_column_type = (a2, b2) => (f2._sqlite3_column_type = Z2.ja)(a2, b2);
      f2._sqlite3_column_name = (a2, b2) => (f2._sqlite3_column_name = Z2.ka)(a2, b2);
      f2._sqlite3_bind_blob = (a2, b2, c2, d2, e2) => (f2._sqlite3_bind_blob = Z2.la)(a2, b2, c2, d2, e2);
      f2._sqlite3_bind_double = (a2, b2, c2) => (f2._sqlite3_bind_double = Z2.ma)(a2, b2, c2);
      f2._sqlite3_bind_int = (a2, b2, c2) => (f2._sqlite3_bind_int = Z2.na)(a2, b2, c2);
      f2._sqlite3_bind_text = (a2, b2, c2, d2, e2) => (f2._sqlite3_bind_text = Z2.oa)(a2, b2, c2, d2, e2);
      f2._sqlite3_bind_parameter_index = (a2, b2) => (f2._sqlite3_bind_parameter_index = Z2.pa)(a2, b2);
      f2._sqlite3_sql = (a2) => (f2._sqlite3_sql = Z2.qa)(a2);
      f2._sqlite3_normalized_sql = (a2) => (f2._sqlite3_normalized_sql = Z2.ra)(a2);
      f2._sqlite3_errmsg = (a2) => (f2._sqlite3_errmsg = Z2.sa)(a2);
      f2._sqlite3_exec = (a2, b2, c2, d2, e2) => (f2._sqlite3_exec = Z2.ta)(a2, b2, c2, d2, e2);
      f2._sqlite3_changes = (a2) => (f2._sqlite3_changes = Z2.ua)(a2);
      f2._sqlite3_close_v2 = (a2) => (f2._sqlite3_close_v2 = Z2.va)(a2);
      f2._sqlite3_create_function_v2 = (a2, b2, c2, d2, e2, h2, k2, r2, y2) => (f2._sqlite3_create_function_v2 = Z2.wa)(a2, b2, c2, d2, e2, h2, k2, r2, y2);
      f2._sqlite3_open = (a2, b2) => (f2._sqlite3_open = Z2.xa)(a2, b2);
      var ea2 = f2._malloc = (a2) => (ea2 = f2._malloc = Z2.ya)(a2), ca2 = f2._free = (a2) => (ca2 = f2._free = Z2.za)(a2);
      f2._RegisterExtensionFunctions = (a2) => (f2._RegisterExtensionFunctions = Z2.Ba)(a2);
      var Gb2 = (a2, b2) => (Gb2 = Z2.Ca)(a2, b2), pa2 = () => (pa2 = Z2.Da)(), sa2 = (a2) => (sa2 = Z2.Ea)(a2), x2 = (a2) => (x2 = Z2.Fa)(a2);
      f2.stackAlloc = x2;
      f2.stackSave = pa2;
      f2.stackRestore = sa2;
      f2.cwrap = (a2, b2, c2, d2) => {
        var e2 = !c2 || c2.every((h2) => "number" === h2 || "boolean" === h2);
        return "string" !== b2 && e2 && !d2 ? f2["_" + a2] : function() {
          return Wc2(a2, b2, c2, arguments);
        };
      };
      f2.addFunction = xa;
      f2.removeFunction = ua2;
      f2.UTF8ToString = ra2;
      f2.ALLOC_NORMAL = ba;
      f2.allocate = aa2;
      f2.allocateUTF8OnStack = ta2;
      var ad2;
      Xa2 = function bd2() {
        ad2 || cd2();
        ad2 || (Xa2 = bd2);
      };
      function cd2() {
        function a2() {
          if (!ad2 && (ad2 = true, f2.calledRun = true, !Ma2)) {
            f2.noFSInit || hc2 || (hc2 = true, gc2(), f2.stdin = f2.stdin, f2.stdout = f2.stdout, f2.stderr = f2.stderr, f2.stdin ? ic2("stdin", f2.stdin) : Zb2("/dev/tty", "/dev/stdin"), f2.stdout ? ic2("stdout", null, f2.stdout) : Zb2("/dev/tty", "/dev/stdout"), f2.stderr ? ic2("stderr", null, f2.stderr) : Zb2("/dev/tty1", "/dev/stderr"), la2("/dev/stdin", 0), la2("/dev/stdout", 1), la2("/dev/stderr", 1));
            Lb2 = false;
            eb2(Sa2);
            if (f2.onRuntimeInitialized)
              f2.onRuntimeInitialized();
            if (f2.postRun)
              for ("function" == typeof f2.postRun && (f2.postRun = [f2.postRun]); f2.postRun.length; ) {
                var b2 = f2.postRun.shift();
                Ta2.unshift(b2);
              }
            eb2(Ta2);
          }
        }
        if (!(0 < G2)) {
          if (f2.preRun)
            for ("function" == typeof f2.preRun && (f2.preRun = [f2.preRun]); f2.preRun.length; )
              Va2();
          eb2(Ra2);
          0 < G2 || (f2.setStatus ? (f2.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              f2.setStatus("");
            }, 1);
            a2();
          }, 1)) : a2());
        }
      }
      if (f2.preInit)
        for ("function" == typeof f2.preInit && (f2.preInit = [f2.preInit]); 0 < f2.preInit.length; )
          f2.preInit.pop()();
      cd2();
      return Module;
    });
    return initSqlJsPromise;
  };
  {
    module.exports = initSqlJs2;
    module.exports.default = initSqlJs2;
  }
})(sqlWasm);
const initSqlJs = sqlWasm.exports;
class UtilsStore {
  static async getDBFromStore(dbName, store) {
    try {
      const retDb = await store.getItem(dbName);
      return Promise.resolve(retDb);
    } catch (err) {
      return Promise.reject(`GetDBFromStore: ${err.message}`);
    }
  }
  static async setInitialDBToStore(dbName, store) {
    try {
      const data = null;
      await store.setItem(dbName, data);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`SetInitialDBToStore: ${err.message}`);
    }
  }
  static async setDBToStore(mDb, dbName, store) {
    try {
      const data = mDb.export();
      await UtilsStore.saveDBToStore(dbName, data, store);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`SetDBToStore: ${err.message}`);
    }
  }
  static async saveDBToStore(dbName, data, store) {
    try {
      await store.setItem(dbName, data);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`SaveDBToStore: ${err.message}`);
    }
  }
  static async removeDBFromStore(dbName, store) {
    try {
      await store.removeItem(dbName);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`RemoveDBFromStore: ${err.message}`);
    }
  }
  static async isDBInStore(dbName, store) {
    try {
      const retDb = await store.getItem(dbName);
      if (retDb != null && retDb.length > 0) {
        return Promise.resolve(true);
      } else {
        return Promise.resolve(false);
      }
    } catch (err) {
      return Promise.reject(`IsDBInStore: ${err}`);
    }
  }
  static async restoreDBFromStore(dbName, prefix, store) {
    const mFileName = `${prefix}-${dbName}`;
    try {
      const isFilePre = await UtilsStore.isDBInStore(mFileName, store);
      if (isFilePre) {
        const isFile = await UtilsStore.isDBInStore(dbName, store);
        if (isFile) {
          const retDb = await UtilsStore.getDBFromStore(mFileName, store);
          await UtilsStore.saveDBToStore(dbName, retDb, store);
          await UtilsStore.removeDBFromStore(mFileName, store);
          return Promise.resolve();
        } else {
          return Promise.reject(new Error(`RestoreDBFromStore: ${dbName} does not exist`));
        }
      } else {
        return Promise.reject(new Error(`RestoreDBFromStore: ${mFileName} does not exist`));
      }
    } catch (err) {
      return Promise.reject(`RestoreDBFromStore: ${err.message}`);
    }
  }
  static async copyDBToStore(dbName, toDb, store) {
    try {
      const isFile = await UtilsStore.isDBInStore(dbName, store);
      if (isFile) {
        const retDb = await UtilsStore.getDBFromStore(dbName, store);
        await UtilsStore.saveDBToStore(toDb, retDb, store);
        return Promise.resolve();
      } else {
        return Promise.reject(new Error(`CopyDBToStore: ${dbName} does not exist`));
      }
    } catch (err) {
      return Promise.reject(`CopyDBToStore: ${err.message}`);
    }
  }
  static async getDBListFromStore(store) {
    try {
      const retDbList = await store.keys();
      return Promise.resolve(retDbList);
    } catch (err) {
      return Promise.reject(`GetDBListFromStore: ${err.message}`);
    }
  }
}
class UtilsDrop {
  static async getTablesNames(db2) {
    let sql = "SELECT name FROM sqlite_master WHERE ";
    sql += "type='table' AND name NOT LIKE 'sync_table' ";
    sql += "AND name NOT LIKE '_temp_%' ";
    sql += "AND name NOT LIKE 'sqlite_%' ";
    sql += "ORDER BY rootpage DESC;";
    const retArr = [];
    try {
      const retQuery = await UtilsSQLite.queryAll(db2, sql, []);
      for (const query of retQuery) {
        retArr.push(query.name);
      }
      return Promise.resolve(retArr);
    } catch (err) {
      return Promise.reject(new Error(`GetTablesNames: ${err.message}`));
    }
  }
  static async getViewsNames(mDb) {
    let sql = "SELECT name FROM sqlite_master WHERE ";
    sql += "type='view' AND name NOT LIKE 'sqlite_%' ";
    sql += "ORDER BY rootpage DESC;";
    const retArr = [];
    try {
      const retQuery = await UtilsSQLite.queryAll(mDb, sql, []);
      for (const query of retQuery) {
        retArr.push(query.name);
      }
      return Promise.resolve(retArr);
    } catch (err) {
      return Promise.reject(new Error(`getViewsNames: ${err.message}`));
    }
  }
  static async dropElements(db2, type) {
    let msg = "";
    let stmt1 = `AND name NOT LIKE ('sqlite_%')`;
    switch (type) {
      case "index":
        msg = "DropIndexes";
        break;
      case "trigger":
        msg = "DropTriggers";
        break;
      case "table":
        msg = "DropTables";
        stmt1 += ` AND name NOT IN ('sync_table')`;
        break;
      case "view":
        msg = "DropViews";
        break;
      default:
        return Promise.reject(new Error(`DropElements: ${type} not found`));
    }
    let stmt = "SELECT name FROM sqlite_master WHERE ";
    stmt += `type = '${type}' ${stmt1};`;
    try {
      const elements = await UtilsSQLite.queryAll(db2, stmt, []);
      if (elements.length > 0) {
        const upType = type.toUpperCase();
        const statements = [];
        for (const elem of elements) {
          let stmt2 = `DROP ${upType} IF EXISTS `;
          stmt2 += `${elem.name};`;
          statements.push(stmt2);
        }
        for (const stmt2 of statements) {
          const lastId2 = await UtilsSQLite.run(db2, stmt2, [], false, "no");
          if (lastId2 < 0) {
            return Promise.reject(new Error(`DropElements: ${msg}: lastId < 0`));
          }
        }
      }
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`DropElements: ${msg}: ${err.message}`));
    }
  }
  static async dropAll(db2) {
    try {
      await UtilsDrop.dropElements(db2, "table");
      await UtilsDrop.dropElements(db2, "index");
      await UtilsDrop.dropElements(db2, "trigger");
      await UtilsDrop.dropElements(db2, "view");
      await UtilsSQLite.run(db2, "VACUUM;", [], false, "no");
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`DropAll: ${err.message}`));
    }
  }
  static async dropTempTables(db2, alterTables) {
    const tempTables = Object.keys(alterTables);
    const statements = [];
    for (const tTable of tempTables) {
      let stmt = "DROP TABLE IF EXISTS ";
      stmt += `_temp_${tTable};`;
      statements.push(stmt);
    }
    try {
      const changes = await UtilsSQLite.execute(db2, statements.join("\n"), false);
      if (changes < 0) {
        return Promise.reject(new Error("DropTempTables: changes < 0"));
      }
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`DropTempTables: ${err.message}`));
    }
  }
}
class UtilsJSON {
  static async isJsonSQLite(obj) {
    const keyFirstLevel = [
      "database",
      "version",
      "overwrite",
      "encrypted",
      "mode",
      "tables",
      "views"
    ];
    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object)
      return false;
    for (const key of Object.keys(obj)) {
      if (keyFirstLevel.indexOf(key) === -1)
        return false;
      if (key === "database" && typeof obj[key] != "string")
        return false;
      if (key === "version" && typeof obj[key] != "number")
        return false;
      if (key === "overwrite" && typeof obj[key] != "boolean")
        return false;
      if (key === "encrypted" && typeof obj[key] != "boolean")
        return false;
      if (key === "mode" && typeof obj[key] != "string")
        return false;
      if (key === "tables" && typeof obj[key] != "object")
        return false;
      if (key === "tables") {
        for (const oKey of obj[key]) {
          const retTable = await UtilsJSON.isTable(oKey);
          if (!retTable)
            return false;
        }
      }
      if (key === "views" && typeof obj[key] != "object")
        return false;
      if (key === "views") {
        for (const oKey of obj[key]) {
          const retView = await UtilsJSON.isView(oKey);
          if (!retView)
            return false;
        }
      }
    }
    return true;
  }
  static async isTable(obj) {
    const keyTableLevel = [
      "name",
      "schema",
      "indexes",
      "triggers",
      "values"
    ];
    let nbColumn = 0;
    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object)
      return false;
    for (const key of Object.keys(obj)) {
      if (keyTableLevel.indexOf(key) === -1)
        return false;
      if (key === "name" && typeof obj[key] != "string")
        return false;
      if (key === "schema" && typeof obj[key] != "object")
        return false;
      if (key === "indexes" && typeof obj[key] != "object")
        return false;
      if (key === "triggers" && typeof obj[key] != "object")
        return false;
      if (key === "values" && typeof obj[key] != "object")
        return false;
      if (key === "schema") {
        obj["schema"].forEach((element) => {
          if (element.column) {
            nbColumn++;
          }
        });
        for (let i = 0; i < nbColumn; i++) {
          const retSchema = await UtilsJSON.isSchema(obj[key][i]);
          if (!retSchema)
            return false;
        }
      }
      if (key === "indexes") {
        for (const oKey of obj[key]) {
          const retIndexes = await UtilsJSON.isIndexes(oKey);
          if (!retIndexes)
            return false;
        }
      }
      if (key === "triggers") {
        for (const oKey of obj[key]) {
          const retTriggers = await UtilsJSON.isTriggers(oKey);
          if (!retTriggers)
            return false;
        }
      }
      if (key === "values") {
        if (nbColumn > 0) {
          for (const oKey of obj[key]) {
            if (typeof oKey != "object" || oKey.length != nbColumn)
              return false;
          }
        }
      }
    }
    return true;
  }
  static async isSchema(obj) {
    const keySchemaLevel = [
      "column",
      "value",
      "foreignkey",
      "primarykey",
      "constraint"
    ];
    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object)
      return false;
    for (const key of Object.keys(obj)) {
      if (keySchemaLevel.indexOf(key) === -1)
        return false;
      if (key === "column" && typeof obj[key] != "string")
        return false;
      if (key === "value" && typeof obj[key] != "string")
        return false;
      if (key === "foreignkey" && typeof obj[key] != "string")
        return false;
      if (key === "primarykey" && typeof obj[key] != "string")
        return false;
      if (key === "constraint" && typeof obj[key] != "string")
        return false;
    }
    return true;
  }
  static async isIndexes(obj) {
    const keyIndexesLevel = ["name", "value", "mode"];
    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object)
      return false;
    for (const key of Object.keys(obj)) {
      if (keyIndexesLevel.indexOf(key) === -1)
        return false;
      if (key === "name" && typeof obj[key] != "string")
        return false;
      if (key === "value" && typeof obj[key] != "string")
        return false;
      if (key === "mode" && (typeof obj[key] != "string" || obj[key].toUpperCase() != "UNIQUE"))
        return false;
    }
    return true;
  }
  static async isTriggers(obj) {
    const keyTriggersLevel = [
      "name",
      "timeevent",
      "condition",
      "logic"
    ];
    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object)
      return false;
    for (const key of Object.keys(obj)) {
      if (keyTriggersLevel.indexOf(key) === -1)
        return false;
      if (key === "name" && typeof obj[key] != "string")
        return false;
      if (key === "timeevent" && typeof obj[key] != "string")
        return false;
      if (key === "condition" && typeof obj[key] != "string")
        return false;
      if (key === "logic" && typeof obj[key] != "string")
        return false;
    }
    return true;
  }
  static async isView(obj) {
    const keyViewLevel = ["name", "value"];
    if (obj == null || Object.keys(obj).length === 0 && obj.constructor === Object)
      return false;
    for (const key of Object.keys(obj)) {
      if (keyViewLevel.indexOf(key) === -1)
        return false;
      if (key === "name" && typeof obj[key] != "string")
        return false;
      if (key === "value" && typeof obj[key] != "string")
        return false;
    }
    return true;
  }
  static async checkSchemaValidity(schema) {
    for (let i = 0; i < schema.length; i++) {
      const sch = {};
      const keys = Object.keys(schema[i]);
      if (keys.includes("column")) {
        sch.column = schema[i].column;
      }
      if (keys.includes("value")) {
        sch.value = schema[i].value;
      }
      if (keys.includes("foreignkey")) {
        sch.foreignkey = schema[i].foreignkey;
      }
      if (keys.includes("constraint")) {
        sch.constraint = schema[i].constraint;
      }
      const isValid2 = await UtilsJSON.isSchema(sch);
      if (!isValid2) {
        return Promise.reject(new Error(`CheckSchemaValidity: schema[${i}] not valid`));
      }
    }
    return Promise.resolve();
  }
  static async checkIndexesValidity(indexes) {
    for (let i = 0; i < indexes.length; i++) {
      const index = {};
      const keys = Object.keys(indexes[i]);
      if (keys.includes("value")) {
        index.value = indexes[i].value;
      }
      if (keys.includes("name")) {
        index.name = indexes[i].name;
      }
      if (keys.includes("mode")) {
        index.mode = indexes[i].mode;
      }
      const isValid2 = await UtilsJSON.isIndexes(index);
      if (!isValid2) {
        return Promise.reject(new Error(`CheckIndexesValidity: indexes[${i}] not valid`));
      }
    }
    return Promise.resolve();
  }
  static async checkTriggersValidity(triggers) {
    for (let i = 0; i < triggers.length; i++) {
      const trigger = {};
      const keys = Object.keys(triggers[i]);
      if (keys.includes("logic")) {
        trigger.logic = triggers[i].logic;
      }
      if (keys.includes("name")) {
        trigger.name = triggers[i].name;
      }
      if (keys.includes("timeevent")) {
        trigger.timeevent = triggers[i].timeevent;
      }
      if (keys.includes("condition")) {
        trigger.condition = triggers[i].condition;
      }
      const isValid2 = await UtilsJSON.isTriggers(trigger);
      if (!isValid2) {
        return Promise.reject(new Error(`CheckTriggersValidity: triggers[${i}] not valid`));
      }
    }
    return Promise.resolve();
  }
  static async checkViewsValidity(views) {
    for (let i = 0; i < views.length; i++) {
      const view = {};
      const keys = Object.keys(views[i]);
      if (keys.includes("value")) {
        view.value = views[i].value;
      }
      if (keys.includes("name")) {
        view.name = views[i].name;
      }
      const isValid2 = await UtilsJSON.isView(view);
      if (!isValid2) {
        return Promise.reject(new Error(`CheckViewsValidity: views[${i}] not valid`));
      }
    }
    return Promise.resolve();
  }
  static async getTableColumnNamesTypes(db2, tableName) {
    let resQuery = [];
    const retNames = [];
    const retTypes = [];
    const query = `PRAGMA table_info('${tableName}');`;
    try {
      resQuery = await UtilsSQLite.queryAll(db2, query, []);
      if (resQuery.length > 0) {
        for (const query2 of resQuery) {
          retNames.push(query2.name);
          retTypes.push(query2.type);
        }
      }
      return Promise.resolve({ names: retNames, types: retTypes });
    } catch (err) {
      return Promise.reject(new Error(`GetTableColumnNamesTypes: ${err.message}`));
    }
  }
  static async getValues(db2, query, tableName) {
    const values = [];
    try {
      const tableNamesTypes = await UtilsJSON.getTableColumnNamesTypes(db2, tableName);
      let rowNames = [];
      if (Object.keys(tableNamesTypes).includes("names")) {
        rowNames = tableNamesTypes.names;
      } else {
        return Promise.reject(new Error(`GetValues: Table ${tableName} no names`));
      }
      const retValues = await UtilsSQLite.queryAll(db2, query, []);
      for (const rValue of retValues) {
        const row = [];
        for (const rName of rowNames) {
          if (Object.keys(rValue).includes(rName)) {
            row.push(rValue[rName]);
          } else {
            row.push(null);
          }
        }
        values.push(row);
      }
      return Promise.resolve(values);
    } catch (err) {
      return Promise.reject(new Error(`GetValues: ${err.message}`));
    }
  }
}
class UtilsSQLStatement {
  static extractTableName(statement) {
    const pattern = /(?:INSERT\s+INTO|UPDATE|DELETE\s+FROM)\s+([^\s]+)/i;
    const match = statement.match(pattern);
    if (match && match[1]) {
      const tableName = match[1];
      return tableName;
    }
    return null;
  }
  static extractWhereClause(statement) {
    const pattern = /WHERE(.+?)(?:ORDER\s+BY|LIMIT|$)/i;
    const match = statement.match(pattern);
    if (match && match[1]) {
      const whereClause = match[1].trim();
      return whereClause;
    }
    return null;
  }
  static addPrefixToWhereClause(whereClause, colNames, refNames, prefix) {
    let columnValuePairs;
    if (whereClause.includes("AND")) {
      const subSequenceArray = whereClause.split("AND");
      columnValuePairs = subSequenceArray.map((pair) => pair.trim());
    } else {
      columnValuePairs = [whereClause];
    }
    const modifiedPairs = columnValuePairs.map((pair) => {
      const match = pair.match(/(\w+)\s*(=|<|<=|<>|>|>=|IN|BETWEEN|LIKE)\s*(.+)/);
      if (!match) {
        return pair;
      }
      const column = match[1].trim();
      const operator = match[2].trim();
      let value = match[3].trim();
      let newColumn = column;
      const index = UtilsSQLStatement.findIndexOfStringInArray(column, refNames);
      if (index !== -1) {
        newColumn = UtilsSQLStatement.getStringAtIndex(colNames, index);
      }
      const modifiedColumn = `${prefix}${newColumn}`;
      const ret = `${modifiedColumn} ${operator} ${value}`;
      return ret;
    });
    return modifiedPairs.join(" AND ");
  }
  static findIndexOfStringInArray(target, array) {
    return array.indexOf(target);
  }
  static getStringAtIndex(array, index) {
    if (index >= 0 && index < array.length) {
      return array[index];
    } else {
      return void 0;
    }
  }
  static extractForeignKeyInfo(sqlStatement) {
    const foreignKeyPattern = /\bFOREIGN\s+KEY\s*\(([^)]+)\)\s+REFERENCES\s+(\w+)\s*\(([^)]+)\)\s+(ON\s+DELETE\s+(RESTRICT|CASCADE|SET\s+NULL|SET\s+DEFAULT|NO\s+ACTION))?/;
    const matches2 = sqlStatement.match(foreignKeyPattern);
    if (matches2) {
      const foreignKeyInfo = {
        forKeys: matches2[1].split(",").map((key) => key.trim()),
        tableName: matches2[2],
        refKeys: matches2[3].split(",").map((key) => key.trim()),
        action: matches2[5] ? matches2[5] : "NO ACTION"
      };
      return foreignKeyInfo;
    } else {
      throw new Error("extractForeignKeyInfo: No FOREIGN KEY found");
    }
  }
  static extractColumnNames(whereClause) {
    const keywords = /* @__PURE__ */ new Set([
      "AND",
      "OR",
      "IN",
      "VALUES",
      "LIKE",
      "BETWEEN",
      "NOT"
    ]);
    const regex = /\b[a-zA-Z]\w*\b(?=\s*(?:<=?|>=?|<>?|=|AND|OR|BETWEEN|NOT|IN|LIKE))|\b[a-zA-Z]\w*\b\s+BETWEEN\s+'[^']+'\s+AND\s+'[^']+'|\(([^)]+)\)\s+IN\s+\(?\s*VALUES\s*\(/g;
    let match;
    const columns = [];
    while ((match = regex.exec(whereClause)) !== null) {
      const columnList = match[1];
      if (columnList) {
        const columnNamesArray = columnList.split(",");
        for (const columnName of columnNamesArray) {
          columns.push(columnName.trim());
        }
      } else {
        const matchedText = match[0];
        if (!keywords.has(matchedText.trim().toUpperCase())) {
          columns.push(matchedText.trim());
        }
      }
    }
    return columns;
  }
  static flattenMultilineString(input) {
    const lines = input.split(/\r?\n/);
    return lines.join(" ");
  }
  static getStmtAndRetColNames(sqlStmt, retMode) {
    const retWord = "RETURNING";
    const retStmtNames = { stmt: sqlStmt, names: "" };
    const retWordIndex = sqlStmt.toUpperCase().indexOf(retWord);
    if (retWordIndex !== -1) {
      const prefix = sqlStmt.substring(0, retWordIndex);
      retStmtNames.stmt = `${prefix};`;
      if (retMode.substring(0, 2) === "wA") {
        const suffix = sqlStmt.substring(retWordIndex + retWord.length);
        const names = suffix.trim();
        if (names.endsWith(";")) {
          retStmtNames.names = names.substring(0, names.length - 1);
        } else {
          retStmtNames.names = names;
        }
      }
    }
    return retStmtNames;
  }
  static extractCombinedPrimaryKey(whereClause) {
    const pattern = /WHERE\s*\((.+?)\)\s*(?:=|IN)\s*\((.+?)\)/g;
    const regex = new RegExp(pattern);
    const matches2 = whereClause.matchAll(regex);
    const primaryKeySets = [];
    for (const match of matches2) {
      const keysString = match[1].trim();
      const keys = keysString.split(",").map((key) => key.trim());
      primaryKeySets.push(keys);
    }
    return primaryKeySets.length === 0 ? null : primaryKeySets;
  }
  static getWhereStmtForCombinedPK(whStmt, withRefs, colNames, keys) {
    let retWhere = whStmt;
    for (const grpKeys of keys) {
      const repKeys = grpKeys.join(",") === withRefs.join(",") ? colNames : withRefs;
      for (const [index, key] of grpKeys.entries()) {
        retWhere = UtilsSQLStatement.replaceAllString(retWhere, key, repKeys[index]);
      }
    }
    return retWhere;
  }
  static replaceAllString(originalStr, searchStr, replaceStr) {
    return originalStr.split(searchStr).join(replaceStr);
  }
  static indicesOf(str, searchStr, fromIndex = 0) {
    const indices = [];
    let currentIndex = str.indexOf(searchStr, fromIndex);
    while (currentIndex !== -1) {
      indices.push(currentIndex);
      currentIndex = str.indexOf(searchStr, currentIndex + 1);
    }
    return indices;
  }
  static getWhereStmtForNonCombinedPK(whStmt, withRefs, colNames) {
    let whereStmt = "";
    let stmt = whStmt.substring(6);
    for (let idx = 0; idx < withRefs.length; idx++) {
      let colType = "withRefsNames";
      let idxs = UtilsSQLStatement.indicesOf(stmt, withRefs[idx]);
      if (idxs.length === 0) {
        idxs = UtilsSQLStatement.indicesOf(stmt, colNames[idx]);
        colType = "colNames";
      }
      if (idxs.length > 0) {
        let valStr = "";
        const indicesEqual = UtilsSQLStatement.indicesOf(stmt, "=", idxs[0]);
        if (indicesEqual.length > 0) {
          const indicesAnd = UtilsSQLStatement.indicesOf(stmt, "AND", indicesEqual[0]);
          if (indicesAnd.length > 0) {
            valStr = stmt.substring(indicesEqual[0] + 1, indicesAnd[0] - 1);
            stmt = stmt.substring(indicesAnd[0] + 3);
          } else {
            valStr = stmt.substring(indicesEqual[0] + 1);
          }
          if (idx > 0) {
            whereStmt += " AND ";
          }
          if (colType === "withRefsNames") {
            whereStmt += colNames[idx] + " = " + valStr;
          } else {
            whereStmt += withRefs[idx] + " = " + valStr;
          }
        }
      }
    }
    whereStmt = "WHERE " + whereStmt;
    return whereStmt;
  }
  static updateWhere(whStmt, withRefs, colNames) {
    let whereStmt = "";
    if (whStmt.length <= 0) {
      return whereStmt;
    }
    if (whStmt.toUpperCase().substring(0, 5) !== "WHERE") {
      return whereStmt;
    }
    if (withRefs.length === colNames.length) {
      const keys = UtilsSQLStatement.extractCombinedPrimaryKey(whStmt);
      if (keys) {
        whereStmt = UtilsSQLStatement.getWhereStmtForCombinedPK(whStmt, withRefs, colNames, keys);
      } else {
        whereStmt = UtilsSQLStatement.getWhereStmtForNonCombinedPK(whStmt, withRefs, colNames);
      }
    }
    return whereStmt;
  }
}
UtilsSQLStatement.replaceString = (originalStr, searchStr, replaceStr) => {
  const range = originalStr.indexOf(searchStr);
  if (range !== -1) {
    const modifiedStr = originalStr.substring(0, range) + replaceStr + originalStr.substring(range + searchStr.length);
    return modifiedStr;
  }
  return originalStr;
};
class UtilsDeleteError {
  static findReferencesAndUpdate(message) {
    return new UtilsDeleteError(message);
  }
  static getRefs(message) {
    return new UtilsDeleteError(message);
  }
  static getReferences(message) {
    return new UtilsDeleteError(message);
  }
  static searchForRelatedItems(message) {
    return new UtilsDeleteError(message);
  }
  static upDateWhereForDefault(message) {
    return new UtilsDeleteError(message);
  }
  static upDateWhereForRestrict(message) {
    return new UtilsDeleteError(message);
  }
  static upDateWhereForCascade(message) {
    return new UtilsDeleteError(message);
  }
  static executeUpdateForDelete(message) {
    return new UtilsDeleteError(message);
  }
  constructor(message) {
    this.message = message;
  }
}
class UtilsDelete {
  static async findReferencesAndUpdate(mDB, tableName, whereStmt, initColNames, values) {
    try {
      let retBool = true;
      const result = await UtilsDelete.getReferences(mDB, tableName);
      const references = result.retRefs;
      const tableNameWithRefs = result.tableWithRefs;
      if (references.length <= 0) {
        return retBool;
      }
      if (tableName === tableNameWithRefs) {
        return retBool;
      }
      for (const ref of references) {
        const foreignKeyInfo = UtilsSQLStatement.extractForeignKeyInfo(ref);
        const refTable = foreignKeyInfo.tableName;
        if (refTable === "" || refTable !== tableName) {
          continue;
        }
        const withRefsNames = foreignKeyInfo.forKeys;
        const colNames = foreignKeyInfo.refKeys;
        if (colNames.length !== withRefsNames.length) {
          const msg = "findReferencesAndUpdate: mismatch length";
          throw UtilsDeleteError.findReferencesAndUpdate(msg);
        }
        const action = foreignKeyInfo.action;
        if (action === "NO_ACTION") {
          continue;
        }
        let updTableName = tableNameWithRefs;
        let updColNames = withRefsNames;
        let results = {
          uWhereStmt: "",
          setStmt: ""
        };
        if (!UtilsDelete.checkValuesMatch(withRefsNames, initColNames)) {
          const result2 = await UtilsDelete.searchForRelatedItems(mDB, updTableName, tableName, whereStmt, withRefsNames, colNames, values);
          if (result2.relatedItems.length === 0 && result2.key.length <= 0) {
            continue;
          }
          if (updTableName !== tableName) {
            switch (action) {
              case "RESTRICT":
                results = await UtilsDelete.upDateWhereForRestrict(result2);
                break;
              case "CASCADE":
                results = await UtilsDelete.upDateWhereForCascade(result2);
                break;
              default:
                results = await UtilsDelete.upDateWhereForDefault(withRefsNames, result2);
                break;
            }
          }
        } else {
          throw UtilsDeleteError.findReferencesAndUpdate("Not implemented. Please transfer your example to the maintener");
        }
        if (results.setStmt.length > 0 && results.uWhereStmt.length > 0) {
          UtilsDelete.executeUpdateForDelete(mDB, updTableName, results.uWhereStmt, results.setStmt, updColNames, values);
        }
      }
      return retBool;
    } catch (error) {
      const msg = error.message ? error.message : error;
      if (error instanceof UtilsDeleteError) {
        throw UtilsDeleteError.findReferencesAndUpdate(msg);
      } else {
        throw error;
      }
    }
  }
  static async getReferences(db2, tableName) {
    const sqlStmt = "SELECT sql FROM sqlite_master WHERE sql LIKE('%FOREIGN KEY%') AND sql LIKE('%REFERENCES%') AND sql LIKE('%" + tableName + "%') AND sql LIKE('%ON DELETE%');";
    try {
      const res = await UtilsSQLite.queryAll(db2, sqlStmt, []);
      let retRefs = [];
      let tableWithRefs = "";
      if (res.length > 0) {
        let result = UtilsDelete.getRefs(res[0].sql);
        retRefs = result.foreignKeys;
        tableWithRefs = result.tableName;
      }
      return Promise.resolve({ tableWithRefs, retRefs });
    } catch (err) {
      const error = err.message ? err.message : err;
      const msg = `getReferences: ${error}`;
      throw UtilsDeleteError.getReferences(msg);
    }
  }
  static getRefs(sqlStatement) {
    let tableName = "";
    const foreignKeys = [];
    const statement = UtilsSQLStatement.flattenMultilineString(sqlStatement);
    try {
      const tableNamePattern = /CREATE\s+TABLE\s+(\w+)\s+\(/;
      const tableNameMatch = statement.match(tableNamePattern);
      if (tableNameMatch) {
        tableName = tableNameMatch[1];
      }
      const foreignKeyPattern = /FOREIGN\s+KEY\s+\([^)]+\)\s+REFERENCES\s+(\w+)\s*\([^)]+\)\s+ON\s+DELETE\s+(CASCADE|RESTRICT|SET\s+DEFAULT|SET\s+NULL|NO\s+ACTION)/g;
      const foreignKeyMatches = statement.matchAll(foreignKeyPattern);
      for (const foreignKeyMatch of foreignKeyMatches) {
        const foreignKey = foreignKeyMatch[0];
        foreignKeys.push(foreignKey);
      }
    } catch (error) {
      const msg = `getRefs: Error creating regular expression: ${error}`;
      throw UtilsDeleteError.getRefs(msg);
    }
    return { tableName, foreignKeys };
  }
  static async getReferencedTableName(refValue) {
    var tableName = "";
    if (refValue.length > 0) {
      const arr = refValue.split(new RegExp("REFERENCES", "i"));
      if (arr.length === 2) {
        const oPar = arr[1].indexOf("(");
        tableName = arr[1].substring(0, oPar).trim();
      }
    }
    return tableName;
  }
  static async searchForRelatedItems(mDB, updTableName, tableName, whStmt, withRefsNames, colNames, values) {
    const relatedItems = [];
    let key = "";
    const t1Names = withRefsNames.map((name) => `t1.${name}`);
    const t2Names = colNames.map((name) => `t2.${name}`);
    try {
      let whereClause = UtilsSQLStatement.addPrefixToWhereClause(whStmt, colNames, withRefsNames, "t2.");
      if (whereClause.endsWith(";")) {
        whereClause = whereClause.slice(0, -1);
      }
      const resultString = t1Names.map((t1, index) => `${t1} = ${t2Names[index]}`).join(" AND ");
      const sql = `SELECT t1.rowid FROM ${updTableName} t1 JOIN ${tableName} t2 ON ${resultString} WHERE ${whereClause} AND t1.sql_deleted = 0;`;
      const vals = await UtilsSQLite.queryAll(mDB, sql, values);
      if (vals.length > 0) {
        key = Object.keys(vals[0])[0];
        relatedItems.push(...vals);
      }
      return { key, relatedItems };
    } catch (error) {
      const msg = error.message ? error.message : error;
      throw UtilsDeleteError.searchForRelatedItems(msg);
    }
  }
  static async upDateWhereForDefault(withRefsNames, results) {
    let setStmt = "";
    let uWhereStmt = "";
    try {
      const key = results.key;
      const cols = [];
      for (const relItem of results.relatedItems) {
        const mVal = relItem[key];
        if (mVal !== void 0) {
          cols.push(mVal);
        }
      }
      for (const name of withRefsNames) {
        setStmt += `${name} = NULL, `;
      }
      setStmt += "sql_deleted = 0";
      uWhereStmt = `WHERE ${key} IN (`;
      for (const col of cols) {
        uWhereStmt += `${col},`;
      }
      if (uWhereStmt.endsWith(",")) {
        uWhereStmt = uWhereStmt.slice(0, -1);
      }
      uWhereStmt += ");";
    } catch (error) {
      const msg = error.message ? error.message : error;
      throw UtilsDeleteError.upDateWhereForDefault(msg);
    }
    return { setStmt, uWhereStmt };
  }
  static async upDateWhereForRestrict(results) {
    try {
      const setStmt = "";
      const uWhereStmt = "";
      if (results.relatedItems.length > 0) {
        const msg = "Restrict mode related items exist, please delete them first";
        throw UtilsDeleteError.upDateWhereForRestrict(msg);
      }
      return { setStmt, uWhereStmt };
    } catch (error) {
      const msg = error.message ? error.message : error;
      throw UtilsDeleteError.upDateWhereForRestrict(msg);
    }
  }
  static async upDateWhereForCascade(results) {
    let setStmt = "";
    let uWhereStmt = "";
    try {
      const key = results.key;
      const cols = [];
      for (const relItem of results.relatedItems) {
        const mVal = relItem[key];
        if (mVal !== void 0) {
          cols.push(mVal);
        }
      }
      setStmt += "sql_deleted = 1";
      uWhereStmt = `WHERE ${key} IN (`;
      for (const col of cols) {
        uWhereStmt += `${col},`;
      }
      if (uWhereStmt.endsWith(",")) {
        uWhereStmt = uWhereStmt.slice(0, -1);
      }
      uWhereStmt += ");";
    } catch (error) {
      const msg = error.message ? error.message : error;
      throw UtilsDeleteError.upDateWhereForCascade(msg);
    }
    return { setStmt, uWhereStmt };
  }
  static executeUpdateForDelete(mDB, tableName, whereStmt, setStmt, colNames, values) {
    try {
      let lastId2 = -1;
      const stmt = `UPDATE ${tableName} SET ${setStmt} ${whereStmt}`;
      const selValues = [];
      if (values.length > 0) {
        const arrVal = whereStmt.split("?");
        if (arrVal[arrVal.length - 1] === ";") {
          arrVal.pop();
        }
        for (let jdx = 0; jdx < arrVal.length; jdx++) {
          for (const updVal of colNames) {
            const indices = UtilsSQLStatement.indicesOf(arrVal[jdx], updVal);
            if (indices.length > 0) {
              selValues.push(values[jdx]);
            }
          }
        }
      }
      const retObj = UtilsSQLite.run(mDB, stmt, selValues, false, "no");
      lastId2 = retObj["lastId"];
      if (lastId2 === -1) {
        const msg = `UPDATE sql_deleted failed for table: ${tableName}`;
        throw UtilsDeleteError.executeUpdateForDelete(msg);
      }
    } catch (error) {
      const msg = error.message ? error.message : error;
      throw UtilsDeleteError.executeUpdateForDelete(msg);
    }
  }
  static getCurrentTimeAsInteger() {
    const currentTime = Math.floor(Date.now() / 1e3);
    return currentTime;
  }
  static checkValuesMatch(array1, array2) {
    for (const value of array1) {
      if (!array2.includes(value)) {
        return false;
      }
    }
    return true;
  }
}
class UtilsSQLite {
  static async beginTransaction(db2, isOpen) {
    const msg = "BeginTransaction: ";
    if (!isOpen) {
      return Promise.reject(new Error(`${msg}database not opened`));
    }
    try {
      db2.exec("BEGIN");
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`${msg}${err.message}`));
    }
  }
  static async rollbackTransaction(db2, isOpen) {
    const msg = "RollbackTransaction: ";
    if (!isOpen) {
      return Promise.reject(new Error(`${msg}database not opened`));
    }
    try {
      db2.exec("ROLLBACK");
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`${msg}${err.message}`));
    }
  }
  static commitTransaction(db2, isOpen) {
    const msg = "CommitTransaction: ";
    if (!isOpen) {
      return Promise.reject(new Error(`${msg}database not opened`));
    }
    const sql = "COMMIT";
    try {
      db2.exec(sql);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`${msg}${err.message}`));
    }
  }
  static async dbChanges(db2) {
    const SELECT_CHANGE = "SELECT total_changes()";
    let changes = 0;
    try {
      const res = db2.exec(SELECT_CHANGE);
      changes = res[0].values[0][0];
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(new Error(`DbChanges failed: ${err.message}`));
    }
  }
  static async getLastId(db2) {
    const SELECT_LAST_ID = "SELECT last_insert_rowid()";
    let lastId2 = -1;
    try {
      const res = db2.exec(SELECT_LAST_ID);
      lastId2 = res[0].values[0][0];
      return Promise.resolve(lastId2);
    } catch (err) {
      return Promise.reject(new Error(`GetLastId failed: ${err.message}`));
    }
  }
  static async setForeignKeyConstraintsEnabled(db2, toggle) {
    let stmt = "PRAGMA foreign_keys=OFF";
    if (toggle) {
      stmt = "PRAGMA foreign_keys=ON";
    }
    try {
      db2.run(stmt);
      return Promise.resolve();
    } catch (err) {
      const msg = err.message ? err.message : err;
      return Promise.reject(new Error(`SetForeignKey: ${msg}`));
    }
  }
  static async getVersion(db2) {
    let version2 = 0;
    try {
      const res = db2.exec("PRAGMA user_version;");
      version2 = res[0].values[0][0];
      return Promise.resolve(version2);
    } catch (err) {
      return Promise.reject(new Error(`GetVersion: ${err.message}`));
    }
  }
  static async setVersion(db2, version2) {
    try {
      db2.exec(`PRAGMA user_version = ${version2}`);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`SetVersion: ${err.message}`));
    }
  }
  static async execute(db2, sql, fromJson) {
    try {
      var sqlStmt = sql;
      if (!fromJson && sql.toLowerCase().includes("DELETE FROM".toLowerCase())) {
        sqlStmt = sql.replace(/\n/g, "");
        let sqlStmts = sqlStmt.split(";");
        var resArr = [];
        for (const stmt of sqlStmts) {
          const trimStmt = stmt.trim().substring(0, 11).toUpperCase();
          if (trimStmt === "DELETE FROM" && stmt.toLowerCase().includes("WHERE".toLowerCase())) {
            const whereStmt = stmt.trim();
            const rStmt = await UtilsSQLite.deleteSQL(db2, whereStmt, []);
            resArr.push(rStmt);
          } else {
            resArr.push(stmt);
          }
        }
        sqlStmt = resArr.join(";");
      }
      db2.exec(sqlStmt);
      const changes = await UtilsSQLite.dbChanges(db2);
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(new Error(`Execute: ${err.message}`));
    }
  }
  static async executeSet(db2, set, fromJson, returnMode) {
    const retValues = [];
    let lastId2 = -1;
    let retObj = {};
    for (let i = 0; i < set.length; i++) {
      const statement = "statement" in set[i] ? set[i].statement : null;
      const values = "values" in set[i] && set[i].values.length > 0 ? set[i].values : [];
      if (statement == null) {
        let msg = "ExecuteSet: Error No statement";
        msg += ` for index ${i}`;
        return Promise.reject(new Error(msg));
      }
      try {
        if (Array.isArray(values[0])) {
          for (const val of values) {
            const mVal = await UtilsSQLite.replaceUndefinedByNull(val);
            retObj = await UtilsSQLite.run(db2, statement, mVal, fromJson, returnMode);
            lastId2 = retObj["lastId"];
            if (Object.keys(retObj).includes("values") && retObj["values"].length > 0) {
              retValues.push(retObj["values"]);
            }
          }
        } else {
          const mVal = await UtilsSQLite.replaceUndefinedByNull(values);
          retObj = await UtilsSQLite.run(db2, statement, mVal, fromJson, returnMode);
          lastId2 = retObj["lastId"];
          if (Object.keys(retObj).includes("values") && retObj["values"].length > 0) {
            retValues.push(retObj["values"]);
          }
        }
      } catch (err) {
        return Promise.reject(new Error(`ExecuteSet: ${err.message}`));
      }
    }
    retObj["lastId"] = lastId2;
    retObj["values"] = returnMode === "all" ? retValues : returnMode === "one" ? retValues[0] : [];
    return Promise.resolve(retObj);
  }
  static async queryAll(db2, sql, values) {
    try {
      let retArr = [];
      if (values != null && values.length > 0) {
        retArr = db2.exec(sql, values);
      } else {
        retArr = db2.exec(sql);
      }
      if (retArr.length == 0)
        return Promise.resolve([]);
      const result = retArr[0].values.map((entry) => {
        const obj = {};
        retArr[0].columns.forEach((column, index) => {
          obj[column] = entry[index];
        });
        return obj;
      });
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(new Error(`queryAll: ${err.message}`));
    }
  }
  static async run(db2, statement, values, fromJson, returnMode) {
    let stmtType = statement.replace(/\n/g, "").trim().substring(0, 6).toUpperCase();
    let sqlStmt = statement;
    let retValues = [];
    let retObj = {};
    try {
      if (!fromJson && stmtType === "DELETE") {
        sqlStmt = await UtilsSQLite.deleteSQL(db2, statement, values);
      }
      const mValues = values ? values : [];
      let res;
      if (mValues.length > 0) {
        const mVal = await UtilsSQLite.replaceUndefinedByNull(mValues);
        res = db2.exec(sqlStmt, mVal);
      } else {
        res = db2.exec(sqlStmt);
      }
      if (returnMode === "all" || returnMode === "one") {
        if (res && res.length > 0) {
          retValues = UtilsSQLite.getReturnedValues(res[0], returnMode);
        }
      }
      let lastId2 = await UtilsSQLite.getLastId(db2);
      retObj["lastId"] = lastId2;
      if (retValues != null && retValues.length > 0)
        retObj["values"] = retValues;
      return Promise.resolve(retObj);
    } catch (err) {
      return Promise.reject(new Error(`run: ${err.message}`));
    }
  }
  static getReturnedValues(result, returnMode) {
    const retValues = [];
    for (let i = 0; i < result.values.length; i++) {
      let row = {};
      for (let j = 0; j < result.columns.length; j++) {
        row[result.columns[j]] = result.values[i][j];
      }
      retValues.push(row);
      if (returnMode === "one")
        break;
    }
    return retValues;
  }
  static async deleteSQL(db2, statement, values) {
    let sqlStmt = statement;
    try {
      const isLast = await UtilsSQLite.isLastModified(db2, true);
      const isDel = await UtilsSQLite.isSqlDeleted(db2, true);
      if (!isLast || !isDel) {
        return sqlStmt;
      }
      const whereClause = UtilsSQLStatement.extractWhereClause(sqlStmt);
      if (!whereClause) {
        const msg = "deleteSQL: cannot find a WHERE clause";
        return Promise.reject(new Error(`${msg}`));
      }
      const tableName = UtilsSQLStatement.extractTableName(sqlStmt);
      if (!tableName) {
        const msg = "deleteSQL: cannot find a WHERE clause";
        return Promise.reject(new Error(`${msg}`));
      }
      const colNames = UtilsSQLStatement.extractColumnNames(whereClause);
      if (colNames.length === 0) {
        const msg = "deleteSQL: Did not find column names in the WHERE Statement";
        return Promise.reject(new Error(`${msg}`));
      }
      const setStmt = "sql_deleted = 1";
      const hasToUpdate = await UtilsDelete.findReferencesAndUpdate(db2, tableName, whereClause, colNames, values);
      if (hasToUpdate) {
        const whereStmt = whereClause.endsWith(";") ? whereClause.slice(0, -1) : whereClause;
        sqlStmt = `UPDATE ${tableName} SET ${setStmt} WHERE ${whereStmt} AND sql_deleted = 0;`;
      } else {
        sqlStmt = "";
      }
      return Promise.resolve(sqlStmt);
    } catch (err) {
      let msg = err.message ? err.message : err;
      return Promise.reject(new Error(`deleteSQL: ${msg}`));
    }
  }
  static async getTableList(db2) {
    try {
      const result = await UtilsDrop.getTablesNames(db2);
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(new Error(`getTableList: ${err.message}`));
    }
  }
  static async isTableExists(db2, tableName) {
    try {
      let statement = "SELECT name FROM sqlite_master WHERE ";
      statement += `type='table' AND name='${tableName}';`;
      const res = await UtilsSQLite.queryAll(db2, statement, []);
      const ret = res.length > 0 ? true : false;
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(new Error(`isTableExists: ${err.message}`));
    }
  }
  /**
   * isLastModified
   * @param db
   * @param isOpen
   */
  static async isLastModified(db2, isOpen) {
    if (!isOpen) {
      return Promise.reject("isLastModified: database not opened");
    }
    try {
      const tableList = await UtilsDrop.getTablesNames(db2);
      for (const table of tableList) {
        const tableNamesTypes = await UtilsJSON.getTableColumnNamesTypes(db2, table);
        const tableColumnNames = tableNamesTypes.names;
        if (tableColumnNames.includes("last_modified")) {
          return Promise.resolve(true);
        }
      }
    } catch (err) {
      return Promise.reject(`isLastModified: ${err}`);
    }
  }
  /**
   * isSqlDeleted
   * @param db
   * @param isOpen
   */
  static async isSqlDeleted(db2, isOpen) {
    if (!isOpen) {
      return Promise.reject("isSqlDeleted: database not opened");
    }
    try {
      const tableList = await UtilsDrop.getTablesNames(db2);
      for (const table of tableList) {
        const tableNamesTypes = await UtilsJSON.getTableColumnNamesTypes(db2, table);
        const tableColumnNames = tableNamesTypes.names;
        if (tableColumnNames.includes("sql_deleted")) {
          return Promise.resolve(true);
        }
      }
    } catch (err) {
      return Promise.reject(`isSqlDeleted: ${err}`);
    }
  }
  static async replaceUndefinedByNull(values) {
    const retValues = [];
    for (const val of values) {
      let mVal = val;
      if (typeof val === "undefined")
        mVal = null;
      retValues.push(mVal);
    }
    return Promise.resolve(retValues);
  }
  static async backupTables(db2) {
    const msg = "BackupTables: ";
    let alterTables = {};
    try {
      const tables = await UtilsDrop.getTablesNames(db2);
      for (const table of tables) {
        try {
          const colNames = await UtilsSQLite.backupTable(db2, table);
          alterTables[`${table}`] = colNames;
        } catch (err) {
          return Promise.reject(new Error(`${msg}table ${table}: ${err.message}`));
        }
      }
      return Promise.resolve(alterTables);
    } catch (err) {
      return Promise.reject(new Error(`BackupTables: ${err.message}`));
    }
  }
  static async backupTable(db2, table) {
    try {
      await UtilsSQLite.beginTransaction(db2, true);
      const colNames = await UtilsSQLite.getTableColumnNames(db2, table);
      const tmpTable = `_temp_${table}`;
      const delStmt = `DROP TABLE IF EXISTS ${tmpTable};`;
      await UtilsSQLite.run(db2, delStmt, [], false, "no");
      let stmt = `ALTER TABLE ${table} RENAME `;
      stmt += `TO ${tmpTable};`;
      const lastId2 = await UtilsSQLite.run(db2, stmt, [], false, "no");
      if (lastId2 < 0) {
        let msg = "BackupTable: lastId < 0";
        try {
          await UtilsSQLite.rollbackTransaction(db2, true);
        } catch (err) {
          msg += `: ${err.message}`;
        }
        return Promise.reject(new Error(`${msg}`));
      } else {
        try {
          await UtilsSQLite.commitTransaction(db2, true);
          return Promise.resolve(colNames);
        } catch (err) {
          return Promise.reject(new Error(`BackupTable: ${err.message}`));
        }
      }
    } catch (err) {
      return Promise.reject(new Error(`BackupTable: ${err.message}`));
    }
  }
  static async getTableColumnNames(db2, tableName) {
    let resQuery = [];
    const retNames = [];
    const query = `PRAGMA table_info('${tableName}');`;
    try {
      resQuery = await UtilsSQLite.queryAll(db2, query, []);
      if (resQuery.length > 0) {
        for (const query2 of resQuery) {
          retNames.push(query2.name);
        }
      }
      return Promise.resolve(retNames);
    } catch (err) {
      return Promise.reject(new Error(`GetTableColumnNames: ${err.message}`));
    }
  }
  static async findCommonColumns(db2, alterTables) {
    let commonColumns = {};
    try {
      const tables = await UtilsDrop.getTablesNames(db2);
      if (tables.length === 0) {
        return Promise.reject(new Error("FindCommonColumns: get table's names failed"));
      }
      for (const table of tables) {
        const tableNames = await UtilsSQLite.getTableColumnNames(db2, table);
        const keys = Object.keys(alterTables);
        if (keys.includes(table)) {
          commonColumns[table] = UtilsSQLite.arraysIntersection(alterTables[table], tableNames);
        }
      }
      return Promise.resolve(commonColumns);
    } catch (err) {
      return Promise.reject(new Error(`FindCommonColumns: ${err.message}`));
    }
  }
  static arraysIntersection(a1, a2) {
    if (a1 != null && a2 != null) {
      const first = new Set(a1);
      const second = new Set(a2);
      return [...first].filter((item) => second.has(item));
    } else {
      return [];
    }
  }
  static async updateNewTablesData(db2, commonColumns) {
    try {
      await UtilsSQLite.beginTransaction(db2, true);
      const statements = [];
      const keys = Object.keys(commonColumns);
      keys.forEach((key) => {
        const columns = commonColumns[key].join(",");
        let stmt = `INSERT INTO ${key} `;
        stmt += `(${columns}) `;
        stmt += `SELECT ${columns} FROM _temp_${key};`;
        statements.push(stmt);
      });
      const changes = await UtilsSQLite.execute(db2, statements.join("\n"), false);
      if (changes < 0) {
        let msg = "updateNewTablesData: changes < 0";
        try {
          await UtilsSQLite.rollbackTransaction(db2, true);
        } catch (err) {
          msg += `: ${err.message}`;
        }
        return Promise.reject(new Error(`${msg}`));
      } else {
        try {
          await UtilsSQLite.commitTransaction(db2, true);
          return Promise.resolve();
        } catch (err) {
          return Promise.reject(new Error(`updateNewTablesData: ${err.message}`));
        }
      }
    } catch (err) {
      return Promise.reject(new Error(`updateNewTablesData: ${err.message}`));
    }
  }
}
class UtilsImportJSON {
  static async createDatabaseSchema(mDB, jsonData) {
    let changes = -1;
    const version2 = jsonData.version;
    try {
      await UtilsSQLite.setVersion(mDB.mDb, version2);
      if (jsonData.mode === "full") {
        await UtilsDrop.dropAll(mDB.mDb);
      }
      changes = await UtilsImportJSON.createSchema(mDB, jsonData);
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(new Error(`CreateDatabaseSchema: ${err.message}`));
    }
  }
  static async createSchema(mDB, jsonData) {
    let changes = 0;
    const db2 = mDB.mDb;
    try {
      await UtilsSQLite.beginTransaction(db2, true);
      mDB.setIsTransActive(true);
    } catch (err) {
      return Promise.reject(new Error(`CreateSchema: ${err.message}`));
    }
    const stmts = await UtilsImportJSON.createSchemaStatement(jsonData);
    if (stmts.length > 0) {
      const schemaStmt = stmts.join("\n");
      try {
        changes = await UtilsSQLite.execute(db2, schemaStmt, true);
        if (changes < 0) {
          try {
            await UtilsSQLite.rollbackTransaction(db2, true);
            mDB.setIsTransActive(false);
          } catch (err) {
            return Promise.reject(new Error(`CreateSchema: changes < 0 ${err.message}`));
          }
        }
      } catch (err) {
        const msg = err.message;
        try {
          await UtilsSQLite.rollbackTransaction(db2, true);
          mDB.setIsTransActive(false);
          return Promise.reject(new Error(`CreateSchema: ${msg}`));
        } catch (err2) {
          return Promise.reject(new Error(`CreateSchema: changes < 0 ${err2.message}: ${msg}`));
        }
      }
    }
    try {
      await UtilsSQLite.commitTransaction(db2, true);
      mDB.setIsTransActive(false);
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(new Error(`CreateSchema: commit ${err.message}`));
    }
  }
  static async createSchemaStatement(jsonData) {
    const statements = [];
    let isLastModified = false;
    let isSqlDeleted = false;
    try {
      for (const jTable of jsonData.tables) {
        if (jTable.schema != null && jTable.schema.length >= 1) {
          statements.push(`CREATE TABLE IF NOT EXISTS ${jTable.name} (`);
          for (let j = 0; j < jTable.schema.length; j++) {
            if (j === jTable.schema.length - 1) {
              if (jTable.schema[j].column) {
                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value}`);
                if (jTable.schema[j].column === "last_modified") {
                  isLastModified = true;
                }
                if (jTable.schema[j].column === "sql_deleted") {
                  isSqlDeleted = true;
                }
              } else if (jTable.schema[j].foreignkey) {
                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value}`);
              } else if (jTable.schema[j].constraint) {
                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value}`);
              }
            } else {
              if (jTable.schema[j].column) {
                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value},`);
              } else if (jTable.schema[j].foreignkey) {
                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value},`);
              } else if (jTable.schema[j].primarykey) {
                statements.push(`FOREIGN KEY ${jTable.schema[j].value},`);
              } else if (jTable.schema[j].constraint) {
                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value},`);
              }
            }
          }
          statements.push(");");
          if (isLastModified && isSqlDeleted) {
            let trig = "CREATE TRIGGER IF NOT EXISTS ";
            trig += `${jTable.name}`;
            trig += `_trigger_last_modified `;
            trig += `AFTER UPDATE ON ${jTable.name} `;
            trig += "FOR EACH ROW WHEN NEW.last_modified < ";
            trig += "OLD.last_modified BEGIN UPDATE ";
            trig += `${jTable.name} `;
            trig += `SET last_modified = `;
            trig += "(strftime('%s','now')) WHERE id=OLD.id; END;";
            statements.push(trig);
          }
        }
        if (jTable.indexes != null && jTable.indexes.length >= 1) {
          for (const jIndex of jTable.indexes) {
            const tableName = jTable.name;
            let stmt = `CREATE ${Object.keys(jIndex).includes("mode") ? jIndex.mode + " " : ""} INDEX IF NOT EXISTS `;
            stmt += `${jIndex.name} ON ${tableName} (${jIndex.value});`;
            statements.push(stmt);
          }
        }
        if (jTable.triggers != null && jTable.triggers.length >= 1) {
          for (const jTrg of jTable.triggers) {
            const tableName = jTable.name;
            if (jTrg.timeevent.toUpperCase().endsWith(" ON")) {
              jTrg.timeevent = jTrg.timeevent.substring(0, jTrg.timeevent.length - 3);
            }
            let stmt = `CREATE TRIGGER IF NOT EXISTS `;
            stmt += `${jTrg.name} ${jTrg.timeevent} ON ${tableName} `;
            if (jTrg.condition)
              stmt += `${jTrg.condition} `;
            stmt += `${jTrg.logic};`;
            statements.push(stmt);
          }
        }
      }
      return Promise.resolve(statements);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  static async createTablesData(mDB, jsonData, importProgress) {
    let changes = 0;
    let isValue = false;
    let lastId2 = -1;
    let msg = "";
    let initChanges = -1;
    const db2 = mDB.mDb;
    try {
      initChanges = await UtilsSQLite.dbChanges(db2);
      await UtilsSQLite.beginTransaction(db2, true);
      mDB.setIsTransActive(true);
    } catch (err) {
      return Promise.reject(new Error(`createTablesData: ${err.message}`));
    }
    for (const jTable of jsonData.tables) {
      if (jTable.values != null && jTable.values.length >= 1) {
        try {
          lastId2 = await UtilsImportJSON.createTableData(db2, jTable, jsonData.mode);
          const msg2 = `create table data ${jTable.name}`;
          importProgress.emit({ progress: msg2 });
          if (lastId2 < 0)
            break;
          isValue = true;
        } catch (err) {
          msg = err.message;
          isValue = false;
          break;
        }
      }
    }
    if (isValue) {
      try {
        await UtilsSQLite.commitTransaction(db2, true);
        mDB.setIsTransActive(false);
        changes = await UtilsSQLite.dbChanges(db2) - initChanges;
        return Promise.resolve(changes);
      } catch (err) {
        return Promise.reject(new Error(`CreateTablesData: ${err.message}`));
      }
    } else {
      if (msg.length > 0) {
        try {
          await UtilsSQLite.rollbackTransaction(db2, true);
          mDB.setIsTransActive(false);
          return Promise.reject(new Error(`CreateTablesData: ${msg}`));
        } catch (err) {
          return Promise.reject(new Error(`CreateTablesData: ${err.message}: ${msg}`));
        }
      } else {
        return Promise.resolve(0);
      }
    }
  }
  static async createTableData(db2, table, mode) {
    let lastId2 = -1;
    try {
      const tableExists = await UtilsSQLite.isTableExists(db2, table.name);
      if (!tableExists) {
        return Promise.reject(new Error(`CreateTableData: Table ${table.name} does not exist`));
      }
      const tableNamesTypes = await UtilsJSON.getTableColumnNamesTypes(db2, table.name);
      const tableColumnTypes = tableNamesTypes.types;
      const tableColumnNames = tableNamesTypes.names;
      if (tableColumnTypes.length === 0) {
        return Promise.reject(new Error(`CreateTableData: Table ${table.name} info does not exist`));
      }
      for (let j = 0; j < table.values.length; j++) {
        let row = table.values[j];
        let isRun = true;
        const stmt = await UtilsImportJSON.createRowStatement(db2, tableColumnNames, row, j, table.name, mode);
        isRun = await UtilsImportJSON.checkUpdate(db2, stmt, row, table.name, tableColumnNames);
        if (isRun) {
          if (stmt.substring(0, 6).toUpperCase() === "DELETE") {
            row = [];
          }
          lastId2 = await UtilsSQLite.run(db2, stmt, row, true, "no");
          if (lastId2 < 0) {
            return Promise.reject(new Error("CreateTableData: lastId < 0"));
          }
        } else {
          lastId2 = 0;
        }
      }
      return Promise.resolve(lastId2);
    } catch (err) {
      return Promise.reject(new Error(`CreateTableData: ${err.message}`));
    }
  }
  static async createRowStatement(db2, tColNames, row, j, tableName, mode) {
    if (row.length != tColNames.length || row.length === 0 || tColNames.length === 0) {
      return Promise.reject(new Error(`CreateRowStatement: Table ${tableName} values row ${j} not correct length`));
    }
    try {
      const retisIdExists = await UtilsImportJSON.isIdExists(db2, tableName, tColNames[0], row[0]);
      let stmt;
      if (mode === "full" || mode === "partial" && !retisIdExists) {
        const nameString = tColNames.join();
        const questionMarkString = await UtilsImportJSON.createQuestionMarkString(tColNames.length);
        stmt = `INSERT INTO ${tableName} (${nameString}) VALUES (`;
        stmt += `${questionMarkString});`;
      } else {
        let isUpdate = true;
        const isColDeleted = (element) => element === `sql_deleted`;
        const idxDelete = tColNames.findIndex(isColDeleted);
        if (idxDelete >= 0) {
          if (row[idxDelete] === 1) {
            isUpdate = false;
            stmt = `DELETE FROM ${tableName} WHERE `;
            if (typeof row[0] == "string") {
              stmt += `${tColNames[0]} = '${row[0]}';`;
            } else {
              stmt += `${tColNames[0]} = ${row[0]};`;
            }
          }
        }
        if (isUpdate) {
          const setString = await UtilsImportJSON.setNameForUpdate(tColNames);
          if (setString.length === 0) {
            return Promise.reject(new Error(`CreateRowStatement: Table ${tableName} values row ${j} not set to String`));
          }
          stmt = `UPDATE ${tableName} SET ${setString} WHERE `;
          if (typeof row[0] == "string") {
            stmt += `${tColNames[0]} = '${row[0]}';`;
          } else {
            stmt += `${tColNames[0]} = ${row[0]};`;
          }
        }
      }
      return Promise.resolve(stmt);
    } catch (err) {
      return Promise.reject(new Error(`CreateRowStatement: ${err.message}`));
    }
  }
  static async checkUpdate(db2, stmt, values, tbName, tColNames) {
    let isRun = true;
    if (stmt.substring(0, 6) === "UPDATE") {
      try {
        let query = `SELECT * FROM ${tbName} WHERE `;
        if (typeof values[0] == "string") {
          query += `${tColNames[0]} = '${values[0]}';`;
        } else {
          query += `${tColNames[0]} = ${values[0]};`;
        }
        const resQuery = await UtilsJSON.getValues(db2, query, tbName);
        let resValues = [];
        if (resQuery.length > 0) {
          resValues = resQuery[0];
        }
        if (values.length > 0 && resValues.length > 0 && values.length === resValues.length) {
          for (let i = 0; i < values.length; i++) {
            if (values[i] !== resValues[i]) {
              return Promise.resolve(true);
            }
          }
          return Promise.resolve(false);
        } else {
          const msg = "Both arrays not the same length";
          return Promise.reject(new Error(`CheckUpdate: ${msg}`));
        }
      } catch (err) {
        return Promise.reject(new Error(`CheckUpdate: ${err.message}`));
      }
    } else {
      return Promise.resolve(isRun);
    }
  }
  static async isIdExists(db2, dbName, firstColumnName, key) {
    let ret = false;
    let query = `SELECT ${firstColumnName} FROM ${dbName} WHERE ${firstColumnName} = `;
    if (typeof key === "number")
      query += `${key};`;
    if (typeof key === "string")
      query += `'${key}';`;
    try {
      const resQuery = await UtilsSQLite.queryAll(db2, query, []);
      if (resQuery.length === 1)
        ret = true;
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(new Error(`IsIdExists: ${err.message}`));
    }
  }
  static async isType(type, value) {
    let ret = false;
    if (type === "NULL" && typeof value === "object")
      ret = true;
    if (type === "TEXT" && typeof value === "string")
      ret = true;
    if (type === "INTEGER" && typeof value === "number")
      ret = true;
    if (type === "REAL" && typeof value === "number")
      ret = true;
    if (type === "BLOB" && typeof value === "string")
      ret = true;
    if (ret) {
      return Promise.resolve();
    } else {
      return Promise.reject(new Error("IsType: not a SQL Type"));
    }
  }
  static async checkColumnTypes(tableTypes, rowValues) {
    for (let i = 0; i < rowValues.length; i++) {
      if (rowValues[i] != null) {
        try {
          await UtilsImportJSON.isType(tableTypes[i], rowValues[i]);
        } catch (err) {
          return Promise.reject(new Error("CheckColumnTypes: Type not found"));
        }
      }
    }
    return Promise.resolve();
  }
  static async createQuestionMarkString(length) {
    let retString = "";
    for (let i = 0; i < length; i++) {
      retString += "?,";
    }
    if (retString.length > 1) {
      retString = retString.slice(0, -1);
      return Promise.resolve(retString);
    } else {
      return Promise.reject(new Error("CreateQuestionMarkString: length = 0"));
    }
  }
  static async setNameForUpdate(names) {
    let retString = "";
    for (const name of names) {
      retString += `${name} = ? ,`;
    }
    if (retString.length > 1) {
      retString = retString.slice(0, -1);
      return Promise.resolve(retString);
    } else {
      return Promise.reject(new Error("SetNameForUpdate: length = 0"));
    }
  }
  static async createView(db2, view) {
    const stmt = `CREATE VIEW IF NOT EXISTS ${view.name} AS ${view.value};`;
    try {
      const changes = await UtilsSQLite.execute(db2, stmt, true);
      if (changes < 0) {
        return Promise.reject(new Error(`CreateView: ${view.name} failed`));
      }
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`CreateView: ${err.message}`));
    }
  }
  static async createViews(mDB, jsonData) {
    const db2 = mDB.mDb;
    let isView = false;
    let msg = "";
    let initChanges = -1;
    let changes = -1;
    try {
      initChanges = await UtilsSQLite.dbChanges(db2);
      await UtilsSQLite.beginTransaction(db2, true);
      mDB.setIsTransActive(true);
    } catch (err) {
      return Promise.reject(new Error(`createViews: ${err.message}`));
    }
    for (const jView of jsonData.views) {
      if (jView.value != null) {
        try {
          await UtilsImportJSON.createView(db2, jView);
          isView = true;
        } catch (err) {
          msg = err.message;
          isView = false;
          break;
        }
      }
    }
    if (isView) {
      try {
        await UtilsSQLite.commitTransaction(db2, true);
        mDB.setIsTransActive(false);
        changes = await UtilsSQLite.dbChanges(db2) - initChanges;
        return Promise.resolve(changes);
      } catch (err) {
        return Promise.reject(new Error(`createViews: ${err.message}`));
      }
    } else {
      if (msg.length > 0) {
        try {
          await UtilsSQLite.rollbackTransaction(db2, true);
          mDB.setIsTransActive(false);
          return Promise.reject(new Error(`createViews: ${msg}`));
        } catch (err) {
          return Promise.reject(new Error(`createViews: ${err.message}: ${msg}`));
        }
      } else {
        return Promise.resolve(0);
      }
    }
  }
}
class UtilsExportJSON {
  static async createExportObject(db2, sqlObj, exportProgress) {
    const retObj = {};
    let tables = [];
    let views = [];
    let errmsg = "";
    try {
      views = await UtilsExportJSON.getViewsName(db2);
      const resTables = await UtilsExportJSON.getTablesNameSQL(db2);
      if (resTables.length === 0) {
        return Promise.reject(new Error("createExportObject: table's names failed"));
      } else {
        const isTable = await UtilsSQLite.isTableExists(db2, "sync_table");
        if (!isTable && sqlObj.mode === "partial") {
          return Promise.reject(new Error("No sync_table available"));
        }
        switch (sqlObj.mode) {
          case "partial": {
            tables = await UtilsExportJSON.getTablesPartial(db2, resTables, exportProgress);
            break;
          }
          case "full": {
            tables = await UtilsExportJSON.getTablesFull(db2, resTables, exportProgress);
            break;
          }
          default: {
            errmsg = "createExportObject: expMode " + sqlObj.mode + " not defined";
            break;
          }
        }
        if (errmsg.length > 0) {
          return Promise.reject(new Error(errmsg));
        }
        if (tables.length > 0) {
          retObj.database = sqlObj.database;
          retObj.version = sqlObj.version;
          retObj.encrypted = sqlObj.encrypted;
          retObj.mode = sqlObj.mode;
          retObj.tables = tables;
          if (views.length > 0) {
            retObj.views = views;
          }
        }
        return Promise.resolve(retObj);
      }
    } catch (err) {
      return Promise.reject(new Error("createExportObject: " + err.message));
    }
  }
  static async getViewsName(mDb) {
    const views = [];
    let sql = "SELECT name,sql FROM sqlite_master WHERE ";
    sql += "type='view' AND name NOT LIKE 'sqlite_%';";
    let retQuery = [];
    try {
      retQuery = await UtilsSQLite.queryAll(mDb, sql, []);
      for (const query of retQuery) {
        const view = {};
        view.name = query.name;
        view.value = query.sql.substring(query.sql.indexOf("AS ") + 3);
        views.push(view);
      }
      return Promise.resolve(views);
    } catch (err) {
      return Promise.reject(new Error(`getViewsName: ${err.message}`));
    }
  }
  static async getTablesFull(db2, resTables, exportProgress) {
    const tables = [];
    let errmsg = "";
    try {
      for (const rTable of resTables) {
        let tableName;
        let sqlStmt;
        if (rTable.name) {
          tableName = rTable.name;
        } else {
          errmsg = "GetTablesFull: no name";
          break;
        }
        if (rTable.sql) {
          sqlStmt = rTable.sql;
        } else {
          errmsg = "GetTablesFull: no sql";
          break;
        }
        const table = {};
        const schema = await UtilsExportJSON.getSchema(
          sqlStmt
          /*, tableName*/
        );
        if (schema.length === 0) {
          errmsg = "GetTablesFull: no Schema returned";
          break;
        }
        await UtilsJSON.checkSchemaValidity(schema);
        const indexes = await UtilsExportJSON.getIndexes(db2, tableName);
        if (indexes.length > 0) {
          await UtilsJSON.checkIndexesValidity(indexes);
        }
        const triggers = await UtilsExportJSON.getTriggers(db2, tableName);
        if (triggers.length > 0) {
          await UtilsJSON.checkTriggersValidity(triggers);
        }
        let msg = `Full: Table ${tableName} schema export completed ...`;
        exportProgress.emit({ progress: msg });
        const query = `SELECT * FROM ${tableName};`;
        const values = await UtilsJSON.getValues(db2, query, tableName);
        table.name = tableName;
        if (schema.length > 0) {
          table.schema = schema;
        } else {
          errmsg = `GetTablesFull: must contain schema`;
          break;
        }
        if (indexes.length > 0) {
          table.indexes = indexes;
        }
        if (triggers.length > 0) {
          table.triggers = triggers;
        }
        if (values.length > 0) {
          table.values = values;
        }
        if (Object.keys(table).length <= 1) {
          errmsg = `GetTablesFull: table ${tableName} is not a jsonTable`;
          break;
        }
        msg = `Full: Table ${tableName} table data export completed ...`;
        exportProgress.emit({ progress: msg });
        tables.push(table);
      }
      if (errmsg.length > 0) {
        return Promise.reject(new Error(errmsg));
      }
      return Promise.resolve(tables);
    } catch (err) {
      return Promise.reject(new Error(`GetTablesFull: ${err.message}`));
    }
  }
  static async getSchema(sqlStmt) {
    const schema = [];
    const openPar = sqlStmt.indexOf("(");
    const closePar = sqlStmt.lastIndexOf(")");
    let sstr = sqlStmt.substring(openPar + 1, closePar);
    try {
      sstr = await UtilsExportJSON.modEmbeddedParentheses(sstr);
      const sch = sstr.split(",");
      for (let j = 0; j < sch.length; j++) {
        let row = [];
        const scht = sch[j].replace(/\n/g, "").trim();
        row[0] = scht.substring(0, scht.indexOf(" "));
        row[1] = scht.substring(scht.indexOf(" ") + 1);
        const jsonRow = {};
        if (row[0].toUpperCase() === "FOREIGN") {
          const oPar = scht.indexOf("(");
          const cPar = scht.indexOf(")");
          const fk2 = scht.substring(oPar + 1, cPar);
          const fknames = fk2.split("§");
          row[0] = fknames.join(",");
          row[0] = row[0].replace(/, /g, ",");
          row[1] = scht.substring(cPar + 2);
          jsonRow["foreignkey"] = row[0];
        } else if (row[0].toUpperCase() === "PRIMARY") {
          const oPar = scht.indexOf("(");
          const cPar = scht.indexOf(")");
          const pk2 = scht.substring(oPar + 1, cPar);
          const pknames = pk2.split("§");
          row[0] = "CPK_" + pknames.join("_");
          row[0] = row[0].replace(/_ /g, "_");
          row[1] = scht;
          jsonRow["constraint"] = row[0];
        } else if (row[0].toUpperCase() === "CONSTRAINT") {
          let tRow = [];
          const row1t = row[1].trim();
          tRow[0] = row1t.substring(0, row1t.indexOf(" "));
          tRow[1] = row1t.substring(row1t.indexOf(" ") + 1);
          row[0] = tRow[0];
          jsonRow["constraint"] = row[0];
          row[1] = tRow[1];
        } else {
          jsonRow["column"] = row[0];
        }
        jsonRow["value"] = row[1].replace(/§/g, ",");
        schema.push(jsonRow);
      }
      return Promise.resolve(schema);
    } catch (err) {
      return Promise.reject(new Error(err.message));
    }
  }
  static async getIndexes(db2, tableName) {
    const indexes = [];
    let errmsg = "";
    try {
      let stmt = "SELECT name,tbl_name,sql FROM sqlite_master WHERE ";
      stmt += `type = 'index' AND tbl_name = '${tableName}' `;
      stmt += `AND sql NOTNULL;`;
      const retIndexes = await UtilsSQLite.queryAll(db2, stmt, []);
      if (retIndexes.length > 0) {
        for (const rIndex of retIndexes) {
          const keys = Object.keys(rIndex);
          if (keys.length === 3) {
            if (rIndex["tbl_name"] === tableName) {
              const sql = rIndex["sql"];
              const mode = sql.includes("UNIQUE") ? "UNIQUE" : "";
              const oPar = sql.lastIndexOf("(");
              const cPar = sql.lastIndexOf(")");
              const index = {};
              index.name = rIndex["name"];
              index.value = sql.slice(oPar + 1, cPar);
              if (mode.length > 0)
                index.mode = mode;
              indexes.push(index);
            } else {
              errmsg = `GetIndexes: Table ${tableName} doesn't match`;
              break;
            }
          } else {
            errmsg = `GetIndexes: Table ${tableName} creating indexes`;
            break;
          }
        }
        if (errmsg.length > 0) {
          return Promise.reject(new Error(errmsg));
        }
      }
      return Promise.resolve(indexes);
    } catch (err) {
      return Promise.reject(new Error(`GetIndexes: ${err.message}`));
    }
  }
  static async getTriggers(db2, tableName) {
    const triggers = [];
    try {
      let stmt = "SELECT name,tbl_name,sql FROM sqlite_master WHERE ";
      stmt += `type = 'trigger' AND tbl_name = '${tableName}' `;
      stmt += `AND sql NOT NULL;`;
      const retTriggers = await UtilsSQLite.queryAll(db2, stmt, []);
      if (retTriggers.length > 0) {
        for (const rTrg of retTriggers) {
          const keys = Object.keys(rTrg);
          if (keys.length === 3) {
            if (rTrg["tbl_name"] === tableName) {
              const sql = rTrg["sql"];
              const name = rTrg["name"];
              let sqlArr = sql.split(name);
              if (sqlArr.length != 2) {
                return Promise.reject(new Error(`GetTriggers: sql split name does not return 2 values`));
              }
              if (!sqlArr[1].includes(tableName)) {
                return Promise.reject(new Error(`GetTriggers: sql split does not contains ${tableName}`));
              }
              const timeEvent = sqlArr[1].split(tableName, 1)[0].trim();
              sqlArr = sqlArr[1].split(timeEvent + " " + tableName);
              if (sqlArr.length != 2) {
                return Promise.reject(new Error(`GetTriggers: sql split tableName does not return 2 values`));
              }
              let condition = "";
              let logic = "";
              if (sqlArr[1].trim().substring(0, 5).toUpperCase() !== "BEGIN") {
                sqlArr = sqlArr[1].trim().split("BEGIN");
                if (sqlArr.length != 2) {
                  return Promise.reject(new Error(`GetTriggers: sql split BEGIN does not return 2 values`));
                }
                condition = sqlArr[0].trim();
                logic = "BEGIN" + sqlArr[1];
              } else {
                logic = sqlArr[1].trim();
              }
              const trigger = {};
              trigger.name = name;
              trigger.logic = logic;
              if (condition.length > 0)
                trigger.condition = condition;
              trigger.timeevent = timeEvent;
              triggers.push(trigger);
            } else {
              return Promise.reject(new Error(`GetTriggers: Table ${tableName} doesn't match`));
            }
          } else {
            return Promise.reject(new Error(`GetTriggers: Table ${tableName} creating indexes`));
          }
        }
      }
      return Promise.resolve(triggers);
    } catch (err) {
      return Promise.reject(new Error(`GetTriggers: ${err.message}`));
    }
  }
  static async getTablesPartial(db2, resTables, exportProgress) {
    const tables = [];
    let modTables = {};
    let syncDate = 0;
    let modTablesKeys = [];
    let errmsg = "";
    try {
      const partialModeData = await UtilsExportJSON.getPartialModeData(db2, resTables);
      if (Object.keys(partialModeData).includes("syncDate")) {
        syncDate = partialModeData.syncDate;
      }
      if (Object.keys(partialModeData).includes("modTables")) {
        modTables = partialModeData.modTables;
        modTablesKeys = Object.keys(modTables);
      }
      for (const rTable of resTables) {
        let tableName = "";
        let sqlStmt = "";
        if (rTable.name) {
          tableName = rTable.name;
        } else {
          errmsg = "GetTablesFull: no name";
          break;
        }
        if (rTable.sql) {
          sqlStmt = rTable.sql;
        } else {
          errmsg = "GetTablesFull: no sql";
          break;
        }
        if (modTablesKeys.length == 0 || modTablesKeys.indexOf(tableName) === -1 || modTables[tableName] == "No") {
          continue;
        }
        const table = {};
        let schema = [];
        let indexes = [];
        let triggers = [];
        table.name = rTable;
        if (modTables[table.name] === "Create") {
          schema = await UtilsExportJSON.getSchema(
            sqlStmt
            /*, tableName*/
          );
          if (schema.length > 0) {
            await UtilsJSON.checkSchemaValidity(schema);
          }
          indexes = await UtilsExportJSON.getIndexes(db2, tableName);
          if (indexes.length > 0) {
            await UtilsJSON.checkIndexesValidity(indexes);
          }
          triggers = await UtilsExportJSON.getTriggers(db2, tableName);
          if (triggers.length > 0) {
            await UtilsJSON.checkTriggersValidity(triggers);
          }
        }
        let msg = `Partial: Table ${tableName} schema export completed ...`;
        exportProgress.emit({ progress: msg });
        let query = "";
        if (modTables[tableName] === "Create") {
          query = `SELECT * FROM ${tableName};`;
        } else {
          query = `SELECT * FROM ${tableName} WHERE last_modified > ${syncDate};`;
        }
        const values = await UtilsJSON.getValues(db2, query, tableName);
        table.name = tableName;
        if (schema.length > 0) {
          table.schema = schema;
        }
        if (indexes.length > 0) {
          table.indexes = indexes;
        }
        if (triggers.length > 0) {
          table.triggers = triggers;
        }
        if (values.length > 0) {
          table.values = values;
        }
        if (Object.keys(table).length <= 1) {
          errmsg = `GetTablesPartial: table ${tableName} is not a jsonTable`;
          break;
        }
        msg = `Partial: Table ${tableName} table data export completed ...`;
        exportProgress.emit({ progress: msg });
        tables.push(table);
      }
      if (errmsg.length > 0) {
        return Promise.reject(new Error(errmsg));
      }
      return Promise.resolve(tables);
    } catch (err) {
      return Promise.reject(new Error(`GetTablesPartial: ${err.message}`));
    }
  }
  static async getPartialModeData(db2, resTables) {
    const retData = {};
    try {
      const syncDate = await UtilsExportJSON.getSynchroDate(db2);
      if (syncDate <= 0) {
        return Promise.reject(new Error(`GetPartialModeData: no syncDate`));
      }
      const modTables = await UtilsExportJSON.getTablesModified(db2, resTables, syncDate);
      if (modTables.length <= 0) {
        return Promise.reject(new Error(`GetPartialModeData: no modTables`));
      }
      retData.syncDate = syncDate;
      retData.modTables = modTables;
      return Promise.resolve(retData);
    } catch (err) {
      return Promise.reject(new Error(`GetPartialModeData: ${err.message}`));
    }
  }
  static async getTablesNameSQL(db2) {
    let sql = "SELECT name,sql FROM sqlite_master WHERE ";
    sql += "type='table' AND name NOT LIKE 'sync_table' ";
    sql += "AND name NOT LIKE '_temp_%' ";
    sql += "AND name NOT LIKE 'sqlite_%';";
    try {
      const retQuery = await UtilsSQLite.queryAll(db2, sql, []);
      return Promise.resolve(retQuery);
    } catch (err) {
      return Promise.reject(new Error(`getTablesNamesSQL: ${err.message}`));
    }
  }
  static async getTablesModified(db2, tables, syncDate) {
    let errmsg = "";
    try {
      const retModified = {};
      for (const rTable of tables) {
        let mode;
        let stmt = "SELECT count(*) AS tcount  ";
        stmt += `FROM ${rTable.name};`;
        let retQuery = await UtilsSQLite.queryAll(db2, stmt, []);
        if (retQuery.length != 1) {
          errmsg = "GetTableModified: total count not returned";
          break;
        }
        const totalCount = retQuery[0]["tcount"];
        stmt = "SELECT count(*) AS mcount FROM ";
        stmt += `${rTable.name} WHERE last_modified > `;
        stmt += `${syncDate};`;
        retQuery = await UtilsSQLite.queryAll(db2, stmt, []);
        if (retQuery.length != 1)
          break;
        const totalModifiedCount = retQuery[0]["mcount"];
        if (totalModifiedCount === 0) {
          mode = "No";
        } else if (totalCount === totalModifiedCount) {
          mode = "Create";
        } else {
          mode = "Modified";
        }
        const key = rTable.name;
        retModified[key] = mode;
      }
      if (errmsg.length > 0) {
        return Promise.reject(new Error(errmsg));
      }
      return Promise.resolve(retModified);
    } catch (err) {
      return Promise.reject(new Error(`GetTableModified: ${err.message}`));
    }
  }
  static async getSynchroDate(db2) {
    try {
      const stmt = `SELECT sync_date FROM sync_table WHERE id = 1;`;
      const res = await UtilsSQLite.queryAll(db2, stmt, []);
      return Promise.resolve(res[0]["sync_date"]);
    } catch (err) {
      const msg = `GetSynchroDate: ${err.message}`;
      return Promise.reject(new Error(msg));
    }
  }
  static async getLastExportDate(db2) {
    try {
      const stmt = `SELECT sync_date FROM sync_table WHERE id = 2;`;
      const res = await UtilsSQLite.queryAll(db2, stmt, []);
      if (res.length === 0) {
        return Promise.resolve(-1);
      } else {
        return Promise.resolve(res[0]["sync_date"]);
      }
    } catch (err) {
      const msg = `getLastExport: ${err.message}`;
      return Promise.reject(new Error(msg));
    }
  }
  static async setLastExportDate(db2, lastExportedDate) {
    try {
      const isTable = await UtilsSQLite.isTableExists(db2, "sync_table");
      if (!isTable) {
        return Promise.reject(new Error("setLastExportDate: No sync_table available"));
      }
      const sDate = Math.round(new Date(lastExportedDate).getTime() / 1e3);
      let stmt = "";
      if (await UtilsExportJSON.getLastExportDate(db2) > 0) {
        stmt = `UPDATE sync_table SET sync_date = ${sDate} WHERE id = 2;`;
      } else {
        stmt = `INSERT INTO sync_table (sync_date) VALUES (${sDate});`;
      }
      const changes = await UtilsSQLite.execute(db2, stmt, false);
      if (changes < 0) {
        return { result: false, message: "setLastExportDate failed" };
      } else {
        return { result: true };
      }
    } catch (err) {
      return { result: false, message: `setLastExportDate failed: ${err.message}` };
    }
  }
  static async delExportedRows(db2) {
    let lastExportDate;
    try {
      const isTable = await UtilsSQLite.isTableExists(db2, "sync_table");
      if (!isTable) {
        return Promise.reject(new Error("DelExportedRows: No sync_table available"));
      }
      lastExportDate = await UtilsExportJSON.getLastExportDate(db2);
      if (lastExportDate < 0) {
        return Promise.reject(new Error("DelExportedRows: no last exported date available"));
      }
      const resTables = await UtilsSQLite.getTableList(db2);
      if (resTables.length === 0) {
        return Promise.reject(new Error("DelExportedRows: No table's names returned"));
      }
      for (const table of resTables) {
        let lastId2 = -1;
        const delStmt = `DELETE FROM ${table}
              WHERE sql_deleted = 1 AND last_modified < ${lastExportDate};`;
        lastId2 = await UtilsSQLite.run(db2, delStmt, [], true, "no");
        if (lastId2 < 0) {
          return Promise.reject(new Error("DelExportedRows: lastId < 0"));
        }
      }
    } catch (err) {
      return Promise.reject(new Error(`DelExportedRows failed: ${err.message}`));
    }
  }
  static async modEmbeddedParentheses(sstr) {
    const oParArray = UtilsExportJSON.indexOfChar(sstr, "(");
    const cParArray = UtilsExportJSON.indexOfChar(sstr, ")");
    if (oParArray.length != cParArray.length) {
      return Promise.reject("ModEmbeddedParentheses: Not same number of '(' & ')'");
    }
    if (oParArray.length === 0) {
      return Promise.resolve(sstr);
    }
    let resStmt = sstr.substring(0, oParArray[0] - 1);
    for (let i = 0; i < oParArray.length; i++) {
      let str;
      if (i < oParArray.length - 1) {
        if (oParArray[i + 1] < cParArray[i]) {
          str = sstr.substring(oParArray[i] - 1, cParArray[i + 1]);
          i++;
        } else {
          str = sstr.substring(oParArray[i] - 1, cParArray[i]);
        }
      } else {
        str = sstr.substring(oParArray[i] - 1, cParArray[i]);
      }
      const newS = str.replace(/,/g, "§");
      resStmt += newS;
      if (i < oParArray.length - 1) {
        resStmt += sstr.substring(cParArray[i], oParArray[i + 1] - 1);
      }
    }
    resStmt += sstr.substring(cParArray[cParArray.length - 1], sstr.length);
    return Promise.resolve(resStmt);
  }
  static indexOfChar(str, char) {
    let tmpArr = [...str];
    char = char.toLowerCase();
    return tmpArr.reduce((results, elem, idx) => elem.toLowerCase() === char ? [...results, idx] : results, []);
  }
}
class UtilsUpgrade {
  static async onUpgrade(mDB, vUpgDict, curVersion, targetVersion) {
    let changes = -1;
    const sortedKeys = new Int32Array(Object.keys(vUpgDict).map((item) => parseInt(item))).sort();
    for (const versionKey of sortedKeys) {
      if (versionKey > curVersion && versionKey <= targetVersion) {
        const statements = vUpgDict[versionKey].statements;
        if (statements.length === 0) {
          return Promise.reject("onUpgrade: statements not given");
        }
        try {
          await UtilsSQLite.setForeignKeyConstraintsEnabled(mDB.mDb, false);
          const initChanges = await UtilsSQLite.dbChanges(mDB.mDb);
          await UtilsUpgrade.executeStatementsProcess(mDB, statements);
          await UtilsSQLite.setVersion(mDB.mDb, versionKey);
          await UtilsSQLite.setForeignKeyConstraintsEnabled(mDB.mDb, true);
          changes = await UtilsSQLite.dbChanges(mDB.mDb) - initChanges;
        } catch (err) {
          return Promise.reject(new Error(`onUpgrade: ${err.message}`));
        }
      }
    }
    return Promise.resolve(changes);
  }
  static async executeStatementsProcess(mDB, statements) {
    try {
      await UtilsSQLite.beginTransaction(mDB.mDb, true);
      mDB.setIsTransActive(true);
      for (const statement of statements) {
        await UtilsSQLite.execute(mDB.mDb, statement, false);
      }
      await UtilsSQLite.commitTransaction(mDB.mDb, true);
      mDB.setIsTransActive(false);
      return Promise.resolve();
    } catch (err) {
      await UtilsSQLite.rollbackTransaction(mDB.mDb, true);
      mDB.setIsTransActive(false);
      return Promise.reject(`ExecuteStatementProcess: ${err}`);
    }
  }
}
class Database {
  constructor(databaseName, version2, upgDict, store, autoSave, wasmPath) {
    this.vUpgDict = {};
    this.autoSave = false;
    this.wasmPath = "/assets";
    this.isBackup = false;
    this.isTransactionActive = false;
    this.dbName = databaseName;
    this.store = store;
    this.version = version2;
    this.mDb = null;
    this.vUpgDict = upgDict;
    this._isDBOpen = false;
    this.autoSave = autoSave;
    this.wasmPath = wasmPath;
  }
  async open() {
    const config2 = {
      locateFile: (file) => `${this.wasmPath}/${file}`
    };
    return new Promise((resolve2, reject) => {
      try {
        initSqlJs(config2).then(async (SQL) => {
          const retDB = await UtilsStore.getDBFromStore(this.dbName, this.store);
          if (retDB != null) {
            this.mDb = new SQL.Database(retDB);
          } else {
            this.mDb = new SQL.Database();
            await UtilsStore.setInitialDBToStore(this.dbName, this.store);
          }
          this._isDBOpen = true;
          let curVersion = await UtilsSQLite.getVersion(this.mDb);
          if (this.version > curVersion && Object.keys(this.vUpgDict).length > 0) {
            try {
              const isDB = await UtilsStore.isDBInStore(this.dbName, this.store);
              if (isDB) {
                await UtilsStore.copyDBToStore(this.dbName, `backup-${this.dbName}`, this.store);
                this.isBackup = true;
              }
              const changes = await UtilsUpgrade.onUpgrade(this, this.vUpgDict, curVersion, this.version);
              if (changes === -1) {
                try {
                  if (this.isBackup) {
                    await UtilsStore.restoreDBFromStore(this.dbName, "backup", this.store);
                  }
                } catch (err) {
                  return reject(new Error(`Open: ${err.message}`));
                }
              }
              if (this.isBackup) {
                await UtilsStore.removeDBFromStore(`backup-${this.dbName}`, this.store);
              }
            } catch (err) {
              try {
                if (this.isBackup) {
                  await UtilsStore.restoreDBFromStore(this.dbName, "backup", this.store);
                }
              } catch (err2) {
                return reject(new Error(`Open: ${err2.message}`));
              }
            }
          }
          if (this.autoSave) {
            try {
              await this.saveToStore();
            } catch (err) {
              this._isDBOpen = false;
              return reject(`Open: ${err}`);
            }
          }
          await UtilsSQLite.setForeignKeyConstraintsEnabled(this.mDb, true);
          return resolve2();
        });
      } catch (err) {
        this._isDBOpen = false;
        return reject(`in open ${err}`);
      }
    });
  }
  isDBOpen() {
    return this._isDBOpen;
  }
  async close() {
    if (this.mDb != null && this._isDBOpen) {
      try {
        await this.saveToStore(false);
        this.mDb.close();
        this._isDBOpen = false;
      } catch (err) {
        this._isDBOpen = false;
        return Promise.reject(`in close ${err}`);
      }
    }
    return Promise.resolve();
  }
  async saveToStore(setFK = true) {
    if (this.mDb != null && this._isDBOpen) {
      try {
        await UtilsStore.setDBToStore(this.mDb, this.dbName, this.store);
        if (setFK) {
          await UtilsSQLite.setForeignKeyConstraintsEnabled(this.mDb, true);
        }
      } catch (err) {
        return Promise.reject(`in saveToStore ${err}`);
      }
    }
    return Promise.resolve();
  }
  async exportDB() {
    try {
      const data = this.mDb.export();
      return data;
    } catch (err) {
      const msg = err.message ? err.message : err;
      return Promise.reject(`exportDB: ${msg}`);
    }
  }
  async getVersion() {
    if (this.mDb != null && this._isDBOpen) {
      try {
        const curVersion = await UtilsSQLite.getVersion(this.mDb);
        return Promise.resolve(curVersion);
      } catch (err) {
        this._isDBOpen = false;
        return Promise.reject(`in getVersion ${err}`);
      }
    }
  }
  async isDBExists(database) {
    try {
      const isExists = await UtilsStore.isDBInStore(database, this.store);
      return Promise.resolve(isExists);
    } catch (err) {
      return Promise.reject(`in isDBExists ${err}`);
    }
  }
  async deleteDB(database) {
    try {
      const isExists = await this.isDBExists(database);
      if (isExists && !this._isDBOpen) {
        await this.open();
      }
      await this.close();
      if (isExists) {
        await UtilsStore.removeDBFromStore(database, this.store);
      }
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(new Error(`DeleteDB: ${err.message}`));
    }
  }
  async beginTransaction() {
    if (!this._isDBOpen) {
      let msg = `BeginTransaction: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    try {
      await UtilsSQLite.beginTransaction(this.mDb, true);
      this.setIsTransActive(true);
      return 0;
    } catch (err) {
      let msg = `BeginTransaction: ${err.message}`;
      return Promise.reject(new Error(`${msg}`));
    }
  }
  async commitTransaction() {
    if (!this._isDBOpen) {
      let msg = `CommitTransaction: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    try {
      await UtilsSQLite.commitTransaction(this.mDb, true);
      this.setIsTransActive(false);
      return 0;
    } catch (err) {
      let msg = `CommitTransaction: ${err.message}`;
      return Promise.reject(new Error(`${msg}`));
    }
  }
  async rollbackTransaction() {
    if (!this._isDBOpen) {
      let msg = `RollbackTransaction: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    try {
      await UtilsSQLite.rollbackTransaction(this.mDb, true);
      this.setIsTransActive(false);
      return 0;
    } catch (err) {
      let msg = `RollbackTransaction: ${err.message}`;
      return Promise.reject(new Error(`${msg}`));
    }
  }
  isTransActive() {
    return this.isTransactionActive;
  }
  setIsTransActive(value) {
    this.isTransactionActive = value;
  }
  async executeSQL(sql, transaction = true) {
    if (!this._isDBOpen) {
      let msg = `ExecuteSQL: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    let initChanges = -1;
    try {
      initChanges = await UtilsSQLite.dbChanges(this.mDb);
      if (transaction && !this.isTransactionActive) {
        await this.beginTransaction();
      }
    } catch (err) {
      let msg = `executeSQL: ${err.message}`;
      return Promise.reject(new Error(`${msg}`));
    }
    try {
      const mChanges = await UtilsSQLite.execute(this.mDb, sql, false);
      if (mChanges < 0) {
        return Promise.reject(new Error("ExecuteSQL: changes < 0"));
      }
      if (transaction && this.isTransactionActive) {
        await this.commitTransaction();
      }
      const changes = await UtilsSQLite.dbChanges(this.mDb) - initChanges;
      return Promise.resolve(changes);
    } catch (err) {
      let msg = `ExecuteSQL: ${err.message}`;
      try {
        if (transaction && this.isTransactionActive)
          await this.rollbackTransaction();
      } catch (err2) {
        msg += ` : ${err2.message}`;
      }
      return Promise.reject(new Error(`ExecuteSQL: ${msg}`));
    } finally {
      if (transaction)
        this.isTransactionActive = false;
      if (this.autoSave) {
        try {
          await this.saveToStore();
        } catch (err) {
          this._isDBOpen = false;
          return Promise.reject(`ExecuteSQL: ${err}`);
        }
      }
    }
  }
  async execSet(set, transaction = true, returnMode = "no") {
    if (!this._isDBOpen) {
      let msg = `ExecSet: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    const retRes = { changes: -1, lastId: -1 };
    let initChanges = -1;
    try {
      initChanges = await UtilsSQLite.dbChanges(this.mDb);
      if (transaction && !this.isTransactionActive) {
        await this.beginTransaction();
      }
    } catch (err) {
      let msg = `ExecSet: ${err.message}`;
      return Promise.reject(new Error(`${msg}`));
    }
    try {
      const retObj = await UtilsSQLite.executeSet(this.mDb, set, false, returnMode);
      let lastId2 = retObj["lastId"];
      if (lastId2 < 0) {
        return Promise.reject(new Error("ExecSet: changes < 0"));
      }
      if (transaction && this.isTransactionActive)
        await this.commitTransaction();
      const changes = await UtilsSQLite.dbChanges(this.mDb) - initChanges;
      retRes.changes = changes;
      retRes.lastId = lastId2;
      retRes.values = retObj["values"] ? retObj["values"] : [];
      return Promise.resolve(retRes);
    } catch (err) {
      let msg = `ExecSet: ${err.message}`;
      try {
        if (transaction && this.isTransactionActive)
          await this.rollbackTransaction();
      } catch (err2) {
        msg += ` : ${err2.message}`;
      }
      return Promise.reject(new Error(`ExecSet: ${msg}`));
    } finally {
      if (transaction)
        this.isTransactionActive = false;
      if (this.autoSave) {
        try {
          await this.saveToStore();
        } catch (err) {
          this._isDBOpen = false;
          return Promise.reject(`ExecSet: ${err}`);
        }
      }
    }
  }
  async selectSQL(sql, values) {
    if (!this._isDBOpen) {
      let msg = `SelectSQL: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    try {
      let retArr = await UtilsSQLite.queryAll(this.mDb, sql, values);
      return Promise.resolve(retArr);
    } catch (err) {
      return Promise.reject(new Error(`SelectSQL: ${err.message}`));
    }
  }
  async runSQL(statement, values, transaction = true, returnMode) {
    let lastId2 = -1;
    if (!this._isDBOpen) {
      let msg = `RunSQL: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    const retRes = { changes: -1, lastId: -1 };
    let initChanges = -1;
    try {
      initChanges = await UtilsSQLite.dbChanges(this.mDb);
      if (transaction && !this.isTransactionActive) {
        await this.beginTransaction();
      }
    } catch (err) {
      let msg = `RunSQL: ${err.message}`;
      return Promise.reject(new Error(`${msg}`));
    }
    try {
      const retObj = await UtilsSQLite.run(this.mDb, statement, values, false, returnMode);
      lastId2 = retObj["lastId"];
      if (lastId2 < 0) {
        return Promise.reject(new Error("RunSQL: lastId < 0"));
      }
      if (transaction && this.isTransactionActive) {
        await this.commitTransaction();
      }
      const changes = await UtilsSQLite.dbChanges(this.mDb) - initChanges;
      retRes.changes = changes;
      retRes.lastId = lastId2;
      retRes.values = retObj["values"] ? retObj["values"] : [];
      return Promise.resolve(retRes);
    } catch (err) {
      let msg = `RunSQL: ${err.message}`;
      try {
        if (transaction && this.isTransactionActive) {
          await this.rollbackTransaction();
        }
      } catch (err2) {
        msg += ` : ${err2.message}`;
      }
      return Promise.reject(new Error(`${msg}`));
    } finally {
      if (transaction)
        this.setIsTransActive(false);
      if (this.autoSave) {
        try {
          await this.saveToStore();
        } catch (err) {
          this._isDBOpen = false;
          return Promise.reject(`ExecSet: ${err}`);
        }
      }
    }
  }
  async getTableNames() {
    if (!this._isDBOpen) {
      let msg = `GetTableNames: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    try {
      let retArr = await UtilsSQLite.getTableList(this.mDb);
      return Promise.resolve(retArr);
    } catch (err) {
      return Promise.reject(new Error(`GetTableNames: ${err.message}`));
    }
  }
  async isTable(tableName) {
    if (!this._isDBOpen) {
      let msg = `isTable: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    try {
      const retB = await UtilsSQLite.isTableExists(this.mDb, tableName);
      return Promise.resolve(retB);
    } catch (err) {
      const msg = `IsTable: ${err.message}`;
      return Promise.reject(new Error(msg));
    }
  }
  async createSyncTable() {
    if (!this._isDBOpen) {
      let msg = `createSyncTable: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    let changes = -1;
    try {
      const retB = await UtilsSQLite.isTableExists(this.mDb, "sync_table");
      if (!retB) {
        const isLastMod = await UtilsSQLite.isLastModified(this.mDb, this._isDBOpen);
        const isDel = await UtilsSQLite.isSqlDeleted(this.mDb, this._isDBOpen);
        if (isLastMod && isDel) {
          const date = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
          let stmts = `
                          CREATE TABLE IF NOT EXISTS sync_table (
                              id INTEGER PRIMARY KEY NOT NULL,
                              sync_date INTEGER
                              );`;
          stmts += `INSERT INTO sync_table (sync_date) VALUES (
                              "${date}");`;
          changes = await UtilsSQLite.execute(this.mDb, stmts, false);
          return Promise.resolve(changes);
        } else {
          return Promise.reject(new Error("No last_modified/sql_deleted columns in tables"));
        }
      } else {
        return Promise.resolve(0);
      }
    } catch (err) {
      const msg = `CreateSyncTable: ${err.message}`;
      return Promise.reject(new Error(msg));
    }
  }
  async getSyncDate() {
    if (!this._isDBOpen) {
      let msg = `getSyncDate: Database ${this.dbName} `;
      msg += `not opened`;
      return Promise.reject(new Error(msg));
    }
    try {
      const isTable = await UtilsSQLite.isTableExists(this.mDb, "sync_table");
      if (!isTable) {
        return Promise.reject(new Error("No sync_table available"));
      }
      const res = await UtilsExportJSON.getSynchroDate(this.mDb);
      return Promise.resolve(res);
    } catch (err) {
      const msg = `getSyncDate: ${err.message}`;
      return Promise.reject(new Error(msg));
    }
  }
  async setSyncDate(syncDate) {
    if (!this._isDBOpen) {
      let msg = `SetSyncDate: Database ${this.dbName} `;
      msg += `not opened`;
      return { result: false, message: msg };
    }
    try {
      const isTable = await UtilsSQLite.isTableExists(this.mDb, "sync_table");
      if (!isTable) {
        return Promise.reject(new Error("No sync_table available"));
      }
      const sDate = Math.round(new Date(syncDate).getTime() / 1e3);
      let stmt = `UPDATE sync_table SET sync_date = `;
      stmt += `${sDate} WHERE id = 1;`;
      const changes = await UtilsSQLite.execute(this.mDb, stmt, false);
      if (changes < 0) {
        return { result: false, message: "setSyncDate failed" };
      } else {
        return { result: true };
      }
    } catch (err) {
      return { result: false, message: `setSyncDate failed: ${err.message}` };
    }
  }
  async importJson(jsonData, importProgress) {
    let changes = 0;
    if (this._isDBOpen) {
      try {
        await UtilsSQLite.setForeignKeyConstraintsEnabled(this.mDb, false);
        if (jsonData.tables && jsonData.tables.length > 0) {
          changes = await UtilsImportJSON.createDatabaseSchema(this, jsonData);
          let msg = `Schema creation completed changes: ${changes}`;
          importProgress.emit({ progress: msg });
          if (changes != -1) {
            changes += await UtilsImportJSON.createTablesData(this, jsonData, importProgress);
            let msg2 = `Tables data creation completed changes: ${changes}`;
            importProgress.emit({ progress: msg2 });
          }
        }
        if (jsonData.views && jsonData.views.length > 0) {
          changes += await UtilsImportJSON.createViews(this, jsonData);
        }
        await UtilsSQLite.setForeignKeyConstraintsEnabled(this.mDb, true);
        await this.saveToStore();
        return Promise.resolve(changes);
      } catch (err) {
        return Promise.reject(new Error(`ImportJson: ${err.message}`));
      }
    } else {
      return Promise.reject(new Error(`ImportJson: database is closed`));
    }
  }
  async exportJson(mode, exportProgress) {
    const inJson = {};
    inJson.database = this.dbName.slice(0, -9);
    inJson.version = this.version;
    inJson.encrypted = false;
    inJson.mode = mode;
    if (this._isDBOpen) {
      try {
        const isTable = await UtilsSQLite.isTableExists(this.mDb, "sync_table");
        if (isTable) {
          await UtilsExportJSON.setLastExportDate(this.mDb, (/* @__PURE__ */ new Date()).toISOString());
        } else {
          if (inJson.mode !== "full") {
            const msg = `No sync_table available for partial mode`;
            return Promise.reject(new Error(msg));
          }
        }
        const retJson = await UtilsExportJSON.createExportObject(this.mDb, inJson, exportProgress);
        const keys = Object.keys(retJson);
        if (keys.length === 0) {
          const msg = `ExportJson: return Object is empty No data to synchronize`;
          return Promise.reject(new Error(msg));
        }
        const isValid2 = UtilsJSON.isJsonSQLite(retJson);
        if (isValid2) {
          return Promise.resolve(retJson);
        } else {
          return Promise.reject(new Error(`ExportJson: retJson not valid`));
        }
      } catch (err) {
        return Promise.reject(new Error(`ExportJson: ${err.message}`));
      }
    } else {
      return Promise.reject(new Error(`ExportJson: database is closed`));
    }
  }
  async deleteExportedRows() {
    if (this._isDBOpen) {
      try {
        await UtilsExportJSON.delExportedRows(this.mDb);
        return Promise.resolve();
      } catch (err) {
        return Promise.reject(new Error(`deleteExportedRows: ${err.message}`));
      }
    } else {
      return Promise.reject(new Error(`deleteExportedRows: database is closed`));
    }
  }
}
var localforage = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(module, exports) {
  (function(f2) {
    {
      module.exports = f2();
    }
  })(function() {
    return function e2(t2, n2, r2) {
      function s2(o3, u2) {
        if (!n2[o3]) {
          if (!t2[o3]) {
            var a2 = typeof commonjsRequire == "function" && commonjsRequire;
            if (!u2 && a2)
              return a2(o3, true);
            if (i)
              return i(o3, true);
            var f2 = new Error("Cannot find module '" + o3 + "'");
            throw f2.code = "MODULE_NOT_FOUND", f2;
          }
          var l2 = n2[o3] = { exports: {} };
          t2[o3][0].call(l2.exports, function(e3) {
            var n3 = t2[o3][1][e3];
            return s2(n3 ? n3 : e3);
          }, l2, l2.exports, e2, t2, n2, r2);
        }
        return n2[o3].exports;
      }
      var i = typeof commonjsRequire == "function" && commonjsRequire;
      for (var o2 = 0; o2 < r2.length; o2++)
        s2(r2[o2]);
      return s2;
    }({ 1: [function(_dereq_, module2, exports2) {
      (function(global2) {
        var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick2);
            var element = global2.document.createTextNode("");
            observer.observe(element, {
              characterData: true
            });
            scheduleDrain = function() {
              element.data = called = ++called % 2;
            };
          } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
            var channel = new global2.MessageChannel();
            channel.port1.onmessage = nextTick2;
            scheduleDrain = function() {
              channel.port2.postMessage(0);
            };
          } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
            scheduleDrain = function() {
              var scriptEl = global2.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                nextTick2();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global2.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function() {
              setTimeout(nextTick2, 0);
            };
          }
        }
        var draining2;
        var queue2 = [];
        function nextTick2() {
          draining2 = true;
          var i, oldQueue;
          var len = queue2.length;
          while (len) {
            oldQueue = queue2;
            queue2 = [];
            i = -1;
            while (++i < len) {
              oldQueue[i]();
            }
            len = queue2.length;
          }
          draining2 = false;
        }
        module2.exports = immediate;
        function immediate(task) {
          if (queue2.push(task) === 1 && !draining2) {
            scheduleDrain();
          }
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 2: [function(_dereq_, module2, exports2) {
      var immediate = _dereq_(1);
      function INTERNAL() {
      }
      var handlers = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      module2.exports = Promise2;
      function Promise2(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }
      Promise2.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
      };
      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap(this.promise, this.onRejected, value);
      };
      function unwrap(promise, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e2) {
            return handlers.reject(promise, e2);
          }
          if (returnValue === promise) {
            handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers.resolve(promise, returnValue);
          }
        });
      }
      handlers.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers.reject = function(self2, error) {
        self2.state = REJECTED;
        self2.outcome = error;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callRejected(error);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e2) {
          out.status = "error";
          out.value = e2;
        }
        return out;
      }
      Promise2.resolve = resolve2;
      function resolve2(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject;
      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers.reject(promise, reason);
      }
      Promise2.all = all;
      function all(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i2) {
          self2.resolve(value).then(resolveFromAll, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
          function resolveFromAll(outValue) {
            values[i2] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers.resolve(promise, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          resolver(iterable[i]);
        }
        return promise;
        function resolver(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers.resolve(promise, response);
            }
          }, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
        }
      }
    }, { "1": 1 }], 3: [function(_dereq_, module2, exports2) {
      (function(global2) {
        if (typeof global2.Promise !== "function") {
          global2.Promise = _dereq_(2);
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "2": 2 }], 4: [function(_dereq_, module2, exports2) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function getIDB() {
        try {
          if (typeof indexedDB !== "undefined") {
            return indexedDB;
          }
          if (typeof webkitIndexedDB !== "undefined") {
            return webkitIndexedDB;
          }
          if (typeof mozIndexedDB !== "undefined") {
            return mozIndexedDB;
          }
          if (typeof OIndexedDB !== "undefined") {
            return OIndexedDB;
          }
          if (typeof msIndexedDB !== "undefined") {
            return msIndexedDB;
          }
        } catch (e2) {
          return;
        }
      }
      var idb = getIDB();
      function isIndexedDBValid() {
        try {
          if (!idb || !idb.open) {
            return false;
          }
          var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
          var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange !== "undefined";
        } catch (e2) {
          return false;
        }
      }
      function createBlob(parts, properties) {
        parts = parts || [];
        properties = properties || {};
        try {
          return new Blob(parts, properties);
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();
          for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
          }
          return builder.getBlob(properties.type);
        }
      }
      if (typeof Promise === "undefined") {
        _dereq_(3);
      }
      var Promise$1 = Promise;
      function executeCallback(promise, callback) {
        if (callback) {
          promise.then(function(result) {
            callback(null, result);
          }, function(error) {
            callback(error);
          });
        }
      }
      function executeTwoCallbacks(promise, callback, errorCallback) {
        if (typeof callback === "function") {
          promise.then(callback);
        }
        if (typeof errorCallback === "function") {
          promise["catch"](errorCallback);
        }
      }
      function normalizeKey(key2) {
        if (typeof key2 !== "string") {
          console.warn(key2 + " used as a key, but it is not a string.");
          key2 = String(key2);
        }
        return key2;
      }
      function getCallback() {
        if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
          return arguments[arguments.length - 1];
        }
      }
      var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
      var supportsBlobs = void 0;
      var dbContexts = {};
      var toString3 = Object.prototype.toString;
      var READ_ONLY = "readonly";
      var READ_WRITE = "readwrite";
      function _binStringToArrayBuffer(bin) {
        var length2 = bin.length;
        var buf = new ArrayBuffer(length2);
        var arr = new Uint8Array(buf);
        for (var i = 0; i < length2; i++) {
          arr[i] = bin.charCodeAt(i);
        }
        return buf;
      }
      function _checkBlobSupportWithoutCaching(idb2) {
        return new Promise$1(function(resolve2) {
          var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob([""]);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
          txn.onabort = function(e2) {
            e2.preventDefault();
            e2.stopPropagation();
            resolve2(false);
          };
          txn.oncomplete = function() {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
        })["catch"](function() {
          return false;
        });
      }
      function _checkBlobSupport(idb2) {
        if (typeof supportsBlobs === "boolean") {
          return Promise$1.resolve(supportsBlobs);
        }
        return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
          supportsBlobs = value;
          return supportsBlobs;
        });
      }
      function _deferReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = {};
        deferredOperation.promise = new Promise$1(function(resolve2, reject) {
          deferredOperation.resolve = resolve2;
          deferredOperation.reject = reject;
        });
        dbContext.deferredOperations.push(deferredOperation);
        if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
        } else {
          dbContext.dbReady = dbContext.dbReady.then(function() {
            return deferredOperation.promise;
          });
        }
      }
      function _advanceReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
        }
      }
      function _rejectReadiness(dbInfo, err) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
        }
      }
      function _getConnection(dbInfo, upgradeNeeded) {
        return new Promise$1(function(resolve2, reject) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
          if (dbInfo.db) {
            if (upgradeNeeded) {
              _deferReadiness(dbInfo);
              dbInfo.db.close();
            } else {
              return resolve2(dbInfo.db);
            }
          }
          var dbArgs = [dbInfo.name];
          if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
          }
          var openreq = idb.open.apply(idb, dbArgs);
          if (upgradeNeeded) {
            openreq.onupgradeneeded = function(e2) {
              var db2 = openreq.result;
              try {
                db2.createObjectStore(dbInfo.storeName);
                if (e2.oldVersion <= 1) {
                  db2.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                }
              } catch (ex) {
                if (ex.name === "ConstraintError") {
                  console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e2.oldVersion + " to version " + e2.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                } else {
                  throw ex;
                }
              }
            };
          }
          openreq.onerror = function(e2) {
            e2.preventDefault();
            reject(openreq.error);
          };
          openreq.onsuccess = function() {
            var db2 = openreq.result;
            db2.onversionchange = function(e2) {
              e2.target.close();
            };
            resolve2(db2);
            _advanceReadiness(dbInfo);
          };
        });
      }
      function _getOriginalConnection(dbInfo) {
        return _getConnection(dbInfo, false);
      }
      function _getUpgradedConnection(dbInfo) {
        return _getConnection(dbInfo, true);
      }
      function _isUpgradeNeeded(dbInfo, defaultVersion) {
        if (!dbInfo.db) {
          return true;
        }
        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
        var isDowngrade = dbInfo.version < dbInfo.db.version;
        var isUpgrade = dbInfo.version > dbInfo.db.version;
        if (isDowngrade) {
          if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
          }
          dbInfo.version = dbInfo.db.version;
        }
        if (isUpgrade || isNewStore) {
          if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
              dbInfo.version = incVersion;
            }
          }
          return true;
        }
        return false;
      }
      function _encodeBlob(blob) {
        return new Promise$1(function(resolve2, reject) {
          var reader = new FileReader();
          reader.onerror = reject;
          reader.onloadend = function(e2) {
            var base64 = btoa(e2.target.result || "");
            resolve2({
              __local_forage_encoded_blob: true,
              data: base64,
              type: blob.type
            });
          };
          reader.readAsBinaryString(blob);
        });
      }
      function _decodeBlob(encodedBlob) {
        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
        return createBlob([arrayBuff], { type: encodedBlob.type });
      }
      function _isEncodedBlob(value) {
        return value && value.__local_forage_encoded_blob;
      }
      function _fullyReady(callback) {
        var self2 = this;
        var promise = self2._initReady().then(function() {
          var dbContext = dbContexts[self2._dbInfo.name];
          if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
          }
        });
        executeTwoCallbacks(promise, callback, callback);
        return promise;
      }
      function _tryReconnect(dbInfo) {
        _deferReadiness(dbInfo);
        var dbContext = dbContexts[dbInfo.name];
        var forages = dbContext.forages;
        for (var i = 0; i < forages.length; i++) {
          var forage = forages[i];
          if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
          }
        }
        dbInfo.db = null;
        return _getOriginalConnection(dbInfo).then(function(db2) {
          dbInfo.db = db2;
          if (_isUpgradeNeeded(dbInfo)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db2;
        }).then(function(db2) {
          dbInfo.db = dbContext.db = db2;
          for (var i2 = 0; i2 < forages.length; i2++) {
            forages[i2]._dbInfo.db = db2;
          }
        })["catch"](function(err) {
          _rejectReadiness(dbInfo, err);
          throw err;
        });
      }
      function createTransaction(dbInfo, mode, callback, retries) {
        if (retries === void 0) {
          retries = 1;
        }
        try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
        } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
            return Promise$1.resolve().then(function() {
              if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                if (dbInfo.db) {
                  dbInfo.version = dbInfo.db.version + 1;
                }
                return _getUpgradedConnection(dbInfo);
              }
            }).then(function() {
              return _tryReconnect(dbInfo).then(function() {
                createTransaction(dbInfo, mode, callback, retries - 1);
              });
            })["catch"](callback);
          }
          callback(err);
        }
      }
      function createDbContext() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function _initStorage(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }
        var dbContext = dbContexts[dbInfo.name];
        if (!dbContext) {
          dbContext = createDbContext();
          dbContexts[dbInfo.name] = dbContext;
        }
        dbContext.forages.push(self2);
        if (!self2._initReady) {
          self2._initReady = self2.ready;
          self2.ready = _fullyReady;
        }
        var initPromises = [];
        function ignoreErrors() {
          return Promise$1.resolve();
        }
        for (var j = 0; j < dbContext.forages.length; j++) {
          var forage = dbContext.forages[j];
          if (forage !== self2) {
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
        }
        var forages = dbContext.forages.slice(0);
        return Promise$1.all(initPromises).then(function() {
          dbInfo.db = dbContext.db;
          return _getOriginalConnection(dbInfo);
        }).then(function(db2) {
          dbInfo.db = db2;
          if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db2;
        }).then(function(db2) {
          dbInfo.db = dbContext.db = db2;
          self2._dbInfo = dbInfo;
          for (var k2 = 0; k2 < forages.length; k2++) {
            var forage2 = forages[k2];
            if (forage2 !== self2) {
              forage2._dbInfo.db = dbInfo.db;
              forage2._dbInfo.version = dbInfo.version;
            }
          }
        });
      }
      function getItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.get(key2);
                req.onsuccess = function() {
                  var value = req.result;
                  if (value === void 0) {
                    value = null;
                  }
                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }
                  resolve2(value);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate(iterator, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openCursor();
                var iterationNumber = 1;
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (cursor) {
                    var value = cursor.value;
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    var result = iterator(value, cursor.key, iterationNumber++);
                    if (result !== void 0) {
                      resolve2(result);
                    } else {
                      cursor["continue"]();
                    }
                  } else {
                    resolve2();
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          var dbInfo;
          self2.ready().then(function() {
            dbInfo = self2._dbInfo;
            if (toString3.call(value) === "[object Blob]") {
              return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                if (blobSupport) {
                  return value;
                }
                return _encodeBlob(value);
              });
            }
            return value;
          }).then(function(value2) {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                if (value2 === null) {
                  value2 = void 0;
                }
                var req = store.put(value2, key2);
                transaction.oncomplete = function() {
                  if (value2 === void 0) {
                    value2 = null;
                  }
                  resolve2(value2);
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store["delete"](key2);
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onerror = function() {
                  reject(req.error);
                };
                transaction.onabort = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.clear();
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.count();
                req.onsuccess = function() {
                  resolve2(req.result);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key(n2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          if (n2 < 0) {
            resolve2(null);
            return;
          }
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var advanced = false;
                var req = store.openKeyCursor();
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(null);
                    return;
                  }
                  if (n2 === 0) {
                    resolve2(cursor.key);
                  } else {
                    if (!advanced) {
                      advanced = true;
                      cursor.advance(n2);
                    } else {
                      resolve2(cursor.key);
                    }
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openKeyCursor();
                var keys2 = [];
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(keys2);
                    return;
                  }
                  keys2.push(cursor.key);
                  cursor["continue"]();
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
          var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db2) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db2;
            for (var i = 0; i < forages.length; i++) {
              forages[i]._dbInfo.db = db2;
            }
            return db2;
          });
          if (!options.storeName) {
            promise = dbPromise.then(function(db2) {
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db2.close();
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
              }
              var dropDBPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.deleteDatabase(options.name);
                req.onerror = function() {
                  var db3 = req.result;
                  if (db3) {
                    db3.close();
                  }
                  reject(req.error);
                };
                req.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                };
                req.onsuccess = function() {
                  var db3 = req.result;
                  if (db3) {
                    db3.close();
                  }
                  resolve2(db3);
                };
              });
              return dropDBPromise.then(function(db3) {
                dbContext.db = db3;
                for (var i2 = 0; i2 < forages.length; i2++) {
                  var _forage = forages[i2];
                  _advanceReadiness(_forage._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          } else {
            promise = dbPromise.then(function(db2) {
              if (!db2.objectStoreNames.contains(options.storeName)) {
                return;
              }
              var newVersion = db2.version + 1;
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db2.close();
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
                forage._dbInfo.version = newVersion;
              }
              var dropObjectPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.open(options.name, newVersion);
                req.onerror = function(err) {
                  var db3 = req.result;
                  db3.close();
                  reject(err);
                };
                req.onupgradeneeded = function() {
                  var db3 = req.result;
                  db3.deleteObjectStore(options.storeName);
                };
                req.onsuccess = function() {
                  var db3 = req.result;
                  db3.close();
                  resolve2(db3);
                };
              });
              return dropObjectPromise.then(function(db3) {
                dbContext.db = db3;
                for (var j = 0; j < forages.length; j++) {
                  var _forage2 = forages[j];
                  _forage2._dbInfo.db = db3;
                  _advanceReadiness(_forage2._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          }
        }
        executeCallback(promise, callback);
        return promise;
      }
      var asyncStorage = {
        _driver: "asyncStorage",
        _initStorage,
        _support: isIndexedDBValid(),
        iterate,
        getItem,
        setItem,
        removeItem,
        clear,
        length,
        key,
        keys,
        dropInstance
      };
      function isWebSQLValid() {
        return typeof openDatabase === "function";
      }
      var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var BLOB_TYPE_PREFIX = "~~local_forage_type~";
      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
      var SERIALIZED_MARKER = "__lfsc__:";
      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
      var TYPE_ARRAYBUFFER = "arbf";
      var TYPE_BLOB = "blob";
      var TYPE_INT8ARRAY = "si08";
      var TYPE_UINT8ARRAY = "ui08";
      var TYPE_UINT8CLAMPEDARRAY = "uic8";
      var TYPE_INT16ARRAY = "si16";
      var TYPE_INT32ARRAY = "si32";
      var TYPE_UINT16ARRAY = "ur16";
      var TYPE_UINT32ARRAY = "ui32";
      var TYPE_FLOAT32ARRAY = "fl32";
      var TYPE_FLOAT64ARRAY = "fl64";
      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
      var toString$1 = Object.prototype.toString;
      function stringToBuffer(serializedString) {
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i;
        var p2 = 0;
        var encoded1, encoded2, encoded3, encoded4;
        if (serializedString[serializedString.length - 1] === "=") {
          bufferLength--;
          if (serializedString[serializedString.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer);
        for (i = 0; i < len; i += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
          bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      }
      function bufferToString(buffer) {
        var bytes = new Uint8Array(buffer);
        var base64String = "";
        var i;
        for (i = 0; i < bytes.length; i += 3) {
          base64String += BASE_CHARS[bytes[i] >> 2];
          base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
          base64String += BASE_CHARS[bytes[i + 2] & 63];
        }
        if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + "=";
        } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + "==";
        }
        return base64String;
      }
      function serialize(value, callback) {
        var valueType = "";
        if (value) {
          valueType = toString$1.call(value);
        }
        if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
          var buffer;
          var marker = SERIALIZED_MARKER;
          if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
          } else {
            buffer = value.buffer;
            if (valueType === "[object Int8Array]") {
              marker += TYPE_INT8ARRAY;
            } else if (valueType === "[object Uint8Array]") {
              marker += TYPE_UINT8ARRAY;
            } else if (valueType === "[object Uint8ClampedArray]") {
              marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === "[object Int16Array]") {
              marker += TYPE_INT16ARRAY;
            } else if (valueType === "[object Uint16Array]") {
              marker += TYPE_UINT16ARRAY;
            } else if (valueType === "[object Int32Array]") {
              marker += TYPE_INT32ARRAY;
            } else if (valueType === "[object Uint32Array]") {
              marker += TYPE_UINT32ARRAY;
            } else if (valueType === "[object Float32Array]") {
              marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === "[object Float64Array]") {
              marker += TYPE_FLOAT64ARRAY;
            } else {
              callback(new Error("Failed to get type for BinaryArray"));
            }
          }
          callback(marker + bufferToString(buffer));
        } else if (valueType === "[object Blob]") {
          var fileReader = new FileReader();
          fileReader.onload = function() {
            var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };
          fileReader.readAsArrayBuffer(value);
        } else {
          try {
            callback(JSON.stringify(value));
          } catch (e2) {
            console.error("Couldn't convert value into a JSON string: ", value);
            callback(null, e2);
          }
        }
      }
      function deserialize(value) {
        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
        }
        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
        var blobType;
        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
        }
        var buffer = stringToBuffer(serializedString);
        switch (type) {
          case TYPE_ARRAYBUFFER:
            return buffer;
          case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
          case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
          case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
          case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
          case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
          case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
          case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
          case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
          case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
          case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
          default:
            throw new Error("Unkown type: " + type);
        }
      }
      var localforageSerializer = {
        serialize,
        deserialize,
        stringToBuffer,
        bufferToString
      };
      function createDbTable(t2, dbInfo, callback, errorCallback) {
        t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
      }
      function _initStorage$1(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i in options) {
            dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
          }
        }
        var dbInfoPromise = new Promise$1(function(resolve2, reject) {
          try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e2) {
            return reject(e2);
          }
          dbInfo.db.transaction(function(t2) {
            createDbTable(t2, dbInfo, function() {
              self2._dbInfo = dbInfo;
              resolve2();
            }, function(t3, error) {
              reject(error);
            });
          }, reject);
        });
        dbInfo.serializer = localforageSerializer;
        return dbInfoPromise;
      }
      function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback, errorCallback) {
        t2.executeSql(sqlStatement, args, callback, function(t3, error) {
          if (error.code === error.SYNTAX_ERR) {
            t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t4, results) {
              if (!results.rows.length) {
                createDbTable(t4, dbInfo, function() {
                  t4.executeSql(sqlStatement, args, callback, errorCallback);
                }, errorCallback);
              } else {
                errorCallback(t4, error);
              }
            }, errorCallback);
          } else {
            errorCallback(t3, error);
          }
        }, errorCallback);
      }
      function getItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t3, results) {
                var result = results.rows.length ? results.rows.item(0).value : null;
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                resolve2(result);
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$1(iterator, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                var rows = results.rows;
                var length2 = rows.length;
                for (var i = 0; i < length2; i++) {
                  var item = rows.item(i);
                  var result = item.value;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  result = iterator(result, item.key, i + 1);
                  if (result !== void 0) {
                    resolve2(result);
                    return;
                  }
                }
                resolve2();
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function _setItem(key2, value, callback, retriesLeft) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                dbInfo.db.transaction(function(t2) {
                  tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                    resolve2(originalValue);
                  }, function(t3, error2) {
                    reject(error2);
                  });
                }, function(sqlError) {
                  if (sqlError.code === sqlError.QUOTA_ERR) {
                    if (retriesLeft > 0) {
                      resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                      return;
                    }
                    reject(sqlError);
                  }
                });
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$1(key2, value, callback) {
        return _setItem.apply(this, [key2, value, callback, 1]);
      }
      function removeItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                resolve2();
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                resolve2();
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                var result = results.rows.item(0).c;
                resolve2(result);
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$1(n2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n2 + 1], function(t3, results) {
                var result = results.rows.length ? results.rows.item(0).key : null;
                resolve2(result);
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                var keys2 = [];
                for (var i = 0; i < results.rows.length; i++) {
                  keys2.push(results.rows.item(i).key);
                }
                resolve2(keys2);
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getAllStoreNames(db2) {
        return new Promise$1(function(resolve2, reject) {
          db2.transaction(function(t2) {
            t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
              var storeNames = [];
              for (var i = 0; i < results.rows.length; i++) {
                storeNames.push(results.rows.item(i).name);
              }
              resolve2({
                db: db2,
                storeNames
              });
            }, function(t3, error) {
              reject(error);
            });
          }, function(sqlError) {
            reject(sqlError);
          });
        });
      }
      function dropInstance$1(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            var db2;
            if (options.name === currentConfig.name) {
              db2 = self2._dbInfo.db;
            } else {
              db2 = openDatabase(options.name, "", "", 0);
            }
            if (!options.storeName) {
              resolve2(getAllStoreNames(db2));
            } else {
              resolve2({
                db: db2,
                storeNames: [options.storeName]
              });
            }
          }).then(function(operationInfo) {
            return new Promise$1(function(resolve2, reject) {
              operationInfo.db.transaction(function(t2) {
                function dropTable(storeName) {
                  return new Promise$1(function(resolve3, reject2) {
                    t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                      resolve3();
                    }, function(t3, error) {
                      reject2(error);
                    });
                  });
                }
                var operations = [];
                for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                  operations.push(dropTable(operationInfo.storeNames[i]));
                }
                Promise$1.all(operations).then(function() {
                  resolve2();
                })["catch"](function(e2) {
                  reject(e2);
                });
              }, function(sqlError) {
                reject(sqlError);
              });
            });
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var webSQLStorage = {
        _driver: "webSQLStorage",
        _initStorage: _initStorage$1,
        _support: isWebSQLValid(),
        iterate: iterate$1,
        getItem: getItem$1,
        setItem: setItem$1,
        removeItem: removeItem$1,
        clear: clear$1,
        length: length$1,
        key: key$1,
        keys: keys$1,
        dropInstance: dropInstance$1
      };
      function isLocalStorageValid() {
        try {
          return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch (e2) {
          return false;
        }
      }
      function _getKeyPrefix(options, defaultConfig) {
        var keyPrefix = options.name + "/";
        if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + "/";
        }
        return keyPrefix;
      }
      function checkIfLocalStorageThrows() {
        var localStorageTestKey = "_localforage_support_test";
        try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);
          return false;
        } catch (e2) {
          return true;
        }
      }
      function _isLocalStorageUsable() {
        return !checkIfLocalStorageThrows() || localStorage.length > 0;
      }
      function _initStorage$2(options) {
        var self2 = this;
        var dbInfo = {};
        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }
        dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
        if (!_isLocalStorageUsable()) {
          return Promise$1.reject();
        }
        self2._dbInfo = dbInfo;
        dbInfo.serializer = localforageSerializer;
        return Promise$1.resolve();
      }
      function clear$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var keyPrefix = self2._dbInfo.keyPrefix;
          for (var i = localStorage.length - 1; i >= 0; i--) {
            var key2 = localStorage.key(i);
            if (key2.indexOf(keyPrefix) === 0) {
              localStorage.removeItem(key2);
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key2);
          if (result) {
            result = dbInfo.serializer.deserialize(result);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$2(iterator, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length2 = localStorage.length;
          var iterationNumber = 1;
          for (var i = 0; i < length2; i++) {
            var key2 = localStorage.key(i);
            if (key2.indexOf(keyPrefix) !== 0) {
              continue;
            }
            var value = localStorage.getItem(key2);
            if (value) {
              value = dbInfo.serializer.deserialize(value);
            }
            value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
              return value;
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$2(n2, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result;
          try {
            result = localStorage.key(n2);
          } catch (error) {
            result = null;
          }
          if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var length2 = localStorage.length;
          var keys2 = [];
          for (var i = 0; i < length2; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
              keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
          }
          return keys2;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$2(callback) {
        var self2 = this;
        var promise = self2.keys().then(function(keys2) {
          return keys2.length;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key2);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$2(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          if (value === void 0) {
            value = null;
          }
          var originalValue = value;
          return new Promise$1(function(resolve2, reject) {
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                try {
                  localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                  resolve2(originalValue);
                } catch (e2) {
                  if (e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                    reject(e2);
                  }
                  reject(e2);
                }
              }
            });
          });
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance$2(options, callback) {
        callback = getCallback.apply(this, arguments);
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            if (!options.storeName) {
              resolve2(options.name + "/");
            } else {
              resolve2(_getKeyPrefix(options, self2._defaultConfig));
            }
          }).then(function(keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var localStorageWrapper = {
        _driver: "localStorageWrapper",
        _initStorage: _initStorage$2,
        _support: isLocalStorageValid(),
        iterate: iterate$2,
        getItem: getItem$2,
        setItem: setItem$2,
        removeItem: removeItem$2,
        clear: clear$2,
        length: length$2,
        key: key$2,
        keys: keys$2,
        dropInstance: dropInstance$2
      };
      var sameValue = function sameValue2(x2, y2) {
        return x2 === y2 || typeof x2 === "number" && typeof y2 === "number" && isNaN(x2) && isNaN(y2);
      };
      var includes2 = function includes3(array, searchElement) {
        var len = array.length;
        var i = 0;
        while (i < len) {
          if (sameValue(array[i], searchElement)) {
            return true;
          }
          i++;
        }
        return false;
      };
      var isArray2 = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
      var DefinedDrivers = {};
      var DriverSupport = {};
      var DefaultDrivers = {
        INDEXEDDB: asyncStorage,
        WEBSQL: webSQLStorage,
        LOCALSTORAGE: localStorageWrapper
      };
      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
      var OptionalDriverMethods = ["dropInstance"];
      var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
      var DefaultConfig = {
        description: "",
        driver: DefaultDriverOrder.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function() {
          var _args = arguments;
          return localForageInstance.ready().then(function() {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
        };
      }
      function extend() {
        for (var i = 1; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            for (var _key in arg) {
              if (arg.hasOwnProperty(_key)) {
                if (isArray2(arg[_key])) {
                  arguments[0][_key] = arg[_key].slice();
                } else {
                  arguments[0][_key] = arg[_key];
                }
              }
            }
          }
        }
        return arguments[0];
      }
      var LocalForage = function() {
        function LocalForage2(options) {
          _classCallCheck(this, LocalForage2);
          for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
              var driver = DefaultDrivers[driverTypeKey];
              var driverName = driver._driver;
              this[driverTypeKey] = driverName;
              if (!DefinedDrivers[driverName]) {
                this.defineDriver(driver);
              }
            }
          }
          this._defaultConfig = extend({}, DefaultConfig);
          this._config = extend({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;
          this._wrapLibraryMethodsWithReady();
          this.setDriver(this._config.driver)["catch"](function() {
          });
        }
        LocalForage2.prototype.config = function config2(options) {
          if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
            if (this._ready) {
              return new Error("Can't call config() after localforage has been used.");
            }
            for (var i in options) {
              if (i === "storeName") {
                options[i] = options[i].replace(/\W/g, "_");
              }
              if (i === "version" && typeof options[i] !== "number") {
                return new Error("Database version must be a number.");
              }
              this._config[i] = options[i];
            }
            if ("driver" in options && options.driver) {
              return this.setDriver(this._config.driver);
            }
            return true;
          } else if (typeof options === "string") {
            return this._config[options];
          } else {
            return this._config;
          }
        };
        LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise = new Promise$1(function(resolve2, reject) {
            try {
              var driverName = driverObject._driver;
              var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!driverObject._driver) {
                reject(complianceError);
                return;
              }
              var driverMethods = LibraryMethods.concat("_initStorage");
              for (var i = 0, len = driverMethods.length; i < len; i++) {
                var driverMethodName = driverMethods[i];
                var isRequired = !includes2(OptionalDriverMethods, driverMethodName);
                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                  reject(complianceError);
                  return;
                }
              }
              var configureMissingMethods = function configureMissingMethods2() {
                var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                  return function() {
                    var error = new Error("Method " + methodName + " is not implemented by the current driver");
                    var promise2 = Promise$1.reject(error);
                    executeCallback(promise2, arguments[arguments.length - 1]);
                    return promise2;
                  };
                };
                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                  var optionalDriverMethod = OptionalDriverMethods[_i];
                  if (!driverObject[optionalDriverMethod]) {
                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                  }
                }
              };
              configureMissingMethods();
              var setDriverSupport = function setDriverSupport2(support) {
                if (DefinedDrivers[driverName]) {
                  console.info("Redefining LocalForage driver: " + driverName);
                }
                DefinedDrivers[driverName] = driverObject;
                DriverSupport[driverName] = support;
                resolve2();
              };
              if ("_support" in driverObject) {
                if (driverObject._support && typeof driverObject._support === "function") {
                  driverObject._support().then(setDriverSupport, reject);
                } else {
                  setDriverSupport(!!driverObject._support);
                }
              } else {
                setDriverSupport(true);
              }
            } catch (e2) {
              reject(e2);
            }
          });
          executeTwoCallbacks(promise, callback, errorCallback);
          return promise;
        };
        LocalForage2.prototype.driver = function driver() {
          return this._driver || null;
        };
        LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
        };
        LocalForage2.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$1.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
        };
        LocalForage2.prototype.ready = function ready(callback) {
          var self2 = this;
          var promise = self2._driverSet.then(function() {
            if (self2._ready === null) {
              self2._ready = self2._initDriver();
            }
            return self2._ready;
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        };
        LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self2 = this;
          if (!isArray2(drivers)) {
            drivers = [drivers];
          }
          var supportedDrivers = this._getSupportedDrivers(drivers);
          function setDriverToConfig() {
            self2._config.driver = self2.driver();
          }
          function extendSelfWithDriver(driver) {
            self2._extend(driver);
            setDriverToConfig();
            self2._ready = self2._initStorage(self2._config);
            return self2._ready;
          }
          function initDriver(supportedDrivers2) {
            return function() {
              var currentDriverIndex = 0;
              function driverPromiseLoop() {
                while (currentDriverIndex < supportedDrivers2.length) {
                  var driverName = supportedDrivers2[currentDriverIndex];
                  currentDriverIndex++;
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                }
                setDriverToConfig();
                var error = new Error("No available storage method found.");
                self2._driverSet = Promise$1.reject(error);
                return self2._driverSet;
              }
              return driverPromiseLoop();
            };
          }
          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
            return Promise$1.resolve();
          }) : Promise$1.resolve();
          this._driverSet = oldDriverSetDone.then(function() {
            var driverName = supportedDrivers[0];
            self2._dbInfo = null;
            self2._ready = null;
            return self2.getDriver(driverName).then(function(driver) {
              self2._driver = driver._driver;
              setDriverToConfig();
              self2._wrapLibraryMethodsWithReady();
              self2._initDriver = initDriver(supportedDrivers);
            });
          })["catch"](function() {
            setDriverToConfig();
            var error = new Error("No available storage method found.");
            self2._driverSet = Promise$1.reject(error);
            return self2._driverSet;
          });
          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
        };
        LocalForage2.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
        };
        LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend(this, libraryMethodsAndProperties);
        };
        LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];
          for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
              supportedDrivers.push(driverName);
            }
          }
          return supportedDrivers;
        };
        LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
          }
        };
        LocalForage2.prototype.createInstance = function createInstance(options) {
          return new LocalForage2(options);
        };
        return LocalForage2;
      }();
      var localforage_js = new LocalForage();
      module2.exports = localforage_js;
    }, { "3": 3 }] }, {}, [4])(4);
  });
})(localforage);
const localForage = localforage.exports;
var jszip_min = { exports: {} };
(function(module, exports) {
  !function(e2) {
    module.exports = e2();
  }(function() {
    return function s2(a2, o2, h2) {
      function u2(r2, e3) {
        if (!o2[r2]) {
          if (!a2[r2]) {
            var t2 = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e3 && t2)
              return t2(r2, true);
            if (l2)
              return l2(r2, true);
            var n2 = new Error("Cannot find module '" + r2 + "'");
            throw n2.code = "MODULE_NOT_FOUND", n2;
          }
          var i = o2[r2] = { exports: {} };
          a2[r2][0].call(i.exports, function(e4) {
            var t3 = a2[r2][1][e4];
            return u2(t3 || e4);
          }, i, i.exports, s2, a2, o2, h2);
        }
        return o2[r2].exports;
      }
      for (var l2 = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < h2.length; e2++)
        u2(h2[e2]);
      return u2;
    }({ 1: [function(e2, t2, r2) {
      var d2 = e2("./utils"), c2 = e2("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r2.encode = function(e3) {
        for (var t3, r3, n2, i, s2, a2, o2, h2 = [], u2 = 0, l2 = e3.length, f2 = l2, c3 = "string" !== d2.getTypeOf(e3); u2 < e3.length; )
          f2 = l2 - u2, n2 = c3 ? (t3 = e3[u2++], r3 = u2 < l2 ? e3[u2++] : 0, u2 < l2 ? e3[u2++] : 0) : (t3 = e3.charCodeAt(u2++), r3 = u2 < l2 ? e3.charCodeAt(u2++) : 0, u2 < l2 ? e3.charCodeAt(u2++) : 0), i = t3 >> 2, s2 = (3 & t3) << 4 | r3 >> 4, a2 = 1 < f2 ? (15 & r3) << 2 | n2 >> 6 : 64, o2 = 2 < f2 ? 63 & n2 : 64, h2.push(p2.charAt(i) + p2.charAt(s2) + p2.charAt(a2) + p2.charAt(o2));
        return h2.join("");
      }, r2.decode = function(e3) {
        var t3, r3, n2, i, s2, a2, o2 = 0, h2 = 0, u2 = "data:";
        if (e3.substr(0, u2.length) === u2)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l2, f2 = 3 * (e3 = e3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (e3.charAt(e3.length - 1) === p2.charAt(64) && f2--, e3.charAt(e3.length - 2) === p2.charAt(64) && f2--, f2 % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l2 = c2.uint8array ? new Uint8Array(0 | f2) : new Array(0 | f2); o2 < e3.length; )
          t3 = p2.indexOf(e3.charAt(o2++)) << 2 | (i = p2.indexOf(e3.charAt(o2++))) >> 4, r3 = (15 & i) << 4 | (s2 = p2.indexOf(e3.charAt(o2++))) >> 2, n2 = (3 & s2) << 6 | (a2 = p2.indexOf(e3.charAt(o2++))), l2[h2++] = t3, 64 !== s2 && (l2[h2++] = r3), 64 !== a2 && (l2[h2++] = n2);
        return l2;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t2, r2) {
      var n2 = e2("./external"), i = e2("./stream/DataWorker"), s2 = e2("./stream/Crc32Probe"), a2 = e2("./stream/DataLengthProbe");
      function o2(e3, t3, r3, n3, i2) {
        this.compressedSize = e3, this.uncompressedSize = t3, this.crc32 = r3, this.compression = n3, this.compressedContent = i2;
      }
      o2.prototype = { getContentWorker: function() {
        var e3 = new i(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a2("data_length")), t3 = this;
        return e3.on("end", function() {
          if (this.streamInfo.data_length !== t3.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), e3;
      }, getCompressedWorker: function() {
        return new i(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o2.createWorkerFrom = function(e3, t3, r3) {
        return e3.pipe(new s2()).pipe(new a2("uncompressedSize")).pipe(t3.compressWorker(r3)).pipe(new a2("compressedSize")).withStreamInfo("compression", t3);
      }, t2.exports = o2;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t2, r2) {
      var n2 = e2("./stream/GenericWorker");
      r2.STORE = { magic: "\0\0", compressWorker: function() {
        return new n2("STORE compression");
      }, uncompressWorker: function() {
        return new n2("STORE decompression");
      } }, r2.DEFLATE = e2("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t2, r2) {
      var n2 = e2("./utils");
      var o2 = function() {
        for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
          e3 = r3;
          for (var n3 = 0; n3 < 8; n3++)
            e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
          t3[r3] = e3;
        }
        return t3;
      }();
      t2.exports = function(e3, t3) {
        return void 0 !== e3 && e3.length ? "string" !== n2.getTypeOf(e3) ? function(e4, t4, r3, n3) {
          var i = o2, s2 = n3 + r3;
          e4 ^= -1;
          for (var a2 = n3; a2 < s2; a2++)
            e4 = e4 >>> 8 ^ i[255 & (e4 ^ t4[a2])];
          return -1 ^ e4;
        }(0 | t3, e3, e3.length, 0) : function(e4, t4, r3, n3) {
          var i = o2, s2 = n3 + r3;
          e4 ^= -1;
          for (var a2 = n3; a2 < s2; a2++)
            e4 = e4 >>> 8 ^ i[255 & (e4 ^ t4.charCodeAt(a2))];
          return -1 ^ e4;
        }(0 | t3, e3, e3.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e2, t2, r2) {
      r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
    }, {}], 6: [function(e2, t2, r2) {
      var n2 = null;
      n2 = "undefined" != typeof Promise ? Promise : e2("lie"), t2.exports = { Promise: n2 };
    }, { lie: 37 }], 7: [function(e2, t2, r2) {
      var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e2("pako"), s2 = e2("./utils"), a2 = e2("./stream/GenericWorker"), o2 = n2 ? "uint8array" : "array";
      function h2(e3, t3) {
        a2.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t3, this.meta = {};
      }
      r2.magic = "\b\0", s2.inherits(h2, a2), h2.prototype.processChunk = function(e3) {
        this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s2.transformTo(o2, e3.data), false);
      }, h2.prototype.flush = function() {
        a2.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
      }, h2.prototype.cleanUp = function() {
        a2.prototype.cleanUp.call(this), this._pako = null;
      }, h2.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t3 = this;
        this._pako.onData = function(e3) {
          t3.push({ data: e3, meta: t3.meta });
        };
      }, r2.compressWorker = function(e3) {
        return new h2("Deflate", e3);
      }, r2.uncompressWorker = function() {
        return new h2("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t2, r2) {
      function A2(e3, t3) {
        var r3, n3 = "";
        for (r3 = 0; r3 < t3; r3++)
          n3 += String.fromCharCode(255 & e3), e3 >>>= 8;
        return n3;
      }
      function n2(e3, t3, r3, n3, i2, s3) {
        var a2, o2, h2 = e3.file, u2 = e3.compression, l2 = s3 !== O2.utf8encode, f2 = I2.transformTo("string", s3(h2.name)), c2 = I2.transformTo("string", O2.utf8encode(h2.name)), d2 = h2.comment, p2 = I2.transformTo("string", s3(d2)), m2 = I2.transformTo("string", O2.utf8encode(d2)), _ = c2.length !== h2.name.length, g = m2.length !== d2.length, b2 = "", v2 = "", y2 = "", w2 = h2.dir, k2 = h2.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        t3 && !r3 || (x2.crc32 = e3.crc32, x2.compressedSize = e3.compressedSize, x2.uncompressedSize = e3.uncompressedSize);
        var S2 = 0;
        t3 && (S2 |= 8), l2 || !_ && !g || (S2 |= 2048);
        var z2 = 0, C2 = 0;
        w2 && (z2 |= 16), "UNIX" === i2 ? (C2 = 798, z2 |= function(e4, t4) {
          var r4 = e4;
          return e4 || (r4 = t4 ? 16893 : 33204), (65535 & r4) << 16;
        }(h2.unixPermissions, w2)) : (C2 = 20, z2 |= function(e4) {
          return 63 & (e4 || 0);
        }(h2.dosPermissions)), a2 = k2.getUTCHours(), a2 <<= 6, a2 |= k2.getUTCMinutes(), a2 <<= 5, a2 |= k2.getUTCSeconds() / 2, o2 = k2.getUTCFullYear() - 1980, o2 <<= 4, o2 |= k2.getUTCMonth() + 1, o2 <<= 5, o2 |= k2.getUTCDate(), _ && (v2 = A2(1, 1) + A2(B2(f2), 4) + c2, b2 += "up" + A2(v2.length, 2) + v2), g && (y2 = A2(1, 1) + A2(B2(p2), 4) + m2, b2 += "uc" + A2(y2.length, 2) + y2);
        var E2 = "";
        return E2 += "\n\0", E2 += A2(S2, 2), E2 += u2.magic, E2 += A2(a2, 2), E2 += A2(o2, 2), E2 += A2(x2.crc32, 4), E2 += A2(x2.compressedSize, 4), E2 += A2(x2.uncompressedSize, 4), E2 += A2(f2.length, 2), E2 += A2(b2.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E2 + f2 + b2, dirRecord: R2.CENTRAL_FILE_HEADER + A2(C2, 2) + E2 + A2(p2.length, 2) + "\0\0\0\0" + A2(z2, 4) + A2(n3, 4) + f2 + b2 + p2 };
      }
      var I2 = e2("../utils"), i = e2("../stream/GenericWorker"), O2 = e2("../utf8"), B2 = e2("../crc32"), R2 = e2("../signature");
      function s2(e3, t3, r3, n3) {
        i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r3, this.encodeFileName = n3, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I2.inherits(s2, i), s2.prototype.push = function(e3) {
        var t3 = e3.meta.percent || 0, r3 = this.entriesCount, n3 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, i.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r3 ? (t3 + 100 * (r3 - n3 - 1)) / r3 : 100 } }));
      }, s2.prototype.openedSource = function(e3) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
        var t3 = this.streamFiles && !e3.file.dir;
        if (t3) {
          var r3 = n2(e3, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r3.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s2.prototype.closedSource = function(e3) {
        this.accumulate = false;
        var t3 = this.streamFiles && !e3.file.dir, r3 = n2(e3, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r3.dirRecord), t3)
          this.push({ data: function(e4) {
            return R2.DATA_DESCRIPTOR + A2(e4.crc32, 4) + A2(e4.compressedSize, 4) + A2(e4.uncompressedSize, 4);
          }(e3), meta: { percent: 100 } });
        else
          for (this.push({ data: r3.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s2.prototype.flush = function() {
        for (var e3 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
          this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
        var r3 = this.bytesWritten - e3, n3 = function(e4, t4, r4, n4, i2) {
          var s3 = I2.transformTo("string", i2(n4));
          return R2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A2(e4, 2) + A2(e4, 2) + A2(t4, 4) + A2(r4, 4) + A2(s3.length, 2) + s3;
        }(this.dirRecords.length, r3, e3, this.zipComment, this.encodeFileName);
        this.push({ data: n3, meta: { percent: 100 } });
      }, s2.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s2.prototype.registerPrevious = function(e3) {
        this._sources.push(e3);
        var t3 = this;
        return e3.on("data", function(e4) {
          t3.processChunk(e4);
        }), e3.on("end", function() {
          t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
        }), e3.on("error", function(e4) {
          t3.error(e4);
        }), this;
      }, s2.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s2.prototype.error = function(e3) {
        var t3 = this._sources;
        if (!i.prototype.error.call(this, e3))
          return false;
        for (var r3 = 0; r3 < t3.length; r3++)
          try {
            t3[r3].error(e3);
          } catch (e4) {
          }
        return true;
      }, s2.prototype.lock = function() {
        i.prototype.lock.call(this);
        for (var e3 = this._sources, t3 = 0; t3 < e3.length; t3++)
          e3[t3].lock();
      }, t2.exports = s2;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t2, r2) {
      var u2 = e2("../compressions"), n2 = e2("./ZipFileWorker");
      r2.generateWorker = function(e3, a2, t3) {
        var o2 = new n2(a2.streamFiles, t3, a2.platform, a2.encodeFileName), h2 = 0;
        try {
          e3.forEach(function(e4, t4) {
            h2++;
            var r3 = function(e5, t5) {
              var r4 = e5 || t5, n4 = u2[r4];
              if (!n4)
                throw new Error(r4 + " is not a valid compression method !");
              return n4;
            }(t4.options.compression, a2.compression), n3 = t4.options.compressionOptions || a2.compressionOptions || {}, i = t4.dir, s2 = t4.date;
            t4._compressWorker(r3, n3).withStreamInfo("file", { name: e4, dir: i, date: s2, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o2);
          }), o2.entriesCount = h2;
        } catch (e4) {
          o2.error(e4);
        }
        return o2;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t2, r2) {
      function n2() {
        if (!(this instanceof n2))
          return new n2();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var e3 = new n2();
          for (var t3 in this)
            "function" != typeof this[t3] && (e3[t3] = this[t3]);
          return e3;
        };
      }
      (n2.prototype = e2("./object")).loadAsync = e2("./load"), n2.support = e2("./support"), n2.defaults = e2("./defaults"), n2.version = "3.10.1", n2.loadAsync = function(e3, t3) {
        return new n2().loadAsync(e3, t3);
      }, n2.external = e2("./external"), t2.exports = n2;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t2, r2) {
      var u2 = e2("./utils"), i = e2("./external"), n2 = e2("./utf8"), s2 = e2("./zipEntries"), a2 = e2("./stream/Crc32Probe"), l2 = e2("./nodejsUtils");
      function f2(n3) {
        return new i.Promise(function(e3, t3) {
          var r3 = n3.decompressed.getContentWorker().pipe(new a2());
          r3.on("error", function(e4) {
            t3(e4);
          }).on("end", function() {
            r3.streamInfo.crc32 !== n3.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e3();
          }).resume();
        });
      }
      t2.exports = function(e3, o2) {
        var h2 = this;
        return o2 = u2.extend(o2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n2.utf8decode }), l2.isNode && l2.isStream(e3) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u2.prepareContent("the loaded zip file", e3, true, o2.optimizedBinaryString, o2.base64).then(function(e4) {
          var t3 = new s2(o2);
          return t3.load(e4), t3;
        }).then(function(e4) {
          var t3 = [i.Promise.resolve(e4)], r3 = e4.files;
          if (o2.checkCRC32)
            for (var n3 = 0; n3 < r3.length; n3++)
              t3.push(f2(r3[n3]));
          return i.Promise.all(t3);
        }).then(function(e4) {
          for (var t3 = e4.shift(), r3 = t3.files, n3 = 0; n3 < r3.length; n3++) {
            var i2 = r3[n3], s3 = i2.fileNameStr, a3 = u2.resolve(i2.fileNameStr);
            h2.file(a3, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o2.createFolders }), i2.dir || (h2.file(a3).unsafeOriginalName = s3);
          }
          return t3.zipComment.length && (h2.comment = t3.zipComment), h2;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t2, r2) {
      var n2 = e2("../utils"), i = e2("../stream/GenericWorker");
      function s2(e3, t3) {
        i.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t3);
      }
      n2.inherits(s2, i), s2.prototype._bindStream = function(e3) {
        var t3 = this;
        (this._stream = e3).pause(), e3.on("data", function(e4) {
          t3.push({ data: e4, meta: { percent: 0 } });
        }).on("error", function(e4) {
          t3.isPaused ? this.generatedError = e4 : t3.error(e4);
        }).on("end", function() {
          t3.isPaused ? t3._upstreamEnded = true : t3.end();
        });
      }, s2.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s2.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, t2.exports = s2;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t2, r2) {
      var i = e2("readable-stream").Readable;
      function n2(e3, t3, r3) {
        i.call(this, t3), this._helper = e3;
        var n3 = this;
        e3.on("data", function(e4, t4) {
          n3.push(e4) || n3._helper.pause(), r3 && r3(t4);
        }).on("error", function(e4) {
          n3.emit("error", e4);
        }).on("end", function() {
          n3.push(null);
        });
      }
      e2("../utils").inherits(n2, i), n2.prototype._read = function() {
        this._helper.resume();
      }, t2.exports = n2;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t2, r2) {
      t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e3, t3) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(e3, t3);
        if ("number" == typeof e3)
          throw new Error('The "data" argument must not be a number');
        return new Buffer(e3, t3);
      }, allocBuffer: function(e3) {
        if (Buffer.alloc)
          return Buffer.alloc(e3);
        var t3 = new Buffer(e3);
        return t3.fill(0), t3;
      }, isBuffer: function(e3) {
        return Buffer.isBuffer(e3);
      }, isStream: function(e3) {
        return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
      } };
    }, {}], 15: [function(e2, t2, r2) {
      function s2(e3, t3, r3) {
        var n3, i2 = u2.getTypeOf(t3), s3 = u2.extend(r3 || {}, f2);
        s3.date = s3.date || /* @__PURE__ */ new Date(), null !== s3.compression && (s3.compression = s3.compression.toUpperCase()), "string" == typeof s3.unixPermissions && (s3.unixPermissions = parseInt(s3.unixPermissions, 8)), s3.unixPermissions && 16384 & s3.unixPermissions && (s3.dir = true), s3.dosPermissions && 16 & s3.dosPermissions && (s3.dir = true), s3.dir && (e3 = g(e3)), s3.createFolders && (n3 = _(e3)) && b2.call(this, n3, true);
        var a3 = "string" === i2 && false === s3.binary && false === s3.base64;
        r3 && void 0 !== r3.binary || (s3.binary = !a3), (t3 instanceof c2 && 0 === t3.uncompressedSize || s3.dir || !t3 || 0 === t3.length) && (s3.base64 = false, s3.binary = true, t3 = "", s3.compression = "STORE", i2 = "string");
        var o3 = null;
        o3 = t3 instanceof c2 || t3 instanceof l2 ? t3 : p2.isNode && p2.isStream(t3) ? new m2(e3, t3) : u2.prepareContent(e3, t3, s3.binary, s3.optimizedBinaryString, s3.base64);
        var h3 = new d2(e3, o3, s3);
        this.files[e3] = h3;
      }
      var i = e2("./utf8"), u2 = e2("./utils"), l2 = e2("./stream/GenericWorker"), a2 = e2("./stream/StreamHelper"), f2 = e2("./defaults"), c2 = e2("./compressedObject"), d2 = e2("./zipObject"), o2 = e2("./generate"), p2 = e2("./nodejsUtils"), m2 = e2("./nodejs/NodejsStreamInputAdapter"), _ = function(e3) {
        "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
        var t3 = e3.lastIndexOf("/");
        return 0 < t3 ? e3.substring(0, t3) : "";
      }, g = function(e3) {
        return "/" !== e3.slice(-1) && (e3 += "/"), e3;
      }, b2 = function(e3, t3) {
        return t3 = void 0 !== t3 ? t3 : f2.createFolders, e3 = g(e3), this.files[e3] || s2.call(this, e3, null, { dir: true, createFolders: t3 }), this.files[e3];
      };
      function h2(e3) {
        return "[object RegExp]" === Object.prototype.toString.call(e3);
      }
      var n2 = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(e3) {
        var t3, r3, n3;
        for (t3 in this.files)
          n3 = this.files[t3], (r3 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e3(r3, n3);
      }, filter: function(r3) {
        var n3 = [];
        return this.forEach(function(e3, t3) {
          r3(e3, t3) && n3.push(t3);
        }), n3;
      }, file: function(e3, t3, r3) {
        if (1 !== arguments.length)
          return e3 = this.root + e3, s2.call(this, e3, t3, r3), this;
        if (h2(e3)) {
          var n3 = e3;
          return this.filter(function(e4, t4) {
            return !t4.dir && n3.test(e4);
          });
        }
        var i2 = this.files[this.root + e3];
        return i2 && !i2.dir ? i2 : null;
      }, folder: function(r3) {
        if (!r3)
          return this;
        if (h2(r3))
          return this.filter(function(e4, t4) {
            return t4.dir && r3.test(e4);
          });
        var e3 = this.root + r3, t3 = b2.call(this, e3), n3 = this.clone();
        return n3.root = t3.name, n3;
      }, remove: function(r3) {
        r3 = this.root + r3;
        var e3 = this.files[r3];
        if (e3 || ("/" !== r3.slice(-1) && (r3 += "/"), e3 = this.files[r3]), e3 && !e3.dir)
          delete this.files[r3];
        else
          for (var t3 = this.filter(function(e4, t4) {
            return t4.name.slice(0, r3.length) === r3;
          }), n3 = 0; n3 < t3.length; n3++)
            delete this.files[t3[n3].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(e3) {
        var t3, r3 = {};
        try {
          if ((r3 = u2.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r3.type.toLowerCase(), r3.compression = r3.compression.toUpperCase(), "binarystring" === r3.type && (r3.type = "string"), !r3.type)
            throw new Error("No output type specified.");
          u2.checkSupport(r3.type), "darwin" !== r3.platform && "freebsd" !== r3.platform && "linux" !== r3.platform && "sunos" !== r3.platform || (r3.platform = "UNIX"), "win32" === r3.platform && (r3.platform = "DOS");
          var n3 = r3.comment || this.comment || "";
          t3 = o2.generateWorker(this, r3, n3);
        } catch (e4) {
          (t3 = new l2("error")).error(e4);
        }
        return new a2(t3, r3.type || "string", r3.mimeType);
      }, generateAsync: function(e3, t3) {
        return this.generateInternalStream(e3).accumulate(t3);
      }, generateNodeStream: function(e3, t3) {
        return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t3);
      } };
      t2.exports = n2;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t2, r2) {
      t2.exports = e2("stream");
    }, { stream: void 0 }], 17: [function(e2, t2, r2) {
      var n2 = e2("./DataReader");
      function i(e3) {
        n2.call(this, e3);
        for (var t3 = 0; t3 < this.data.length; t3++)
          e3[t3] = 255 & e3[t3];
      }
      e2("../utils").inherits(i, n2), i.prototype.byteAt = function(e3) {
        return this.data[this.zero + e3];
      }, i.prototype.lastIndexOfSignature = function(e3) {
        for (var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i2 = e3.charCodeAt(3), s2 = this.length - 4; 0 <= s2; --s2)
          if (this.data[s2] === t3 && this.data[s2 + 1] === r3 && this.data[s2 + 2] === n3 && this.data[s2 + 3] === i2)
            return s2 - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(e3) {
        var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i2 = e3.charCodeAt(3), s2 = this.readData(4);
        return t3 === s2[0] && r3 === s2[1] && n3 === s2[2] && i2 === s2[3];
      }, i.prototype.readData = function(e3) {
        if (this.checkOffset(e3), 0 === e3)
          return [];
        var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t3;
      }, t2.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t2, r2) {
      var n2 = e2("../utils");
      function i(e3) {
        this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(e3) {
        this.checkIndex(this.index + e3);
      }, checkIndex: function(e3) {
        if (this.length < this.zero + e3 || e3 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
      }, setIndex: function(e3) {
        this.checkIndex(e3), this.index = e3;
      }, skip: function(e3) {
        this.setIndex(this.index + e3);
      }, byteAt: function() {
      }, readInt: function(e3) {
        var t3, r3 = 0;
        for (this.checkOffset(e3), t3 = this.index + e3 - 1; t3 >= this.index; t3--)
          r3 = (r3 << 8) + this.byteAt(t3);
        return this.index += e3, r3;
      }, readString: function(e3) {
        return n2.transformTo("string", this.readData(e3));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var e3 = this.readInt(4);
        return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
      } }, t2.exports = i;
    }, { "../utils": 32 }], 19: [function(e2, t2, r2) {
      var n2 = e2("./Uint8ArrayReader");
      function i(e3) {
        n2.call(this, e3);
      }
      e2("../utils").inherits(i, n2), i.prototype.readData = function(e3) {
        this.checkOffset(e3);
        var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t3;
      }, t2.exports = i;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t2, r2) {
      var n2 = e2("./DataReader");
      function i(e3) {
        n2.call(this, e3);
      }
      e2("../utils").inherits(i, n2), i.prototype.byteAt = function(e3) {
        return this.data.charCodeAt(this.zero + e3);
      }, i.prototype.lastIndexOfSignature = function(e3) {
        return this.data.lastIndexOf(e3) - this.zero;
      }, i.prototype.readAndCheckSignature = function(e3) {
        return e3 === this.readData(4);
      }, i.prototype.readData = function(e3) {
        this.checkOffset(e3);
        var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t3;
      }, t2.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t2, r2) {
      var n2 = e2("./ArrayReader");
      function i(e3) {
        n2.call(this, e3);
      }
      e2("../utils").inherits(i, n2), i.prototype.readData = function(e3) {
        if (this.checkOffset(e3), 0 === e3)
          return new Uint8Array(0);
        var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t3;
      }, t2.exports = i;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t2, r2) {
      var n2 = e2("../utils"), i = e2("../support"), s2 = e2("./ArrayReader"), a2 = e2("./StringReader"), o2 = e2("./NodeBufferReader"), h2 = e2("./Uint8ArrayReader");
      t2.exports = function(e3) {
        var t3 = n2.getTypeOf(e3);
        return n2.checkSupport(t3), "string" !== t3 || i.uint8array ? "nodebuffer" === t3 ? new o2(e3) : i.uint8array ? new h2(n2.transformTo("uint8array", e3)) : new s2(n2.transformTo("array", e3)) : new a2(e3);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t2, r2) {
      r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e2, t2, r2) {
      var n2 = e2("./GenericWorker"), i = e2("../utils");
      function s2(e3) {
        n2.call(this, "ConvertWorker to " + e3), this.destType = e3;
      }
      i.inherits(s2, n2), s2.prototype.processChunk = function(e3) {
        this.push({ data: i.transformTo(this.destType, e3.data), meta: e3.meta });
      }, t2.exports = s2;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t2, r2) {
      var n2 = e2("./GenericWorker"), i = e2("../crc32");
      function s2() {
        n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e2("../utils").inherits(s2, n2), s2.prototype.processChunk = function(e3) {
        this.streamInfo.crc32 = i(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
      }, t2.exports = s2;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t2, r2) {
      var n2 = e2("../utils"), i = e2("./GenericWorker");
      function s2(e3) {
        i.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
      }
      n2.inherits(s2, i), s2.prototype.processChunk = function(e3) {
        if (e3) {
          var t3 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = t3 + e3.data.length;
        }
        i.prototype.processChunk.call(this, e3);
      }, t2.exports = s2;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t2, r2) {
      var n2 = e2("../utils"), i = e2("./GenericWorker");
      function s2(e3) {
        i.call(this, "DataWorker");
        var t3 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then(function(e4) {
          t3.dataIsReady = true, t3.data = e4, t3.max = e4 && e4.length || 0, t3.type = n2.getTypeOf(e4), t3.isPaused || t3._tickAndRepeat();
        }, function(e4) {
          t3.error(e4);
        });
      }
      n2.inherits(s2, i), s2.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, s2.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
      }, s2.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s2.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var e3 = null, t3 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            e3 = this.data.substring(this.index, t3);
            break;
          case "uint8array":
            e3 = this.data.subarray(this.index, t3);
            break;
          case "array":
          case "nodebuffer":
            e3 = this.data.slice(this.index, t3);
        }
        return this.index = t3, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, t2.exports = s2;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t2, r2) {
      function n2(e3) {
        this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n2.prototype = { push: function(e3) {
        this.emit("data", e3);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (e3) {
          this.emit("error", e3);
        }
        return true;
      }, error: function(e3) {
        return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
      }, on: function(e3, t3) {
        return this._listeners[e3].push(t3), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(e3, t3) {
        if (this._listeners[e3])
          for (var r3 = 0; r3 < this._listeners[e3].length; r3++)
            this._listeners[e3][r3].call(this, t3);
      }, pipe: function(e3) {
        return e3.registerPrevious(this);
      }, registerPrevious: function(e3) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
        var t3 = this;
        return e3.on("data", function(e4) {
          t3.processChunk(e4);
        }), e3.on("end", function() {
          t3.end();
        }), e3.on("error", function(e4) {
          t3.error(e4);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var e3 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
      }, flush: function() {
      }, processChunk: function(e3) {
        this.push(e3);
      }, withStreamInfo: function(e3, t3) {
        return this.extraStreamInfo[e3] = t3, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var e3 in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var e3 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + e3 : e3;
      } }, t2.exports = n2;
    }, {}], 29: [function(e2, t2, r2) {
      var h2 = e2("../utils"), i = e2("./ConvertWorker"), s2 = e2("./GenericWorker"), u2 = e2("../base64"), n2 = e2("../support"), a2 = e2("../external"), o2 = null;
      if (n2.nodestream)
        try {
          o2 = e2("../nodejs/NodejsStreamOutputAdapter");
        } catch (e3) {
        }
      function l2(e3, o3) {
        return new a2.Promise(function(t3, r3) {
          var n3 = [], i2 = e3._internalType, s3 = e3._outputType, a3 = e3._mimeType;
          e3.on("data", function(e4, t4) {
            n3.push(e4), o3 && o3(t4);
          }).on("error", function(e4) {
            n3 = [], r3(e4);
          }).on("end", function() {
            try {
              var e4 = function(e5, t4, r4) {
                switch (e5) {
                  case "blob":
                    return h2.newBlob(h2.transformTo("arraybuffer", t4), r4);
                  case "base64":
                    return u2.encode(t4);
                  default:
                    return h2.transformTo(e5, t4);
                }
              }(s3, function(e5, t4) {
                var r4, n4 = 0, i3 = null, s4 = 0;
                for (r4 = 0; r4 < t4.length; r4++)
                  s4 += t4[r4].length;
                switch (e5) {
                  case "string":
                    return t4.join("");
                  case "array":
                    return Array.prototype.concat.apply([], t4);
                  case "uint8array":
                    for (i3 = new Uint8Array(s4), r4 = 0; r4 < t4.length; r4++)
                      i3.set(t4[r4], n4), n4 += t4[r4].length;
                    return i3;
                  case "nodebuffer":
                    return Buffer.concat(t4);
                  default:
                    throw new Error("concat : unsupported type '" + e5 + "'");
                }
              }(i2, n3), a3);
              t3(e4);
            } catch (e5) {
              r3(e5);
            }
            n3 = [];
          }).resume();
        });
      }
      function f2(e3, t3, r3) {
        var n3 = t3;
        switch (t3) {
          case "blob":
          case "arraybuffer":
            n3 = "uint8array";
            break;
          case "base64":
            n3 = "string";
        }
        try {
          this._internalType = n3, this._outputType = t3, this._mimeType = r3, h2.checkSupport(n3), this._worker = e3.pipe(new i(n3)), e3.lock();
        } catch (e4) {
          this._worker = new s2("error"), this._worker.error(e4);
        }
      }
      f2.prototype = { accumulate: function(e3) {
        return l2(this, e3);
      }, on: function(e3, t3) {
        var r3 = this;
        return "data" === e3 ? this._worker.on(e3, function(e4) {
          t3.call(r3, e4.data, e4.meta);
        }) : this._worker.on(e3, function() {
          h2.delay(t3, arguments, r3);
        }), this;
      }, resume: function() {
        return h2.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(e3) {
        if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
          throw new Error(this._outputType + " is not supported by this method");
        return new o2(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
      } }, t2.exports = f2;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t2, r2) {
      if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = "undefined" != typeof Buffer, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
        r2.blob = false;
      else {
        var n2 = new ArrayBuffer(0);
        try {
          r2.blob = 0 === new Blob([n2], { type: "application/zip" }).size;
        } catch (e3) {
          try {
            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            i.append(n2), r2.blob = 0 === i.getBlob("application/zip").size;
          } catch (e4) {
            r2.blob = false;
          }
        }
      }
      try {
        r2.nodestream = !!e2("readable-stream").Readable;
      } catch (e3) {
        r2.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e2, t2, s2) {
      for (var o2 = e2("./utils"), h2 = e2("./support"), r2 = e2("./nodejsUtils"), n2 = e2("./stream/GenericWorker"), u2 = new Array(256), i = 0; i < 256; i++)
        u2[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
      u2[254] = u2[254] = 1;
      function a2() {
        n2.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l2() {
        n2.call(this, "utf-8 encode");
      }
      s2.utf8encode = function(e3) {
        return h2.nodebuffer ? r2.newBufferFrom(e3, "utf-8") : function(e4) {
          var t3, r3, n3, i2, s3, a3 = e4.length, o3 = 0;
          for (i2 = 0; i2 < a3; i2++)
            55296 == (64512 & (r3 = e4.charCodeAt(i2))) && i2 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i2 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i2++), o3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
          for (t3 = h2.uint8array ? new Uint8Array(o3) : new Array(o3), i2 = s3 = 0; s3 < o3; i2++)
            55296 == (64512 & (r3 = e4.charCodeAt(i2))) && i2 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i2 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i2++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
          return t3;
        }(e3);
      }, s2.utf8decode = function(e3) {
        return h2.nodebuffer ? o2.transformTo("nodebuffer", e3).toString("utf-8") : function(e4) {
          var t3, r3, n3, i2, s3 = e4.length, a3 = new Array(2 * s3);
          for (t3 = r3 = 0; t3 < s3; )
            if ((n3 = e4[t3++]) < 128)
              a3[r3++] = n3;
            else if (4 < (i2 = u2[n3]))
              a3[r3++] = 65533, t3 += i2 - 1;
            else {
              for (n3 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t3 < s3; )
                n3 = n3 << 6 | 63 & e4[t3++], i2--;
              1 < i2 ? a3[r3++] = 65533 : n3 < 65536 ? a3[r3++] = n3 : (n3 -= 65536, a3[r3++] = 55296 | n3 >> 10 & 1023, a3[r3++] = 56320 | 1023 & n3);
            }
          return a3.length !== r3 && (a3.subarray ? a3 = a3.subarray(0, r3) : a3.length = r3), o2.applyFromCharCode(a3);
        }(e3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3));
      }, o2.inherits(a2, n2), a2.prototype.processChunk = function(e3) {
        var t3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3.data);
        if (this.leftOver && this.leftOver.length) {
          if (h2.uint8array) {
            var r3 = t3;
            (t3 = new Uint8Array(r3.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r3, this.leftOver.length);
          } else
            t3 = this.leftOver.concat(t3);
          this.leftOver = null;
        }
        var n3 = function(e4, t4) {
          var r4;
          for ((t4 = t4 || e4.length) > e4.length && (t4 = e4.length), r4 = t4 - 1; 0 <= r4 && 128 == (192 & e4[r4]); )
            r4--;
          return r4 < 0 ? t4 : 0 === r4 ? t4 : r4 + u2[e4[r4]] > t4 ? r4 : t4;
        }(t3), i2 = t3;
        n3 !== t3.length && (h2.uint8array ? (i2 = t3.subarray(0, n3), this.leftOver = t3.subarray(n3, t3.length)) : (i2 = t3.slice(0, n3), this.leftOver = t3.slice(n3, t3.length))), this.push({ data: s2.utf8decode(i2), meta: e3.meta });
      }, a2.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s2.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s2.Utf8DecodeWorker = a2, o2.inherits(l2, n2), l2.prototype.processChunk = function(e3) {
        this.push({ data: s2.utf8encode(e3.data), meta: e3.meta });
      }, s2.Utf8EncodeWorker = l2;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t2, a2) {
      var o2 = e2("./support"), h2 = e2("./base64"), r2 = e2("./nodejsUtils"), u2 = e2("./external");
      function n2(e3) {
        return e3;
      }
      function l2(e3, t3) {
        for (var r3 = 0; r3 < e3.length; ++r3)
          t3[r3] = 255 & e3.charCodeAt(r3);
        return t3;
      }
      e2("setimmediate"), a2.newBlob = function(t3, r3) {
        a2.checkSupport("blob");
        try {
          return new Blob([t3], { type: r3 });
        } catch (e3) {
          try {
            var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return n3.append(t3), n3.getBlob(r3);
          } catch (e4) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var i = { stringifyByChunk: function(e3, t3, r3) {
        var n3 = [], i2 = 0, s3 = e3.length;
        if (s3 <= r3)
          return String.fromCharCode.apply(null, e3);
        for (; i2 < s3; )
          "array" === t3 || "nodebuffer" === t3 ? n3.push(String.fromCharCode.apply(null, e3.slice(i2, Math.min(i2 + r3, s3)))) : n3.push(String.fromCharCode.apply(null, e3.subarray(i2, Math.min(i2 + r3, s3)))), i2 += r3;
        return n3.join("");
      }, stringifyByChar: function(e3) {
        for (var t3 = "", r3 = 0; r3 < e3.length; r3++)
          t3 += String.fromCharCode(e3[r3]);
        return t3;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o2.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
        } catch (e3) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o2.nodebuffer && 1 === String.fromCharCode.apply(null, r2.allocBuffer(1)).length;
        } catch (e3) {
          return false;
        }
      }() } };
      function s2(e3) {
        var t3 = 65536, r3 = a2.getTypeOf(e3), n3 = true;
        if ("uint8array" === r3 ? n3 = i.applyCanBeUsed.uint8array : "nodebuffer" === r3 && (n3 = i.applyCanBeUsed.nodebuffer), n3)
          for (; 1 < t3; )
            try {
              return i.stringifyByChunk(e3, r3, t3);
            } catch (e4) {
              t3 = Math.floor(t3 / 2);
            }
        return i.stringifyByChar(e3);
      }
      function f2(e3, t3) {
        for (var r3 = 0; r3 < e3.length; r3++)
          t3[r3] = e3[r3];
        return t3;
      }
      a2.applyFromCharCode = s2;
      var c2 = {};
      c2.string = { string: n2, array: function(e3) {
        return l2(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return c2.string.uint8array(e3).buffer;
      }, uint8array: function(e3) {
        return l2(e3, new Uint8Array(e3.length));
      }, nodebuffer: function(e3) {
        return l2(e3, r2.allocBuffer(e3.length));
      } }, c2.array = { string: s2, array: n2, arraybuffer: function(e3) {
        return new Uint8Array(e3).buffer;
      }, uint8array: function(e3) {
        return new Uint8Array(e3);
      }, nodebuffer: function(e3) {
        return r2.newBufferFrom(e3);
      } }, c2.arraybuffer = { string: function(e3) {
        return s2(new Uint8Array(e3));
      }, array: function(e3) {
        return f2(new Uint8Array(e3), new Array(e3.byteLength));
      }, arraybuffer: n2, uint8array: function(e3) {
        return new Uint8Array(e3);
      }, nodebuffer: function(e3) {
        return r2.newBufferFrom(new Uint8Array(e3));
      } }, c2.uint8array = { string: s2, array: function(e3) {
        return f2(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return e3.buffer;
      }, uint8array: n2, nodebuffer: function(e3) {
        return r2.newBufferFrom(e3);
      } }, c2.nodebuffer = { string: s2, array: function(e3) {
        return f2(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return c2.nodebuffer.uint8array(e3).buffer;
      }, uint8array: function(e3) {
        return f2(e3, new Uint8Array(e3.length));
      }, nodebuffer: n2 }, a2.transformTo = function(e3, t3) {
        if (t3 = t3 || "", !e3)
          return t3;
        a2.checkSupport(e3);
        var r3 = a2.getTypeOf(t3);
        return c2[r3][e3](t3);
      }, a2.resolve = function(e3) {
        for (var t3 = e3.split("/"), r3 = [], n3 = 0; n3 < t3.length; n3++) {
          var i2 = t3[n3];
          "." === i2 || "" === i2 && 0 !== n3 && n3 !== t3.length - 1 || (".." === i2 ? r3.pop() : r3.push(i2));
        }
        return r3.join("/");
      }, a2.getTypeOf = function(e3) {
        return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : o2.nodebuffer && r2.isBuffer(e3) ? "nodebuffer" : o2.uint8array && e3 instanceof Uint8Array ? "uint8array" : o2.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a2.checkSupport = function(e3) {
        if (!o2[e3.toLowerCase()])
          throw new Error(e3 + " is not supported by this platform");
      }, a2.MAX_VALUE_16BITS = 65535, a2.MAX_VALUE_32BITS = -1, a2.pretty = function(e3) {
        var t3, r3, n3 = "";
        for (r3 = 0; r3 < (e3 || "").length; r3++)
          n3 += "\\x" + ((t3 = e3.charCodeAt(r3)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
        return n3;
      }, a2.delay = function(e3, t3, r3) {
        setImmediate(function() {
          e3.apply(r3 || null, t3 || []);
        });
      }, a2.inherits = function(e3, t3) {
        function r3() {
        }
        r3.prototype = t3.prototype, e3.prototype = new r3();
      }, a2.extend = function() {
        var e3, t3, r3 = {};
        for (e3 = 0; e3 < arguments.length; e3++)
          for (t3 in arguments[e3])
            Object.prototype.hasOwnProperty.call(arguments[e3], t3) && void 0 === r3[t3] && (r3[t3] = arguments[e3][t3]);
        return r3;
      }, a2.prepareContent = function(r3, e3, n3, i2, s3) {
        return u2.Promise.resolve(e3).then(function(n4) {
          return o2.blob && (n4 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n4))) && "undefined" != typeof FileReader ? new u2.Promise(function(t3, r4) {
            var e4 = new FileReader();
            e4.onload = function(e5) {
              t3(e5.target.result);
            }, e4.onerror = function(e5) {
              r4(e5.target.error);
            }, e4.readAsArrayBuffer(n4);
          }) : n4;
        }).then(function(e4) {
          var t3 = a2.getTypeOf(e4);
          return t3 ? ("arraybuffer" === t3 ? e4 = a2.transformTo("uint8array", e4) : "string" === t3 && (s3 ? e4 = h2.decode(e4) : n3 && true !== i2 && (e4 = function(e5) {
            return l2(e5, o2.uint8array ? new Uint8Array(e5.length) : new Array(e5.length));
          }(e4))), e4) : u2.Promise.reject(new Error("Can't read the data of '" + r3 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t2, r2) {
      var n2 = e2("./reader/readerFor"), i = e2("./utils"), s2 = e2("./signature"), a2 = e2("./zipEntry"), o2 = e2("./support");
      function h2(e3) {
        this.files = [], this.loadOptions = e3;
      }
      h2.prototype = { checkSignature: function(e3) {
        if (!this.reader.readAndCheckSignature(e3)) {
          this.reader.index -= 4;
          var t3 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t3) + ", expected " + i.pretty(e3) + ")");
        }
      }, isSignature: function(e3, t3) {
        var r3 = this.reader.index;
        this.reader.setIndex(e3);
        var n3 = this.reader.readString(4) === t3;
        return this.reader.setIndex(r3), n3;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var e3 = this.reader.readData(this.zipCommentLength), t3 = o2.uint8array ? "uint8array" : "array", r3 = i.transformTo(t3, e3);
        this.zipComment = this.loadOptions.decodeFileName(r3);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var e3, t3, r3, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; )
          e3 = this.reader.readInt(2), t3 = this.reader.readInt(4), r3 = this.reader.readData(t3), this.zip64ExtensibleData[e3] = { id: e3, length: t3, value: r3 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var e3, t3;
        for (e3 = 0; e3 < this.files.length; e3++)
          t3 = this.files[e3], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s2.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
      }, readCentralDir: function() {
        var e3;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER); )
          (e3 = new a2({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var e3 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END);
        if (e3 < 0)
          throw !this.isSignature(0, s2.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(e3);
        var t3 = e3;
        if (this.checkSignature(s2.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(e3), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r3 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r3 += 20, r3 += 12 + this.zip64EndOfCentralSize);
        var n3 = t3 - r3;
        if (0 < n3)
          this.isSignature(t3, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
        else if (n3 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
      }, prepareReader: function(e3) {
        this.reader = n2(e3);
      }, load: function(e3) {
        this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, t2.exports = h2;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t2, r2) {
      var n2 = e2("./reader/readerFor"), s2 = e2("./utils"), i = e2("./compressedObject"), a2 = e2("./crc32"), o2 = e2("./utf8"), h2 = e2("./compressions"), u2 = e2("./support");
      function l2(e3, t3) {
        this.options = e3, this.loadOptions = t3;
      }
      l2.prototype = { isEncrypted: function() {
        return 1 == (1 & this.bitFlag);
      }, useUTF8: function() {
        return 2048 == (2048 & this.bitFlag);
      }, readLocalPart: function(e3) {
        var t3, r3;
        if (e3.skip(22), this.fileNameLength = e3.readInt(2), r3 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r3), -1 === this.compressedSize || -1 === this.uncompressedSize)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if (null === (t3 = function(e4) {
          for (var t4 in h2)
            if (Object.prototype.hasOwnProperty.call(h2, t4) && h2[t4].magic === e4)
              return h2[t4];
          return null;
        }(this.compressionMethod)))
          throw new Error("Corrupted zip : compression " + s2.pretty(this.compressionMethod) + " unknown (inner file : " + s2.transformTo("string", this.fileName) + ")");
        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t3, e3.readData(this.compressedSize));
      }, readCentralPart: function(e3) {
        this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
        var t3 = e3.readInt(2);
        if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        e3.skip(t3), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var e3 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var e3 = n2(this.extraFields[1].value);
          this.uncompressedSize === s2.MAX_VALUE_32BITS && (this.uncompressedSize = e3.readInt(8)), this.compressedSize === s2.MAX_VALUE_32BITS && (this.compressedSize = e3.readInt(8)), this.localHeaderOffset === s2.MAX_VALUE_32BITS && (this.localHeaderOffset = e3.readInt(8)), this.diskNumberStart === s2.MAX_VALUE_32BITS && (this.diskNumberStart = e3.readInt(4));
        }
      }, readExtraFields: function(e3) {
        var t3, r3, n3, i2 = e3.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i2; )
          t3 = e3.readInt(2), r3 = e3.readInt(2), n3 = e3.readData(r3), this.extraFields[t3] = { id: t3, length: r3, value: n3 };
        e3.setIndex(i2);
      }, handleUTF8: function() {
        var e3 = u2.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o2.utf8decode(this.fileName), this.fileCommentStr = o2.utf8decode(this.fileComment);
        else {
          var t3 = this.findExtraFieldUnicodePath();
          if (null !== t3)
            this.fileNameStr = t3;
          else {
            var r3 = s2.transformTo(e3, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r3);
          }
          var n3 = this.findExtraFieldUnicodeComment();
          if (null !== n3)
            this.fileCommentStr = n3;
          else {
            var i2 = s2.transformTo(e3, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(i2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var e3 = this.extraFields[28789];
        if (e3) {
          var t3 = n2(e3.value);
          return 1 !== t3.readInt(1) ? null : a2(this.fileName) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var e3 = this.extraFields[25461];
        if (e3) {
          var t3 = n2(e3.value);
          return 1 !== t3.readInt(1) ? null : a2(this.fileComment) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
        }
        return null;
      } }, t2.exports = l2;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t2, r2) {
      function n2(e3, t3, r3) {
        this.name = e3, this.dir = r3.dir, this.date = r3.date, this.comment = r3.comment, this.unixPermissions = r3.unixPermissions, this.dosPermissions = r3.dosPermissions, this._data = t3, this._dataBinary = r3.binary, this.options = { compression: r3.compression, compressionOptions: r3.compressionOptions };
      }
      var s2 = e2("./stream/StreamHelper"), i = e2("./stream/DataWorker"), a2 = e2("./utf8"), o2 = e2("./compressedObject"), h2 = e2("./stream/GenericWorker");
      n2.prototype = { internalStream: function(e3) {
        var t3 = null, r3 = "string";
        try {
          if (!e3)
            throw new Error("No output type specified.");
          var n3 = "string" === (r3 = e3.toLowerCase()) || "text" === r3;
          "binarystring" !== r3 && "text" !== r3 || (r3 = "string"), t3 = this._decompressWorker();
          var i2 = !this._dataBinary;
          i2 && !n3 && (t3 = t3.pipe(new a2.Utf8EncodeWorker())), !i2 && n3 && (t3 = t3.pipe(new a2.Utf8DecodeWorker()));
        } catch (e4) {
          (t3 = new h2("error")).error(e4);
        }
        return new s2(t3, r3, "");
      }, async: function(e3, t3) {
        return this.internalStream(e3).accumulate(t3);
      }, nodeStream: function(e3, t3) {
        return this.internalStream(e3 || "nodebuffer").toNodejsStream(t3);
      }, _compressWorker: function(e3, t3) {
        if (this._data instanceof o2 && this._data.compression.magic === e3.magic)
          return this._data.getCompressedWorker();
        var r3 = this._decompressWorker();
        return this._dataBinary || (r3 = r3.pipe(new a2.Utf8EncodeWorker())), o2.createWorkerFrom(r3, e3, t3);
      }, _decompressWorker: function() {
        return this._data instanceof o2 ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i(this._data);
      } };
      for (var u2 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l2 = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f2 = 0; f2 < u2.length; f2++)
        n2.prototype[u2[f2]] = l2;
      t2.exports = n2;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l2, t2) {
      (function(t3) {
        var r2, n2, e3 = t3.MutationObserver || t3.WebKitMutationObserver;
        if (e3) {
          var i = 0, s2 = new e3(u2), a2 = t3.document.createTextNode("");
          s2.observe(a2, { characterData: true }), r2 = function() {
            a2.data = i = ++i % 2;
          };
        } else if (t3.setImmediate || void 0 === t3.MessageChannel)
          r2 = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
            var e4 = t3.document.createElement("script");
            e4.onreadystatechange = function() {
              u2(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
            }, t3.document.documentElement.appendChild(e4);
          } : function() {
            setTimeout(u2, 0);
          };
        else {
          var o2 = new t3.MessageChannel();
          o2.port1.onmessage = u2, r2 = function() {
            o2.port2.postMessage(0);
          };
        }
        var h2 = [];
        function u2() {
          var e4, t4;
          n2 = true;
          for (var r3 = h2.length; r3; ) {
            for (t4 = h2, h2 = [], e4 = -1; ++e4 < r3; )
              t4[e4]();
            r3 = h2.length;
          }
          n2 = false;
        }
        l2.exports = function(e4) {
          1 !== h2.push(e4) || n2 || r2();
        };
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 37: [function(e2, t2, r2) {
      var i = e2("immediate");
      function u2() {
      }
      var l2 = {}, s2 = ["REJECTED"], a2 = ["FULFILLED"], n2 = ["PENDING"];
      function o2(e3) {
        if ("function" != typeof e3)
          throw new TypeError("resolver must be a function");
        this.state = n2, this.queue = [], this.outcome = void 0, e3 !== u2 && d2(this, e3);
      }
      function h2(e3, t3, r3) {
        this.promise = e3, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r3 && (this.onRejected = r3, this.callRejected = this.otherCallRejected);
      }
      function f2(t3, r3, n3) {
        i(function() {
          var e3;
          try {
            e3 = r3(n3);
          } catch (e4) {
            return l2.reject(t3, e4);
          }
          e3 === t3 ? l2.reject(t3, new TypeError("Cannot resolve promise with itself")) : l2.resolve(t3, e3);
        });
      }
      function c2(e3) {
        var t3 = e3 && e3.then;
        if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t3)
          return function() {
            t3.apply(e3, arguments);
          };
      }
      function d2(t3, e3) {
        var r3 = false;
        function n3(e4) {
          r3 || (r3 = true, l2.reject(t3, e4));
        }
        function i2(e4) {
          r3 || (r3 = true, l2.resolve(t3, e4));
        }
        var s3 = p2(function() {
          e3(i2, n3);
        });
        "error" === s3.status && n3(s3.value);
      }
      function p2(e3, t3) {
        var r3 = {};
        try {
          r3.value = e3(t3), r3.status = "success";
        } catch (e4) {
          r3.status = "error", r3.value = e4;
        }
        return r3;
      }
      (t2.exports = o2).prototype.finally = function(t3) {
        if ("function" != typeof t3)
          return this;
        var r3 = this.constructor;
        return this.then(function(e3) {
          return r3.resolve(t3()).then(function() {
            return e3;
          });
        }, function(e3) {
          return r3.resolve(t3()).then(function() {
            throw e3;
          });
        });
      }, o2.prototype.catch = function(e3) {
        return this.then(null, e3);
      }, o2.prototype.then = function(e3, t3) {
        if ("function" != typeof e3 && this.state === a2 || "function" != typeof t3 && this.state === s2)
          return this;
        var r3 = new this.constructor(u2);
        this.state !== n2 ? f2(r3, this.state === a2 ? e3 : t3, this.outcome) : this.queue.push(new h2(r3, e3, t3));
        return r3;
      }, h2.prototype.callFulfilled = function(e3) {
        l2.resolve(this.promise, e3);
      }, h2.prototype.otherCallFulfilled = function(e3) {
        f2(this.promise, this.onFulfilled, e3);
      }, h2.prototype.callRejected = function(e3) {
        l2.reject(this.promise, e3);
      }, h2.prototype.otherCallRejected = function(e3) {
        f2(this.promise, this.onRejected, e3);
      }, l2.resolve = function(e3, t3) {
        var r3 = p2(c2, t3);
        if ("error" === r3.status)
          return l2.reject(e3, r3.value);
        var n3 = r3.value;
        if (n3)
          d2(e3, n3);
        else {
          e3.state = a2, e3.outcome = t3;
          for (var i2 = -1, s3 = e3.queue.length; ++i2 < s3; )
            e3.queue[i2].callFulfilled(t3);
        }
        return e3;
      }, l2.reject = function(e3, t3) {
        e3.state = s2, e3.outcome = t3;
        for (var r3 = -1, n3 = e3.queue.length; ++r3 < n3; )
          e3.queue[r3].callRejected(t3);
        return e3;
      }, o2.resolve = function(e3) {
        if (e3 instanceof this)
          return e3;
        return l2.resolve(new this(u2), e3);
      }, o2.reject = function(e3) {
        var t3 = new this(u2);
        return l2.reject(t3, e3);
      }, o2.all = function(e3) {
        var r3 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e3))
          return this.reject(new TypeError("must be an array"));
        var n3 = e3.length, i2 = false;
        if (!n3)
          return this.resolve([]);
        var s3 = new Array(n3), a3 = 0, t3 = -1, o3 = new this(u2);
        for (; ++t3 < n3; )
          h3(e3[t3], t3);
        return o3;
        function h3(e4, t4) {
          r3.resolve(e4).then(function(e5) {
            s3[t4] = e5, ++a3 !== n3 || i2 || (i2 = true, l2.resolve(o3, s3));
          }, function(e5) {
            i2 || (i2 = true, l2.reject(o3, e5));
          });
        }
      }, o2.race = function(e3) {
        var t3 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e3))
          return this.reject(new TypeError("must be an array"));
        var r3 = e3.length, n3 = false;
        if (!r3)
          return this.resolve([]);
        var i2 = -1, s3 = new this(u2);
        for (; ++i2 < r3; )
          a3 = e3[i2], t3.resolve(a3).then(function(e4) {
            n3 || (n3 = true, l2.resolve(s3, e4));
          }, function(e4) {
            n3 || (n3 = true, l2.reject(s3, e4));
          });
        var a3;
        return s3;
      };
    }, { immediate: 36 }], 38: [function(e2, t2, r2) {
      var n2 = {};
      (0, e2("./lib/utils/common").assign)(n2, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t2.exports = n2;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t2, r2) {
      var a2 = e2("./zlib/deflate"), o2 = e2("./utils/common"), h2 = e2("./utils/strings"), i = e2("./zlib/messages"), s2 = e2("./zlib/zstream"), u2 = Object.prototype.toString, l2 = 0, f2 = -1, c2 = 0, d2 = 8;
      function p2(e3) {
        if (!(this instanceof p2))
          return new p2(e3);
        this.options = o2.assign({ level: f2, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e3 || {});
        var t3 = this.options;
        t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s2(), this.strm.avail_out = 0;
        var r3 = a2.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
        if (r3 !== l2)
          throw new Error(i[r3]);
        if (t3.header && a2.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
          var n3;
          if (n3 = "string" == typeof t3.dictionary ? h2.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u2.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r3 = a2.deflateSetDictionary(this.strm, n3)) !== l2)
            throw new Error(i[r3]);
          this._dict_set = true;
        }
      }
      function n2(e3, t3) {
        var r3 = new p2(t3);
        if (r3.push(e3, true), r3.err)
          throw r3.msg || i[r3.err];
        return r3.result;
      }
      p2.prototype.push = function(e3, t3) {
        var r3, n3, i2 = this.strm, s3 = this.options.chunkSize;
        if (this.ended)
          return false;
        n3 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e3 ? i2.input = h2.string2buf(e3) : "[object ArrayBuffer]" === u2.call(e3) ? i2.input = new Uint8Array(e3) : i2.input = e3, i2.next_in = 0, i2.avail_in = i2.input.length;
        do {
          if (0 === i2.avail_out && (i2.output = new o2.Buf8(s3), i2.next_out = 0, i2.avail_out = s3), 1 !== (r3 = a2.deflate(i2, n3)) && r3 !== l2)
            return this.onEnd(r3), !(this.ended = true);
          0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n3 && 2 !== n3) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o2.shrinkBuf(i2.output, i2.next_out))) : this.onData(o2.shrinkBuf(i2.output, i2.next_out)));
        } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r3);
        return 4 === n3 ? (r3 = a2.deflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === l2) : 2 !== n3 || (this.onEnd(l2), !(i2.avail_out = 0));
      }, p2.prototype.onData = function(e3) {
        this.chunks.push(e3);
      }, p2.prototype.onEnd = function(e3) {
        e3 === l2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
      }, r2.Deflate = p2, r2.deflate = n2, r2.deflateRaw = function(e3, t3) {
        return (t3 = t3 || {}).raw = true, n2(e3, t3);
      }, r2.gzip = function(e3, t3) {
        return (t3 = t3 || {}).gzip = true, n2(e3, t3);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t2, r2) {
      var c2 = e2("./zlib/inflate"), d2 = e2("./utils/common"), p2 = e2("./utils/strings"), m2 = e2("./zlib/constants"), n2 = e2("./zlib/messages"), i = e2("./zlib/zstream"), s2 = e2("./zlib/gzheader"), _ = Object.prototype.toString;
      function a2(e3) {
        if (!(this instanceof a2))
          return new a2(e3);
        this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
        var t3 = this.options;
        t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e3 && e3.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
        var r3 = c2.inflateInit2(this.strm, t3.windowBits);
        if (r3 !== m2.Z_OK)
          throw new Error(n2[r3]);
        this.header = new s2(), c2.inflateGetHeader(this.strm, this.header);
      }
      function o2(e3, t3) {
        var r3 = new a2(t3);
        if (r3.push(e3, true), r3.err)
          throw r3.msg || n2[r3.err];
        return r3.result;
      }
      a2.prototype.push = function(e3, t3) {
        var r3, n3, i2, s3, a3, o3, h2 = this.strm, u2 = this.options.chunkSize, l2 = this.options.dictionary, f2 = false;
        if (this.ended)
          return false;
        n3 = t3 === ~~t3 ? t3 : true === t3 ? m2.Z_FINISH : m2.Z_NO_FLUSH, "string" == typeof e3 ? h2.input = p2.binstring2buf(e3) : "[object ArrayBuffer]" === _.call(e3) ? h2.input = new Uint8Array(e3) : h2.input = e3, h2.next_in = 0, h2.avail_in = h2.input.length;
        do {
          if (0 === h2.avail_out && (h2.output = new d2.Buf8(u2), h2.next_out = 0, h2.avail_out = u2), (r3 = c2.inflate(h2, m2.Z_NO_FLUSH)) === m2.Z_NEED_DICT && l2 && (o3 = "string" == typeof l2 ? p2.string2buf(l2) : "[object ArrayBuffer]" === _.call(l2) ? new Uint8Array(l2) : l2, r3 = c2.inflateSetDictionary(this.strm, o3)), r3 === m2.Z_BUF_ERROR && true === f2 && (r3 = m2.Z_OK, f2 = false), r3 !== m2.Z_STREAM_END && r3 !== m2.Z_OK)
            return this.onEnd(r3), !(this.ended = true);
          h2.next_out && (0 !== h2.avail_out && r3 !== m2.Z_STREAM_END && (0 !== h2.avail_in || n3 !== m2.Z_FINISH && n3 !== m2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p2.utf8border(h2.output, h2.next_out), s3 = h2.next_out - i2, a3 = p2.buf2string(h2.output, i2), h2.next_out = s3, h2.avail_out = u2 - s3, s3 && d2.arraySet(h2.output, h2.output, i2, s3, 0), this.onData(a3)) : this.onData(d2.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f2 = true);
        } while ((0 < h2.avail_in || 0 === h2.avail_out) && r3 !== m2.Z_STREAM_END);
        return r3 === m2.Z_STREAM_END && (n3 = m2.Z_FINISH), n3 === m2.Z_FINISH ? (r3 = c2.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === m2.Z_OK) : n3 !== m2.Z_SYNC_FLUSH || (this.onEnd(m2.Z_OK), !(h2.avail_out = 0));
      }, a2.prototype.onData = function(e3) {
        this.chunks.push(e3);
      }, a2.prototype.onEnd = function(e3) {
        e3 === m2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
      }, r2.Inflate = a2, r2.inflate = o2, r2.inflateRaw = function(e3, t3) {
        return (t3 = t3 || {}).raw = true, o2(e3, t3);
      }, r2.ungzip = o2;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t2, r2) {
      var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      r2.assign = function(e3) {
        for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
          var r3 = t3.shift();
          if (r3) {
            if ("object" != typeof r3)
              throw new TypeError(r3 + "must be non-object");
            for (var n3 in r3)
              r3.hasOwnProperty(n3) && (e3[n3] = r3[n3]);
          }
        }
        return e3;
      }, r2.shrinkBuf = function(e3, t3) {
        return e3.length === t3 ? e3 : e3.subarray ? e3.subarray(0, t3) : (e3.length = t3, e3);
      };
      var i = { arraySet: function(e3, t3, r3, n3, i2) {
        if (t3.subarray && e3.subarray)
          e3.set(t3.subarray(r3, r3 + n3), i2);
        else
          for (var s3 = 0; s3 < n3; s3++)
            e3[i2 + s3] = t3[r3 + s3];
      }, flattenChunks: function(e3) {
        var t3, r3, n3, i2, s3, a2;
        for (t3 = n3 = 0, r3 = e3.length; t3 < r3; t3++)
          n3 += e3[t3].length;
        for (a2 = new Uint8Array(n3), t3 = i2 = 0, r3 = e3.length; t3 < r3; t3++)
          s3 = e3[t3], a2.set(s3, i2), i2 += s3.length;
        return a2;
      } }, s2 = { arraySet: function(e3, t3, r3, n3, i2) {
        for (var s3 = 0; s3 < n3; s3++)
          e3[i2 + s3] = t3[r3 + s3];
      }, flattenChunks: function(e3) {
        return [].concat.apply([], e3);
      } };
      r2.setTyped = function(e3) {
        e3 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s2));
      }, r2.setTyped(n2);
    }, {}], 42: [function(e2, t2, r2) {
      var h2 = e2("./common"), i = true, s2 = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (e3) {
        i = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e3) {
        s2 = false;
      }
      for (var u2 = new h2.Buf8(256), n2 = 0; n2 < 256; n2++)
        u2[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
      function l2(e3, t3) {
        if (t3 < 65537 && (e3.subarray && s2 || !e3.subarray && i))
          return String.fromCharCode.apply(null, h2.shrinkBuf(e3, t3));
        for (var r3 = "", n3 = 0; n3 < t3; n3++)
          r3 += String.fromCharCode(e3[n3]);
        return r3;
      }
      u2[254] = u2[254] = 1, r2.string2buf = function(e3) {
        var t3, r3, n3, i2, s3, a2 = e3.length, o2 = 0;
        for (i2 = 0; i2 < a2; i2++)
          55296 == (64512 & (r3 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i2 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i2++), o2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        for (t3 = new h2.Buf8(o2), i2 = s3 = 0; s3 < o2; i2++)
          55296 == (64512 & (r3 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i2 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i2++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
        return t3;
      }, r2.buf2binstring = function(e3) {
        return l2(e3, e3.length);
      }, r2.binstring2buf = function(e3) {
        for (var t3 = new h2.Buf8(e3.length), r3 = 0, n3 = t3.length; r3 < n3; r3++)
          t3[r3] = e3.charCodeAt(r3);
        return t3;
      }, r2.buf2string = function(e3, t3) {
        var r3, n3, i2, s3, a2 = t3 || e3.length, o2 = new Array(2 * a2);
        for (r3 = n3 = 0; r3 < a2; )
          if ((i2 = e3[r3++]) < 128)
            o2[n3++] = i2;
          else if (4 < (s3 = u2[i2]))
            o2[n3++] = 65533, r3 += s3 - 1;
          else {
            for (i2 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; 1 < s3 && r3 < a2; )
              i2 = i2 << 6 | 63 & e3[r3++], s3--;
            1 < s3 ? o2[n3++] = 65533 : i2 < 65536 ? o2[n3++] = i2 : (i2 -= 65536, o2[n3++] = 55296 | i2 >> 10 & 1023, o2[n3++] = 56320 | 1023 & i2);
          }
        return l2(o2, n3);
      }, r2.utf8border = function(e3, t3) {
        var r3;
        for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
          r3--;
        return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u2[e3[r3]] > t3 ? r3 : t3;
      };
    }, { "./common": 41 }], 43: [function(e2, t2, r2) {
      t2.exports = function(e3, t3, r3, n2) {
        for (var i = 65535 & e3 | 0, s2 = e3 >>> 16 & 65535 | 0, a2 = 0; 0 !== r3; ) {
          for (r3 -= a2 = 2e3 < r3 ? 2e3 : r3; s2 = s2 + (i = i + t3[n2++] | 0) | 0, --a2; )
            ;
          i %= 65521, s2 %= 65521;
        }
        return i | s2 << 16 | 0;
      };
    }, {}], 44: [function(e2, t2, r2) {
      t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e2, t2, r2) {
      var o2 = function() {
        for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
          e3 = r3;
          for (var n2 = 0; n2 < 8; n2++)
            e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
          t3[r3] = e3;
        }
        return t3;
      }();
      t2.exports = function(e3, t3, r3, n2) {
        var i = o2, s2 = n2 + r3;
        e3 ^= -1;
        for (var a2 = n2; a2 < s2; a2++)
          e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a2])];
        return -1 ^ e3;
      };
    }, {}], 46: [function(e2, t2, r2) {
      var h2, c2 = e2("../utils/common"), u2 = e2("./trees"), d2 = e2("./adler32"), p2 = e2("./crc32"), n2 = e2("./messages"), l2 = 0, f2 = 4, m2 = 0, _ = -2, g = -1, b2 = 4, i = 2, v2 = 8, y2 = 9, s2 = 286, a2 = 30, o2 = 19, w2 = 2 * s2 + 1, k2 = 15, x2 = 3, S2 = 258, z2 = S2 + x2 + 1, C2 = 42, E2 = 113, A2 = 1, I2 = 2, O2 = 3, B2 = 4;
      function R2(e3, t3) {
        return e3.msg = n2[t3], t3;
      }
      function T2(e3) {
        return (e3 << 1) - (4 < e3 ? 9 : 0);
      }
      function D2(e3) {
        for (var t3 = e3.length; 0 <= --t3; )
          e3[t3] = 0;
      }
      function F2(e3) {
        var t3 = e3.state, r3 = t3.pending;
        r3 > e3.avail_out && (r3 = e3.avail_out), 0 !== r3 && (c2.arraySet(e3.output, t3.pending_buf, t3.pending_out, r3, e3.next_out), e3.next_out += r3, t3.pending_out += r3, e3.total_out += r3, e3.avail_out -= r3, t3.pending -= r3, 0 === t3.pending && (t3.pending_out = 0));
      }
      function N2(e3, t3) {
        u2._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t3), e3.block_start = e3.strstart, F2(e3.strm);
      }
      function U2(e3, t3) {
        e3.pending_buf[e3.pending++] = t3;
      }
      function P2(e3, t3) {
        e3.pending_buf[e3.pending++] = t3 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t3;
      }
      function L2(e3, t3) {
        var r3, n3, i2 = e3.max_chain_length, s3 = e3.strstart, a3 = e3.prev_length, o3 = e3.nice_match, h3 = e3.strstart > e3.w_size - z2 ? e3.strstart - (e3.w_size - z2) : 0, u3 = e3.window, l3 = e3.w_mask, f3 = e3.prev, c3 = e3.strstart + S2, d3 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
        e3.prev_length >= e3.good_match && (i2 >>= 2), o3 > e3.lookahead && (o3 = e3.lookahead);
        do {
          if (u3[(r3 = t3) + a3] === p3 && u3[r3 + a3 - 1] === d3 && u3[r3] === u3[s3] && u3[++r3] === u3[s3 + 1]) {
            s3 += 2, r3++;
            do {
            } while (u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && s3 < c3);
            if (n3 = S2 - (c3 - s3), s3 = c3 - S2, a3 < n3) {
              if (e3.match_start = t3, o3 <= (a3 = n3))
                break;
              d3 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
            }
          }
        } while ((t3 = f3[t3 & l3]) > h3 && 0 != --i2);
        return a3 <= e3.lookahead ? a3 : e3.lookahead;
      }
      function j(e3) {
        var t3, r3, n3, i2, s3, a3, o3, h3, u3, l3, f3 = e3.w_size;
        do {
          if (i2 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= f3 + (f3 - z2)) {
            for (c2.arraySet(e3.window, e3.window, f3, f3, 0), e3.match_start -= f3, e3.strstart -= f3, e3.block_start -= f3, t3 = r3 = e3.hash_size; n3 = e3.head[--t3], e3.head[t3] = f3 <= n3 ? n3 - f3 : 0, --r3; )
              ;
            for (t3 = r3 = f3; n3 = e3.prev[--t3], e3.prev[t3] = f3 <= n3 ? n3 - f3 : 0, --r3; )
              ;
            i2 += f3;
          }
          if (0 === e3.strm.avail_in)
            break;
          if (a3 = e3.strm, o3 = e3.window, h3 = e3.strstart + e3.lookahead, u3 = i2, l3 = void 0, l3 = a3.avail_in, u3 < l3 && (l3 = u3), r3 = 0 === l3 ? 0 : (a3.avail_in -= l3, c2.arraySet(o3, a3.input, a3.next_in, l3, h3), 1 === a3.state.wrap ? a3.adler = d2(a3.adler, o3, l3, h3) : 2 === a3.state.wrap && (a3.adler = p2(a3.adler, o3, l3, h3)), a3.next_in += l3, a3.total_in += l3, l3), e3.lookahead += r3, e3.lookahead + e3.insert >= x2)
            for (s3 = e3.strstart - e3.insert, e3.ins_h = e3.window[s3], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + x2 - 1]) & e3.hash_mask, e3.prev[s3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s3, s3++, e3.insert--, !(e3.lookahead + e3.insert < x2)); )
              ;
        } while (e3.lookahead < z2 && 0 !== e3.strm.avail_in);
      }
      function Z2(e3, t3) {
        for (var r3, n3; ; ) {
          if (e3.lookahead < z2) {
            if (j(e3), e3.lookahead < z2 && t3 === l2)
              return A2;
            if (0 === e3.lookahead)
              break;
          }
          if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r3 && e3.strstart - r3 <= e3.w_size - z2 && (e3.match_length = L2(e3, r3)), e3.match_length >= x2)
            if (n3 = u2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - x2), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= x2) {
              for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; )
                ;
              e3.strstart++;
            } else
              e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
          else
            n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
          if (n3 && (N2(e3, false), 0 === e3.strm.avail_out))
            return A2;
        }
        return e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
      }
      function W2(e3, t3) {
        for (var r3, n3, i2; ; ) {
          if (e3.lookahead < z2) {
            if (j(e3), e3.lookahead < z2 && t3 === l2)
              return A2;
            if (0 === e3.lookahead)
              break;
          }
          if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = x2 - 1, 0 !== r3 && e3.prev_length < e3.max_lazy_match && e3.strstart - r3 <= e3.w_size - z2 && (e3.match_length = L2(e3, r3), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === x2 && 4096 < e3.strstart - e3.match_start) && (e3.match_length = x2 - 1)), e3.prev_length >= x2 && e3.match_length <= e3.prev_length) {
            for (i2 = e3.strstart + e3.lookahead - x2, n3 = u2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - x2), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; )
              ;
            if (e3.match_available = 0, e3.match_length = x2 - 1, e3.strstart++, n3 && (N2(e3, false), 0 === e3.strm.avail_out))
              return A2;
          } else if (e3.match_available) {
            if ((n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && N2(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out)
              return A2;
          } else
            e3.match_available = 1, e3.strstart++, e3.lookahead--;
        }
        return e3.match_available && (n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
      }
      function M2(e3, t3, r3, n3, i2) {
        this.good_length = e3, this.max_lazy = t3, this.nice_length = r3, this.max_chain = n3, this.func = i2;
      }
      function H2() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w2), this.dyn_dtree = new c2.Buf16(2 * (2 * a2 + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o2 + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k2 + 1), this.heap = new c2.Buf16(2 * s2 + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s2 + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G2(e3) {
        var t3;
        return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = i, (t3 = e3.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C2 : E2, e3.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l2, u2._tr_init(t3), m2) : R2(e3, _);
      }
      function K2(e3) {
        var t3 = G2(e3);
        return t3 === m2 && function(e4) {
          e4.window_size = 2 * e4.w_size, D2(e4.head), e4.max_lazy_match = h2[e4.level].max_lazy, e4.good_match = h2[e4.level].good_length, e4.nice_match = h2[e4.level].nice_length, e4.max_chain_length = h2[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = x2 - 1, e4.match_available = 0, e4.ins_h = 0;
        }(e3.state), t3;
      }
      function Y2(e3, t3, r3, n3, i2, s3) {
        if (!e3)
          return _;
        var a3 = 1;
        if (t3 === g && (t3 = 6), n3 < 0 ? (a3 = 0, n3 = -n3) : 15 < n3 && (a3 = 2, n3 -= 16), i2 < 1 || y2 < i2 || r3 !== v2 || n3 < 8 || 15 < n3 || t3 < 0 || 9 < t3 || s3 < 0 || b2 < s3)
          return R2(e3, _);
        8 === n3 && (n3 = 9);
        var o3 = new H2();
        return (e3.state = o3).strm = e3, o3.wrap = a3, o3.gzhead = null, o3.w_bits = n3, o3.w_size = 1 << o3.w_bits, o3.w_mask = o3.w_size - 1, o3.hash_bits = i2 + 7, o3.hash_size = 1 << o3.hash_bits, o3.hash_mask = o3.hash_size - 1, o3.hash_shift = ~~((o3.hash_bits + x2 - 1) / x2), o3.window = new c2.Buf8(2 * o3.w_size), o3.head = new c2.Buf16(o3.hash_size), o3.prev = new c2.Buf16(o3.w_size), o3.lit_bufsize = 1 << i2 + 6, o3.pending_buf_size = 4 * o3.lit_bufsize, o3.pending_buf = new c2.Buf8(o3.pending_buf_size), o3.d_buf = 1 * o3.lit_bufsize, o3.l_buf = 3 * o3.lit_bufsize, o3.level = t3, o3.strategy = s3, o3.method = r3, K2(e3);
      }
      h2 = [new M2(0, 0, 0, 0, function(e3, t3) {
        var r3 = 65535;
        for (r3 > e3.pending_buf_size - 5 && (r3 = e3.pending_buf_size - 5); ; ) {
          if (e3.lookahead <= 1) {
            if (j(e3), 0 === e3.lookahead && t3 === l2)
              return A2;
            if (0 === e3.lookahead)
              break;
          }
          e3.strstart += e3.lookahead, e3.lookahead = 0;
          var n3 = e3.block_start + r3;
          if ((0 === e3.strstart || e3.strstart >= n3) && (e3.lookahead = e3.strstart - n3, e3.strstart = n3, N2(e3, false), 0 === e3.strm.avail_out))
            return A2;
          if (e3.strstart - e3.block_start >= e3.w_size - z2 && (N2(e3, false), 0 === e3.strm.avail_out))
            return A2;
        }
        return e3.insert = 0, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : (e3.strstart > e3.block_start && (N2(e3, false), e3.strm.avail_out), A2);
      }), new M2(4, 4, 8, 4, Z2), new M2(4, 5, 16, 8, Z2), new M2(4, 6, 32, 32, Z2), new M2(4, 4, 16, 16, W2), new M2(8, 16, 32, 32, W2), new M2(8, 16, 128, 128, W2), new M2(8, 32, 128, 256, W2), new M2(32, 128, 258, 1024, W2), new M2(32, 258, 258, 4096, W2)], r2.deflateInit = function(e3, t3) {
        return Y2(e3, t3, v2, 15, 8, 0);
      }, r2.deflateInit2 = Y2, r2.deflateReset = K2, r2.deflateResetKeep = G2, r2.deflateSetHeader = function(e3, t3) {
        return e3 && e3.state ? 2 !== e3.state.wrap ? _ : (e3.state.gzhead = t3, m2) : _;
      }, r2.deflate = function(e3, t3) {
        var r3, n3, i2, s3;
        if (!e3 || !e3.state || 5 < t3 || t3 < 0)
          return e3 ? R2(e3, _) : _;
        if (n3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === n3.status && t3 !== f2)
          return R2(e3, 0 === e3.avail_out ? -5 : _);
        if (n3.strm = e3, r3 = n3.last_flush, n3.last_flush = t3, n3.status === C2)
          if (2 === n3.wrap)
            e3.adler = 0, U2(n3, 31), U2(n3, 139), U2(n3, 8), n3.gzhead ? (U2(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), U2(n3, 255 & n3.gzhead.time), U2(n3, n3.gzhead.time >> 8 & 255), U2(n3, n3.gzhead.time >> 16 & 255), U2(n3, n3.gzhead.time >> 24 & 255), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (U2(n3, 255 & n3.gzhead.extra.length), U2(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = 69) : (U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 3), n3.status = E2);
          else {
            var a3 = v2 + (n3.w_bits - 8 << 4) << 8;
            a3 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : 6 === n3.level ? 2 : 3) << 6, 0 !== n3.strstart && (a3 |= 32), a3 += 31 - a3 % 31, n3.status = E2, P2(n3, a3), 0 !== n3.strstart && (P2(n3, e3.adler >>> 16), P2(n3, 65535 & e3.adler)), e3.adler = 1;
          }
        if (69 === n3.status)
          if (n3.gzhead.extra) {
            for (i2 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > i2 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i2, i2)), F2(e3), i2 = n3.pending, n3.pending !== n3.pending_buf_size)); )
              U2(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
            n3.gzhead.hcrc && n3.pending > i2 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i2, i2)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = 73);
          } else
            n3.status = 73;
        if (73 === n3.status)
          if (n3.gzhead.name) {
            i2 = n3.pending;
            do {
              if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i2 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i2, i2)), F2(e3), i2 = n3.pending, n3.pending === n3.pending_buf_size)) {
                s3 = 1;
                break;
              }
              s3 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
            } while (0 !== s3);
            n3.gzhead.hcrc && n3.pending > i2 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i2, i2)), 0 === s3 && (n3.gzindex = 0, n3.status = 91);
          } else
            n3.status = 91;
        if (91 === n3.status)
          if (n3.gzhead.comment) {
            i2 = n3.pending;
            do {
              if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i2 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i2, i2)), F2(e3), i2 = n3.pending, n3.pending === n3.pending_buf_size)) {
                s3 = 1;
                break;
              }
              s3 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
            } while (0 !== s3);
            n3.gzhead.hcrc && n3.pending > i2 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i2, i2)), 0 === s3 && (n3.status = 103);
          } else
            n3.status = 103;
        if (103 === n3.status && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && F2(e3), n3.pending + 2 <= n3.pending_buf_size && (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), e3.adler = 0, n3.status = E2)) : n3.status = E2), 0 !== n3.pending) {
          if (F2(e3), 0 === e3.avail_out)
            return n3.last_flush = -1, m2;
        } else if (0 === e3.avail_in && T2(t3) <= T2(r3) && t3 !== f2)
          return R2(e3, -5);
        if (666 === n3.status && 0 !== e3.avail_in)
          return R2(e3, -5);
        if (0 !== e3.avail_in || 0 !== n3.lookahead || t3 !== l2 && 666 !== n3.status) {
          var o3 = 2 === n3.strategy ? function(e4, t4) {
            for (var r4; ; ) {
              if (0 === e4.lookahead && (j(e4), 0 === e4.lookahead)) {
                if (t4 === l2)
                  return A2;
                break;
              }
              if (e4.match_length = 0, r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r4 && (N2(e4, false), 0 === e4.strm.avail_out))
                return A2;
            }
            return e4.insert = 0, t4 === f2 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B2) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I2;
          }(n3, t3) : 3 === n3.strategy ? function(e4, t4) {
            for (var r4, n4, i3, s4, a4 = e4.window; ; ) {
              if (e4.lookahead <= S2) {
                if (j(e4), e4.lookahead <= S2 && t4 === l2)
                  return A2;
                if (0 === e4.lookahead)
                  break;
              }
              if (e4.match_length = 0, e4.lookahead >= x2 && 0 < e4.strstart && (n4 = a4[i3 = e4.strstart - 1]) === a4[++i3] && n4 === a4[++i3] && n4 === a4[++i3]) {
                s4 = e4.strstart + S2;
                do {
                } while (n4 === a4[++i3] && n4 === a4[++i3] && n4 === a4[++i3] && n4 === a4[++i3] && n4 === a4[++i3] && n4 === a4[++i3] && n4 === a4[++i3] && n4 === a4[++i3] && i3 < s4);
                e4.match_length = S2 - (s4 - i3), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
              }
              if (e4.match_length >= x2 ? (r4 = u2._tr_tally(e4, 1, e4.match_length - x2), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r4 && (N2(e4, false), 0 === e4.strm.avail_out))
                return A2;
            }
            return e4.insert = 0, t4 === f2 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B2) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I2;
          }(n3, t3) : h2[n3.level].func(n3, t3);
          if (o3 !== O2 && o3 !== B2 || (n3.status = 666), o3 === A2 || o3 === O2)
            return 0 === e3.avail_out && (n3.last_flush = -1), m2;
          if (o3 === I2 && (1 === t3 ? u2._tr_align(n3) : 5 !== t3 && (u2._tr_stored_block(n3, 0, 0, false), 3 === t3 && (D2(n3.head), 0 === n3.lookahead && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), F2(e3), 0 === e3.avail_out))
            return n3.last_flush = -1, m2;
        }
        return t3 !== f2 ? m2 : n3.wrap <= 0 ? 1 : (2 === n3.wrap ? (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), U2(n3, e3.adler >> 16 & 255), U2(n3, e3.adler >> 24 & 255), U2(n3, 255 & e3.total_in), U2(n3, e3.total_in >> 8 & 255), U2(n3, e3.total_in >> 16 & 255), U2(n3, e3.total_in >> 24 & 255)) : (P2(n3, e3.adler >>> 16), P2(n3, 65535 & e3.adler)), F2(e3), 0 < n3.wrap && (n3.wrap = -n3.wrap), 0 !== n3.pending ? m2 : 1);
      }, r2.deflateEnd = function(e3) {
        var t3;
        return e3 && e3.state ? (t3 = e3.state.status) !== C2 && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E2 && 666 !== t3 ? R2(e3, _) : (e3.state = null, t3 === E2 ? R2(e3, -3) : m2) : _;
      }, r2.deflateSetDictionary = function(e3, t3) {
        var r3, n3, i2, s3, a3, o3, h3, u3, l3 = t3.length;
        if (!e3 || !e3.state)
          return _;
        if (2 === (s3 = (r3 = e3.state).wrap) || 1 === s3 && r3.status !== C2 || r3.lookahead)
          return _;
        for (1 === s3 && (e3.adler = d2(e3.adler, t3, l3, 0)), r3.wrap = 0, l3 >= r3.w_size && (0 === s3 && (D2(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), u3 = new c2.Buf8(r3.w_size), c2.arraySet(u3, t3, l3 - r3.w_size, r3.w_size, 0), t3 = u3, l3 = r3.w_size), a3 = e3.avail_in, o3 = e3.next_in, h3 = e3.input, e3.avail_in = l3, e3.next_in = 0, e3.input = t3, j(r3); r3.lookahead >= x2; ) {
          for (n3 = r3.strstart, i2 = r3.lookahead - (x2 - 1); r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + x2 - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++, --i2; )
            ;
          r3.strstart = n3, r3.lookahead = x2 - 1, j(r3);
        }
        return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = x2 - 1, r3.match_available = 0, e3.next_in = o3, e3.input = h3, e3.avail_in = a3, r3.wrap = s3, m2;
      }, r2.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t2, r2) {
      t2.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e2, t2, r2) {
      t2.exports = function(e3, t3) {
        var r3, n2, i, s2, a2, o2, h2, u2, l2, f2, c2, d2, p2, m2, _, g, b2, v2, y2, w2, k2, x2, S2, z2, C2;
        r3 = e3.state, n2 = e3.next_in, z2 = e3.input, i = n2 + (e3.avail_in - 5), s2 = e3.next_out, C2 = e3.output, a2 = s2 - (t3 - e3.avail_out), o2 = s2 + (e3.avail_out - 257), h2 = r3.dmax, u2 = r3.wsize, l2 = r3.whave, f2 = r3.wnext, c2 = r3.window, d2 = r3.hold, p2 = r3.bits, m2 = r3.lencode, _ = r3.distcode, g = (1 << r3.lenbits) - 1, b2 = (1 << r3.distbits) - 1;
        e:
          do {
            p2 < 15 && (d2 += z2[n2++] << p2, p2 += 8, d2 += z2[n2++] << p2, p2 += 8), v2 = m2[d2 & g];
            t:
              for (; ; ) {
                if (d2 >>>= y2 = v2 >>> 24, p2 -= y2, 0 === (y2 = v2 >>> 16 & 255))
                  C2[s2++] = 65535 & v2;
                else {
                  if (!(16 & y2)) {
                    if (0 == (64 & y2)) {
                      v2 = m2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                      continue t;
                    }
                    if (32 & y2) {
                      r3.mode = 12;
                      break e;
                    }
                    e3.msg = "invalid literal/length code", r3.mode = 30;
                    break e;
                  }
                  w2 = 65535 & v2, (y2 &= 15) && (p2 < y2 && (d2 += z2[n2++] << p2, p2 += 8), w2 += d2 & (1 << y2) - 1, d2 >>>= y2, p2 -= y2), p2 < 15 && (d2 += z2[n2++] << p2, p2 += 8, d2 += z2[n2++] << p2, p2 += 8), v2 = _[d2 & b2];
                  r:
                    for (; ; ) {
                      if (d2 >>>= y2 = v2 >>> 24, p2 -= y2, !(16 & (y2 = v2 >>> 16 & 255))) {
                        if (0 == (64 & y2)) {
                          v2 = _[(65535 & v2) + (d2 & (1 << y2) - 1)];
                          continue r;
                        }
                        e3.msg = "invalid distance code", r3.mode = 30;
                        break e;
                      }
                      if (k2 = 65535 & v2, p2 < (y2 &= 15) && (d2 += z2[n2++] << p2, (p2 += 8) < y2 && (d2 += z2[n2++] << p2, p2 += 8)), h2 < (k2 += d2 & (1 << y2) - 1)) {
                        e3.msg = "invalid distance too far back", r3.mode = 30;
                        break e;
                      }
                      if (d2 >>>= y2, p2 -= y2, (y2 = s2 - a2) < k2) {
                        if (l2 < (y2 = k2 - y2) && r3.sane) {
                          e3.msg = "invalid distance too far back", r3.mode = 30;
                          break e;
                        }
                        if (S2 = c2, (x2 = 0) === f2) {
                          if (x2 += u2 - y2, y2 < w2) {
                            for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                              ;
                            x2 = s2 - k2, S2 = C2;
                          }
                        } else if (f2 < y2) {
                          if (x2 += u2 + f2 - y2, (y2 -= f2) < w2) {
                            for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                              ;
                            if (x2 = 0, f2 < w2) {
                              for (w2 -= y2 = f2; C2[s2++] = c2[x2++], --y2; )
                                ;
                              x2 = s2 - k2, S2 = C2;
                            }
                          }
                        } else if (x2 += f2 - y2, y2 < w2) {
                          for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                            ;
                          x2 = s2 - k2, S2 = C2;
                        }
                        for (; 2 < w2; )
                          C2[s2++] = S2[x2++], C2[s2++] = S2[x2++], C2[s2++] = S2[x2++], w2 -= 3;
                        w2 && (C2[s2++] = S2[x2++], 1 < w2 && (C2[s2++] = S2[x2++]));
                      } else {
                        for (x2 = s2 - k2; C2[s2++] = C2[x2++], C2[s2++] = C2[x2++], C2[s2++] = C2[x2++], 2 < (w2 -= 3); )
                          ;
                        w2 && (C2[s2++] = C2[x2++], 1 < w2 && (C2[s2++] = C2[x2++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n2 < i && s2 < o2);
        n2 -= w2 = p2 >> 3, d2 &= (1 << (p2 -= w2 << 3)) - 1, e3.next_in = n2, e3.next_out = s2, e3.avail_in = n2 < i ? i - n2 + 5 : 5 - (n2 - i), e3.avail_out = s2 < o2 ? o2 - s2 + 257 : 257 - (s2 - o2), r3.hold = d2, r3.bits = p2;
      };
    }, {}], 49: [function(e2, t2, r2) {
      var I2 = e2("../utils/common"), O2 = e2("./adler32"), B2 = e2("./crc32"), R2 = e2("./inffast"), T2 = e2("./inftrees"), D2 = 1, F2 = 2, N2 = 0, U2 = -2, P2 = 1, n2 = 852, i = 592;
      function L2(e3) {
        return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
      }
      function s2() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I2.Buf16(320), this.work = new I2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a2(e3) {
        var t3;
        return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = P2, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I2.Buf32(n2), t3.distcode = t3.distdyn = new I2.Buf32(i), t3.sane = 1, t3.back = -1, N2) : U2;
      }
      function o2(e3) {
        var t3;
        return e3 && e3.state ? ((t3 = e3.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a2(e3)) : U2;
      }
      function h2(e3, t3) {
        var r3, n3;
        return e3 && e3.state ? (n3 = e3.state, t3 < 0 ? (r3 = 0, t3 = -t3) : (r3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U2 : (null !== n3.window && n3.wbits !== t3 && (n3.window = null), n3.wrap = r3, n3.wbits = t3, o2(e3))) : U2;
      }
      function u2(e3, t3) {
        var r3, n3;
        return e3 ? (n3 = new s2(), (e3.state = n3).window = null, (r3 = h2(e3, t3)) !== N2 && (e3.state = null), r3) : U2;
      }
      var l2, f2, c2 = true;
      function j(e3) {
        if (c2) {
          var t3;
          for (l2 = new I2.Buf32(512), f2 = new I2.Buf32(32), t3 = 0; t3 < 144; )
            e3.lens[t3++] = 8;
          for (; t3 < 256; )
            e3.lens[t3++] = 9;
          for (; t3 < 280; )
            e3.lens[t3++] = 7;
          for (; t3 < 288; )
            e3.lens[t3++] = 8;
          for (T2(D2, e3.lens, 0, 288, l2, 0, e3.work, { bits: 9 }), t3 = 0; t3 < 32; )
            e3.lens[t3++] = 5;
          T2(F2, e3.lens, 0, 32, f2, 0, e3.work, { bits: 5 }), c2 = false;
        }
        e3.lencode = l2, e3.lenbits = 9, e3.distcode = f2, e3.distbits = 5;
      }
      function Z2(e3, t3, r3, n3) {
        var i2, s3 = e3.state;
        return null === s3.window && (s3.wsize = 1 << s3.wbits, s3.wnext = 0, s3.whave = 0, s3.window = new I2.Buf8(s3.wsize)), n3 >= s3.wsize ? (I2.arraySet(s3.window, t3, r3 - s3.wsize, s3.wsize, 0), s3.wnext = 0, s3.whave = s3.wsize) : (n3 < (i2 = s3.wsize - s3.wnext) && (i2 = n3), I2.arraySet(s3.window, t3, r3 - n3, i2, s3.wnext), (n3 -= i2) ? (I2.arraySet(s3.window, t3, r3 - n3, n3, 0), s3.wnext = n3, s3.whave = s3.wsize) : (s3.wnext += i2, s3.wnext === s3.wsize && (s3.wnext = 0), s3.whave < s3.wsize && (s3.whave += i2))), 0;
      }
      r2.inflateReset = o2, r2.inflateReset2 = h2, r2.inflateResetKeep = a2, r2.inflateInit = function(e3) {
        return u2(e3, 15);
      }, r2.inflateInit2 = u2, r2.inflate = function(e3, t3) {
        var r3, n3, i2, s3, a3, o3, h3, u3, l3, f3, c3, d2, p2, m2, _, g, b2, v2, y2, w2, k2, x2, S2, z2, C2 = 0, E2 = new I2.Buf8(4), A2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in)
          return U2;
        12 === (r3 = e3.state).mode && (r3.mode = 13), a3 = e3.next_out, i2 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l3 = r3.bits, f3 = o3, c3 = h3, x2 = N2;
        e:
          for (; ; )
            switch (r3.mode) {
              case P2:
                if (0 === r3.wrap) {
                  r3.mode = 13;
                  break;
                }
                for (; l3 < 16; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (2 & r3.wrap && 35615 === u3) {
                  E2[r3.check = 0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0), l3 = u3 = 0, r3.mode = 2;
                  break;
                }
                if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & u3) << 8) + (u3 >> 8)) % 31) {
                  e3.msg = "incorrect header check", r3.mode = 30;
                  break;
                }
                if (8 != (15 & u3)) {
                  e3.msg = "unknown compression method", r3.mode = 30;
                  break;
                }
                if (l3 -= 4, k2 = 8 + (15 & (u3 >>>= 4)), 0 === r3.wbits)
                  r3.wbits = k2;
                else if (k2 > r3.wbits) {
                  e3.msg = "invalid window size", r3.mode = 30;
                  break;
                }
                r3.dmax = 1 << k2, e3.adler = r3.check = 1, r3.mode = 512 & u3 ? 10 : 12, l3 = u3 = 0;
                break;
              case 2:
                for (; l3 < 16; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (r3.flags = u3, 8 != (255 & r3.flags)) {
                  e3.msg = "unknown compression method", r3.mode = 30;
                  break;
                }
                if (57344 & r3.flags) {
                  e3.msg = "unknown header flags set", r3.mode = 30;
                  break;
                }
                r3.head && (r3.head.text = u3 >> 8 & 1), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l3 = u3 = 0, r3.mode = 3;
              case 3:
                for (; l3 < 32; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                r3.head && (r3.head.time = u3), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, E2[2] = u3 >>> 16 & 255, E2[3] = u3 >>> 24 & 255, r3.check = B2(r3.check, E2, 4, 0)), l3 = u3 = 0, r3.mode = 4;
              case 4:
                for (; l3 < 16; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                r3.head && (r3.head.xflags = 255 & u3, r3.head.os = u3 >> 8), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l3 = u3 = 0, r3.mode = 5;
              case 5:
                if (1024 & r3.flags) {
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.length = u3, r3.head && (r3.head.extra_len = u3), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l3 = u3 = 0;
                } else
                  r3.head && (r3.head.extra = null);
                r3.mode = 6;
              case 6:
                if (1024 & r3.flags && (o3 < (d2 = r3.length) && (d2 = o3), d2 && (r3.head && (k2 = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), I2.arraySet(r3.head.extra, n3, s3, d2, k2)), 512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, r3.length -= d2), r3.length))
                  break e;
                r3.length = 0, r3.mode = 7;
              case 7:
                if (2048 & r3.flags) {
                  if (0 === o3)
                    break e;
                  for (d2 = 0; k2 = n3[s3 + d2++], r3.head && k2 && r3.length < 65536 && (r3.head.name += String.fromCharCode(k2)), k2 && d2 < o3; )
                    ;
                  if (512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, k2)
                    break e;
                } else
                  r3.head && (r3.head.name = null);
                r3.length = 0, r3.mode = 8;
              case 8:
                if (4096 & r3.flags) {
                  if (0 === o3)
                    break e;
                  for (d2 = 0; k2 = n3[s3 + d2++], r3.head && k2 && r3.length < 65536 && (r3.head.comment += String.fromCharCode(k2)), k2 && d2 < o3; )
                    ;
                  if (512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, k2)
                    break e;
                } else
                  r3.head && (r3.head.comment = null);
                r3.mode = 9;
              case 9:
                if (512 & r3.flags) {
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (u3 !== (65535 & r3.check)) {
                    e3.msg = "header crc mismatch", r3.mode = 30;
                    break;
                  }
                  l3 = u3 = 0;
                }
                r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), e3.adler = r3.check = 0, r3.mode = 12;
                break;
              case 10:
                for (; l3 < 32; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                e3.adler = r3.check = L2(u3), l3 = u3 = 0, r3.mode = 11;
              case 11:
                if (0 === r3.havedict)
                  return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, 2;
                e3.adler = r3.check = 1, r3.mode = 12;
              case 12:
                if (5 === t3 || 6 === t3)
                  break e;
              case 13:
                if (r3.last) {
                  u3 >>>= 7 & l3, l3 -= 7 & l3, r3.mode = 27;
                  break;
                }
                for (; l3 < 3; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                switch (r3.last = 1 & u3, l3 -= 1, 3 & (u3 >>>= 1)) {
                  case 0:
                    r3.mode = 14;
                    break;
                  case 1:
                    if (j(r3), r3.mode = 20, 6 !== t3)
                      break;
                    u3 >>>= 2, l3 -= 2;
                    break e;
                  case 2:
                    r3.mode = 17;
                    break;
                  case 3:
                    e3.msg = "invalid block type", r3.mode = 30;
                }
                u3 >>>= 2, l3 -= 2;
                break;
              case 14:
                for (u3 >>>= 7 & l3, l3 -= 7 & l3; l3 < 32; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if ((65535 & u3) != (u3 >>> 16 ^ 65535)) {
                  e3.msg = "invalid stored block lengths", r3.mode = 30;
                  break;
                }
                if (r3.length = 65535 & u3, l3 = u3 = 0, r3.mode = 15, 6 === t3)
                  break e;
              case 15:
                r3.mode = 16;
              case 16:
                if (d2 = r3.length) {
                  if (o3 < d2 && (d2 = o3), h3 < d2 && (d2 = h3), 0 === d2)
                    break e;
                  I2.arraySet(i2, n3, s3, d2, a3), o3 -= d2, s3 += d2, h3 -= d2, a3 += d2, r3.length -= d2;
                  break;
                }
                r3.mode = 12;
                break;
              case 17:
                for (; l3 < 14; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (r3.nlen = 257 + (31 & u3), u3 >>>= 5, l3 -= 5, r3.ndist = 1 + (31 & u3), u3 >>>= 5, l3 -= 5, r3.ncode = 4 + (15 & u3), u3 >>>= 4, l3 -= 4, 286 < r3.nlen || 30 < r3.ndist) {
                  e3.msg = "too many length or distance symbols", r3.mode = 30;
                  break;
                }
                r3.have = 0, r3.mode = 18;
              case 18:
                for (; r3.have < r3.ncode; ) {
                  for (; l3 < 3; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.lens[A2[r3.have++]] = 7 & u3, u3 >>>= 3, l3 -= 3;
                }
                for (; r3.have < 19; )
                  r3.lens[A2[r3.have++]] = 0;
                if (r3.lencode = r3.lendyn, r3.lenbits = 7, S2 = { bits: r3.lenbits }, x2 = T2(0, r3.lens, 0, 19, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                  e3.msg = "invalid code lengths set", r3.mode = 30;
                  break;
                }
                r3.have = 0, r3.mode = 19;
              case 19:
                for (; r3.have < r3.nlen + r3.ndist; ) {
                  for (; g = (C2 = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_ = C2 >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (b2 < 16)
                    u3 >>>= _, l3 -= _, r3.lens[r3.have++] = b2;
                  else {
                    if (16 === b2) {
                      for (z2 = _ + 2; l3 < z2; ) {
                        if (0 === o3)
                          break e;
                        o3--, u3 += n3[s3++] << l3, l3 += 8;
                      }
                      if (u3 >>>= _, l3 -= _, 0 === r3.have) {
                        e3.msg = "invalid bit length repeat", r3.mode = 30;
                        break;
                      }
                      k2 = r3.lens[r3.have - 1], d2 = 3 + (3 & u3), u3 >>>= 2, l3 -= 2;
                    } else if (17 === b2) {
                      for (z2 = _ + 3; l3 < z2; ) {
                        if (0 === o3)
                          break e;
                        o3--, u3 += n3[s3++] << l3, l3 += 8;
                      }
                      l3 -= _, k2 = 0, d2 = 3 + (7 & (u3 >>>= _)), u3 >>>= 3, l3 -= 3;
                    } else {
                      for (z2 = _ + 7; l3 < z2; ) {
                        if (0 === o3)
                          break e;
                        o3--, u3 += n3[s3++] << l3, l3 += 8;
                      }
                      l3 -= _, k2 = 0, d2 = 11 + (127 & (u3 >>>= _)), u3 >>>= 7, l3 -= 7;
                    }
                    if (r3.have + d2 > r3.nlen + r3.ndist) {
                      e3.msg = "invalid bit length repeat", r3.mode = 30;
                      break;
                    }
                    for (; d2--; )
                      r3.lens[r3.have++] = k2;
                  }
                }
                if (30 === r3.mode)
                  break;
                if (0 === r3.lens[256]) {
                  e3.msg = "invalid code -- missing end-of-block", r3.mode = 30;
                  break;
                }
                if (r3.lenbits = 9, S2 = { bits: r3.lenbits }, x2 = T2(D2, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                  e3.msg = "invalid literal/lengths set", r3.mode = 30;
                  break;
                }
                if (r3.distbits = 6, r3.distcode = r3.distdyn, S2 = { bits: r3.distbits }, x2 = T2(F2, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, S2), r3.distbits = S2.bits, x2) {
                  e3.msg = "invalid distances set", r3.mode = 30;
                  break;
                }
                if (r3.mode = 20, 6 === t3)
                  break e;
              case 20:
                r3.mode = 21;
              case 21:
                if (6 <= o3 && 258 <= h3) {
                  e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, R2(e3, c3), a3 = e3.next_out, i2 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l3 = r3.bits, 12 === r3.mode && (r3.back = -1);
                  break;
                }
                for (r3.back = 0; g = (C2 = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_ = C2 >>> 24) <= l3); ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (g && 0 == (240 & g)) {
                  for (v2 = _, y2 = g, w2 = b2; g = (C2 = r3.lencode[w2 + ((u3 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_ = C2 >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  u3 >>>= v2, l3 -= v2, r3.back += v2;
                }
                if (u3 >>>= _, l3 -= _, r3.back += _, r3.length = b2, 0 === g) {
                  r3.mode = 26;
                  break;
                }
                if (32 & g) {
                  r3.back = -1, r3.mode = 12;
                  break;
                }
                if (64 & g) {
                  e3.msg = "invalid literal/length code", r3.mode = 30;
                  break;
                }
                r3.extra = 15 & g, r3.mode = 22;
              case 22:
                if (r3.extra) {
                  for (z2 = r3.extra; l3 < z2; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.length += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
                }
                r3.was = r3.length, r3.mode = 23;
              case 23:
                for (; g = (C2 = r3.distcode[u3 & (1 << r3.distbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_ = C2 >>> 24) <= l3); ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (0 == (240 & g)) {
                  for (v2 = _, y2 = g, w2 = b2; g = (C2 = r3.distcode[w2 + ((u3 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_ = C2 >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  u3 >>>= v2, l3 -= v2, r3.back += v2;
                }
                if (u3 >>>= _, l3 -= _, r3.back += _, 64 & g) {
                  e3.msg = "invalid distance code", r3.mode = 30;
                  break;
                }
                r3.offset = b2, r3.extra = 15 & g, r3.mode = 24;
              case 24:
                if (r3.extra) {
                  for (z2 = r3.extra; l3 < z2; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.offset += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
                }
                if (r3.offset > r3.dmax) {
                  e3.msg = "invalid distance too far back", r3.mode = 30;
                  break;
                }
                r3.mode = 25;
              case 25:
                if (0 === h3)
                  break e;
                if (d2 = c3 - h3, r3.offset > d2) {
                  if ((d2 = r3.offset - d2) > r3.whave && r3.sane) {
                    e3.msg = "invalid distance too far back", r3.mode = 30;
                    break;
                  }
                  p2 = d2 > r3.wnext ? (d2 -= r3.wnext, r3.wsize - d2) : r3.wnext - d2, d2 > r3.length && (d2 = r3.length), m2 = r3.window;
                } else
                  m2 = i2, p2 = a3 - r3.offset, d2 = r3.length;
                for (h3 < d2 && (d2 = h3), h3 -= d2, r3.length -= d2; i2[a3++] = m2[p2++], --d2; )
                  ;
                0 === r3.length && (r3.mode = 21);
                break;
              case 26:
                if (0 === h3)
                  break e;
                i2[a3++] = r3.length, h3--, r3.mode = 21;
                break;
              case 27:
                if (r3.wrap) {
                  for (; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 |= n3[s3++] << l3, l3 += 8;
                  }
                  if (c3 -= h3, e3.total_out += c3, r3.total += c3, c3 && (e3.adler = r3.check = r3.flags ? B2(r3.check, i2, c3, a3 - c3) : O2(r3.check, i2, c3, a3 - c3)), c3 = h3, (r3.flags ? u3 : L2(u3)) !== r3.check) {
                    e3.msg = "incorrect data check", r3.mode = 30;
                    break;
                  }
                  l3 = u3 = 0;
                }
                r3.mode = 28;
              case 28:
                if (r3.wrap && r3.flags) {
                  for (; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (u3 !== (4294967295 & r3.total)) {
                    e3.msg = "incorrect length check", r3.mode = 30;
                    break;
                  }
                  l3 = u3 = 0;
                }
                r3.mode = 29;
              case 29:
                x2 = 1;
                break e;
              case 30:
                x2 = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U2;
            }
        return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, (r3.wsize || c3 !== e3.avail_out && r3.mode < 30 && (r3.mode < 27 || 4 !== t3)) && Z2(e3, e3.output, e3.next_out, c3 - e3.avail_out) ? (r3.mode = 31, -4) : (f3 -= e3.avail_in, c3 -= e3.avail_out, e3.total_in += f3, e3.total_out += c3, r3.total += c3, r3.wrap && c3 && (e3.adler = r3.check = r3.flags ? B2(r3.check, i2, c3, e3.next_out - c3) : O2(r3.check, i2, c3, e3.next_out - c3)), e3.data_type = r3.bits + (r3.last ? 64 : 0) + (12 === r3.mode ? 128 : 0) + (20 === r3.mode || 15 === r3.mode ? 256 : 0), (0 == f3 && 0 === c3 || 4 === t3) && x2 === N2 && (x2 = -5), x2);
      }, r2.inflateEnd = function(e3) {
        if (!e3 || !e3.state)
          return U2;
        var t3 = e3.state;
        return t3.window && (t3.window = null), e3.state = null, N2;
      }, r2.inflateGetHeader = function(e3, t3) {
        var r3;
        return e3 && e3.state ? 0 == (2 & (r3 = e3.state).wrap) ? U2 : ((r3.head = t3).done = false, N2) : U2;
      }, r2.inflateSetDictionary = function(e3, t3) {
        var r3, n3 = t3.length;
        return e3 && e3.state ? 0 !== (r3 = e3.state).wrap && 11 !== r3.mode ? U2 : 11 === r3.mode && O2(1, t3, n3, 0) !== r3.check ? -3 : Z2(e3, t3, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, N2) : U2;
      }, r2.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t2, r2) {
      var D2 = e2("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t2.exports = function(e3, t3, r3, n2, i, s2, a2, o2) {
        var h2, u2, l2, f2, c2, d2, p2, m2, _, g = o2.bits, b2 = 0, v2 = 0, y2 = 0, w2 = 0, k2 = 0, x2 = 0, S2 = 0, z2 = 0, C2 = 0, E2 = 0, A2 = null, I2 = 0, O2 = new D2.Buf16(16), B2 = new D2.Buf16(16), R2 = null, T2 = 0;
        for (b2 = 0; b2 <= 15; b2++)
          O2[b2] = 0;
        for (v2 = 0; v2 < n2; v2++)
          O2[t3[r3 + v2]]++;
        for (k2 = g, w2 = 15; 1 <= w2 && 0 === O2[w2]; w2--)
          ;
        if (w2 < k2 && (k2 = w2), 0 === w2)
          return i[s2++] = 20971520, i[s2++] = 20971520, o2.bits = 1, 0;
        for (y2 = 1; y2 < w2 && 0 === O2[y2]; y2++)
          ;
        for (k2 < y2 && (k2 = y2), b2 = z2 = 1; b2 <= 15; b2++)
          if (z2 <<= 1, (z2 -= O2[b2]) < 0)
            return -1;
        if (0 < z2 && (0 === e3 || 1 !== w2))
          return -1;
        for (B2[1] = 0, b2 = 1; b2 < 15; b2++)
          B2[b2 + 1] = B2[b2] + O2[b2];
        for (v2 = 0; v2 < n2; v2++)
          0 !== t3[r3 + v2] && (a2[B2[t3[r3 + v2]]++] = v2);
        if (d2 = 0 === e3 ? (A2 = R2 = a2, 19) : 1 === e3 ? (A2 = F2, I2 -= 257, R2 = N2, T2 -= 257, 256) : (A2 = U2, R2 = P2, -1), b2 = y2, c2 = s2, S2 = v2 = E2 = 0, l2 = -1, f2 = (C2 = 1 << (x2 = k2)) - 1, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2)
          return 1;
        for (; ; ) {
          for (p2 = b2 - S2, _ = a2[v2] < d2 ? (m2 = 0, a2[v2]) : a2[v2] > d2 ? (m2 = R2[T2 + a2[v2]], A2[I2 + a2[v2]]) : (m2 = 96, 0), h2 = 1 << b2 - S2, y2 = u2 = 1 << x2; i[c2 + (E2 >> S2) + (u2 -= h2)] = p2 << 24 | m2 << 16 | _ | 0, 0 !== u2; )
            ;
          for (h2 = 1 << b2 - 1; E2 & h2; )
            h2 >>= 1;
          if (0 !== h2 ? (E2 &= h2 - 1, E2 += h2) : E2 = 0, v2++, 0 == --O2[b2]) {
            if (b2 === w2)
              break;
            b2 = t3[r3 + a2[v2]];
          }
          if (k2 < b2 && (E2 & f2) !== l2) {
            for (0 === S2 && (S2 = k2), c2 += y2, z2 = 1 << (x2 = b2 - S2); x2 + S2 < w2 && !((z2 -= O2[x2 + S2]) <= 0); )
              x2++, z2 <<= 1;
            if (C2 += 1 << x2, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2)
              return 1;
            i[l2 = E2 & f2] = k2 << 24 | x2 << 16 | c2 - s2 | 0;
          }
        }
        return 0 !== E2 && (i[c2 + E2] = b2 - S2 << 24 | 64 << 16 | 0), o2.bits = k2, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e2, t2, r2) {
      t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e2, t2, r2) {
      var i = e2("../utils/common"), o2 = 0, h2 = 1;
      function n2(e3) {
        for (var t3 = e3.length; 0 <= --t3; )
          e3[t3] = 0;
      }
      var s2 = 0, a2 = 29, u2 = 256, l2 = u2 + 1 + a2, f2 = 30, c2 = 19, _ = 2 * l2 + 1, g = 15, d2 = 16, p2 = 7, m2 = 256, b2 = 16, v2 = 17, y2 = 18, w2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l2 + 2));
      n2(z2);
      var C2 = new Array(2 * f2);
      n2(C2);
      var E2 = new Array(512);
      n2(E2);
      var A2 = new Array(256);
      n2(A2);
      var I2 = new Array(a2);
      n2(I2);
      var O2, B2, R2, T2 = new Array(f2);
      function D2(e3, t3, r3, n3, i2) {
        this.static_tree = e3, this.extra_bits = t3, this.extra_base = r3, this.elems = n3, this.max_length = i2, this.has_stree = e3 && e3.length;
      }
      function F2(e3, t3) {
        this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t3;
      }
      function N2(e3) {
        return e3 < 256 ? E2[e3] : E2[256 + (e3 >>> 7)];
      }
      function U2(e3, t3) {
        e3.pending_buf[e3.pending++] = 255 & t3, e3.pending_buf[e3.pending++] = t3 >>> 8 & 255;
      }
      function P2(e3, t3, r3) {
        e3.bi_valid > d2 - r3 ? (e3.bi_buf |= t3 << e3.bi_valid & 65535, U2(e3, e3.bi_buf), e3.bi_buf = t3 >> d2 - e3.bi_valid, e3.bi_valid += r3 - d2) : (e3.bi_buf |= t3 << e3.bi_valid & 65535, e3.bi_valid += r3);
      }
      function L2(e3, t3, r3) {
        P2(e3, r3[2 * t3], r3[2 * t3 + 1]);
      }
      function j(e3, t3) {
        for (var r3 = 0; r3 |= 1 & e3, e3 >>>= 1, r3 <<= 1, 0 < --t3; )
          ;
        return r3 >>> 1;
      }
      function Z2(e3, t3, r3) {
        var n3, i2, s3 = new Array(g + 1), a3 = 0;
        for (n3 = 1; n3 <= g; n3++)
          s3[n3] = a3 = a3 + r3[n3 - 1] << 1;
        for (i2 = 0; i2 <= t3; i2++) {
          var o3 = e3[2 * i2 + 1];
          0 !== o3 && (e3[2 * i2] = j(s3[o3]++, o3));
        }
      }
      function W2(e3) {
        var t3;
        for (t3 = 0; t3 < l2; t3++)
          e3.dyn_ltree[2 * t3] = 0;
        for (t3 = 0; t3 < f2; t3++)
          e3.dyn_dtree[2 * t3] = 0;
        for (t3 = 0; t3 < c2; t3++)
          e3.bl_tree[2 * t3] = 0;
        e3.dyn_ltree[2 * m2] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
      }
      function M2(e3) {
        8 < e3.bi_valid ? U2(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
      }
      function H2(e3, t3, r3, n3) {
        var i2 = 2 * t3, s3 = 2 * r3;
        return e3[i2] < e3[s3] || e3[i2] === e3[s3] && n3[t3] <= n3[r3];
      }
      function G2(e3, t3, r3) {
        for (var n3 = e3.heap[r3], i2 = r3 << 1; i2 <= e3.heap_len && (i2 < e3.heap_len && H2(t3, e3.heap[i2 + 1], e3.heap[i2], e3.depth) && i2++, !H2(t3, n3, e3.heap[i2], e3.depth)); )
          e3.heap[r3] = e3.heap[i2], r3 = i2, i2 <<= 1;
        e3.heap[r3] = n3;
      }
      function K2(e3, t3, r3) {
        var n3, i2, s3, a3, o3 = 0;
        if (0 !== e3.last_lit)
          for (; n3 = e3.pending_buf[e3.d_buf + 2 * o3] << 8 | e3.pending_buf[e3.d_buf + 2 * o3 + 1], i2 = e3.pending_buf[e3.l_buf + o3], o3++, 0 === n3 ? L2(e3, i2, t3) : (L2(e3, (s3 = A2[i2]) + u2 + 1, t3), 0 !== (a3 = w2[s3]) && P2(e3, i2 -= I2[s3], a3), L2(e3, s3 = N2(--n3), r3), 0 !== (a3 = k2[s3]) && P2(e3, n3 -= T2[s3], a3)), o3 < e3.last_lit; )
            ;
        L2(e3, m2, t3);
      }
      function Y2(e3, t3) {
        var r3, n3, i2, s3 = t3.dyn_tree, a3 = t3.stat_desc.static_tree, o3 = t3.stat_desc.has_stree, h3 = t3.stat_desc.elems, u3 = -1;
        for (e3.heap_len = 0, e3.heap_max = _, r3 = 0; r3 < h3; r3++)
          0 !== s3[2 * r3] ? (e3.heap[++e3.heap_len] = u3 = r3, e3.depth[r3] = 0) : s3[2 * r3 + 1] = 0;
        for (; e3.heap_len < 2; )
          s3[2 * (i2 = e3.heap[++e3.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e3.depth[i2] = 0, e3.opt_len--, o3 && (e3.static_len -= a3[2 * i2 + 1]);
        for (t3.max_code = u3, r3 = e3.heap_len >> 1; 1 <= r3; r3--)
          G2(e3, s3, r3);
        for (i2 = h3; r3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], G2(e3, s3, 1), n3 = e3.heap[1], e3.heap[--e3.heap_max] = r3, e3.heap[--e3.heap_max] = n3, s3[2 * i2] = s3[2 * r3] + s3[2 * n3], e3.depth[i2] = (e3.depth[r3] >= e3.depth[n3] ? e3.depth[r3] : e3.depth[n3]) + 1, s3[2 * r3 + 1] = s3[2 * n3 + 1] = i2, e3.heap[1] = i2++, G2(e3, s3, 1), 2 <= e3.heap_len; )
          ;
        e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t4) {
          var r4, n4, i3, s4, a4, o4, h4 = t4.dyn_tree, u4 = t4.max_code, l3 = t4.stat_desc.static_tree, f3 = t4.stat_desc.has_stree, c3 = t4.stat_desc.extra_bits, d3 = t4.stat_desc.extra_base, p3 = t4.stat_desc.max_length, m3 = 0;
          for (s4 = 0; s4 <= g; s4++)
            e4.bl_count[s4] = 0;
          for (h4[2 * e4.heap[e4.heap_max] + 1] = 0, r4 = e4.heap_max + 1; r4 < _; r4++)
            p3 < (s4 = h4[2 * h4[2 * (n4 = e4.heap[r4]) + 1] + 1] + 1) && (s4 = p3, m3++), h4[2 * n4 + 1] = s4, u4 < n4 || (e4.bl_count[s4]++, a4 = 0, d3 <= n4 && (a4 = c3[n4 - d3]), o4 = h4[2 * n4], e4.opt_len += o4 * (s4 + a4), f3 && (e4.static_len += o4 * (l3[2 * n4 + 1] + a4)));
          if (0 !== m3) {
            do {
              for (s4 = p3 - 1; 0 === e4.bl_count[s4]; )
                s4--;
              e4.bl_count[s4]--, e4.bl_count[s4 + 1] += 2, e4.bl_count[p3]--, m3 -= 2;
            } while (0 < m3);
            for (s4 = p3; 0 !== s4; s4--)
              for (n4 = e4.bl_count[s4]; 0 !== n4; )
                u4 < (i3 = e4.heap[--r4]) || (h4[2 * i3 + 1] !== s4 && (e4.opt_len += (s4 - h4[2 * i3 + 1]) * h4[2 * i3], h4[2 * i3 + 1] = s4), n4--);
          }
        }(e3, t3), Z2(s3, u3, e3.bl_count);
      }
      function X2(e3, t3, r3) {
        var n3, i2, s3 = -1, a3 = t3[1], o3 = 0, h3 = 7, u3 = 4;
        for (0 === a3 && (h3 = 138, u3 = 3), t3[2 * (r3 + 1) + 1] = 65535, n3 = 0; n3 <= r3; n3++)
          i2 = a3, a3 = t3[2 * (n3 + 1) + 1], ++o3 < h3 && i2 === a3 || (o3 < u3 ? e3.bl_tree[2 * i2] += o3 : 0 !== i2 ? (i2 !== s3 && e3.bl_tree[2 * i2]++, e3.bl_tree[2 * b2]++) : o3 <= 10 ? e3.bl_tree[2 * v2]++ : e3.bl_tree[2 * y2]++, s3 = i2, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i2 === a3 ? (h3 = 6, 3) : (h3 = 7, 4));
      }
      function V2(e3, t3, r3) {
        var n3, i2, s3 = -1, a3 = t3[1], o3 = 0, h3 = 7, u3 = 4;
        for (0 === a3 && (h3 = 138, u3 = 3), n3 = 0; n3 <= r3; n3++)
          if (i2 = a3, a3 = t3[2 * (n3 + 1) + 1], !(++o3 < h3 && i2 === a3)) {
            if (o3 < u3)
              for (; L2(e3, i2, e3.bl_tree), 0 != --o3; )
                ;
            else
              0 !== i2 ? (i2 !== s3 && (L2(e3, i2, e3.bl_tree), o3--), L2(e3, b2, e3.bl_tree), P2(e3, o3 - 3, 2)) : o3 <= 10 ? (L2(e3, v2, e3.bl_tree), P2(e3, o3 - 3, 3)) : (L2(e3, y2, e3.bl_tree), P2(e3, o3 - 11, 7));
            s3 = i2, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i2 === a3 ? (h3 = 6, 3) : (h3 = 7, 4);
          }
      }
      n2(T2);
      var q2 = false;
      function J2(e3, t3, r3, n3) {
        P2(e3, (s2 << 1) + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
          M2(e4), n4 && (U2(e4, r4), U2(e4, ~r4)), i.arraySet(e4.pending_buf, e4.window, t4, r4, e4.pending), e4.pending += r4;
        }(e3, t3, r3, true);
      }
      r2._tr_init = function(e3) {
        q2 || (function() {
          var e4, t3, r3, n3, i2, s3 = new Array(g + 1);
          for (n3 = r3 = 0; n3 < a2 - 1; n3++)
            for (I2[n3] = r3, e4 = 0; e4 < 1 << w2[n3]; e4++)
              A2[r3++] = n3;
          for (A2[r3 - 1] = n3, n3 = i2 = 0; n3 < 16; n3++)
            for (T2[n3] = i2, e4 = 0; e4 < 1 << k2[n3]; e4++)
              E2[i2++] = n3;
          for (i2 >>= 7; n3 < f2; n3++)
            for (T2[n3] = i2 << 7, e4 = 0; e4 < 1 << k2[n3] - 7; e4++)
              E2[256 + i2++] = n3;
          for (t3 = 0; t3 <= g; t3++)
            s3[t3] = 0;
          for (e4 = 0; e4 <= 143; )
            z2[2 * e4 + 1] = 8, e4++, s3[8]++;
          for (; e4 <= 255; )
            z2[2 * e4 + 1] = 9, e4++, s3[9]++;
          for (; e4 <= 279; )
            z2[2 * e4 + 1] = 7, e4++, s3[7]++;
          for (; e4 <= 287; )
            z2[2 * e4 + 1] = 8, e4++, s3[8]++;
          for (Z2(z2, l2 + 1, s3), e4 = 0; e4 < f2; e4++)
            C2[2 * e4 + 1] = 5, C2[2 * e4] = j(e4, 5);
          O2 = new D2(z2, w2, u2 + 1, l2, g), B2 = new D2(C2, k2, 0, f2, g), R2 = new D2(new Array(0), x2, 0, c2, p2);
        }(), q2 = true), e3.l_desc = new F2(e3.dyn_ltree, O2), e3.d_desc = new F2(e3.dyn_dtree, B2), e3.bl_desc = new F2(e3.bl_tree, R2), e3.bi_buf = 0, e3.bi_valid = 0, W2(e3);
      }, r2._tr_stored_block = J2, r2._tr_flush_block = function(e3, t3, r3, n3) {
        var i2, s3, a3 = 0;
        0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
          var t4, r4 = 4093624447;
          for (t4 = 0; t4 <= 31; t4++, r4 >>>= 1)
            if (1 & r4 && 0 !== e4.dyn_ltree[2 * t4])
              return o2;
          if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26])
            return h2;
          for (t4 = 32; t4 < u2; t4++)
            if (0 !== e4.dyn_ltree[2 * t4])
              return h2;
          return o2;
        }(e3)), Y2(e3, e3.l_desc), Y2(e3, e3.d_desc), a3 = function(e4) {
          var t4;
          for (X2(e4, e4.dyn_ltree, e4.l_desc.max_code), X2(e4, e4.dyn_dtree, e4.d_desc.max_code), Y2(e4, e4.bl_desc), t4 = c2 - 1; 3 <= t4 && 0 === e4.bl_tree[2 * S2[t4] + 1]; t4--)
            ;
          return e4.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
        }(e3), i2 = e3.opt_len + 3 + 7 >>> 3, (s3 = e3.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s3)) : i2 = s3 = r3 + 5, r3 + 4 <= i2 && -1 !== t3 ? J2(e3, t3, r3, n3) : 4 === e3.strategy || s3 === i2 ? (P2(e3, 2 + (n3 ? 1 : 0), 3), K2(e3, z2, C2)) : (P2(e3, 4 + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
          var i3;
          for (P2(e4, t4 - 257, 5), P2(e4, r4 - 1, 5), P2(e4, n4 - 4, 4), i3 = 0; i3 < n4; i3++)
            P2(e4, e4.bl_tree[2 * S2[i3] + 1], 3);
          V2(e4, e4.dyn_ltree, t4 - 1), V2(e4, e4.dyn_dtree, r4 - 1);
        }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a3 + 1), K2(e3, e3.dyn_ltree, e3.dyn_dtree)), W2(e3), n3 && M2(e3);
      }, r2._tr_tally = function(e3, t3, r3) {
        return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t3 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t3, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r3, e3.last_lit++, 0 === t3 ? e3.dyn_ltree[2 * r3]++ : (e3.matches++, t3--, e3.dyn_ltree[2 * (A2[r3] + u2 + 1)]++, e3.dyn_dtree[2 * N2(t3)]++), e3.last_lit === e3.lit_bufsize - 1;
      }, r2._tr_align = function(e3) {
        P2(e3, 2, 3), L2(e3, m2, z2), function(e4) {
          16 === e4.bi_valid ? (U2(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
        }(e3);
      };
    }, { "../utils/common": 41 }], 53: [function(e2, t2, r2) {
      t2.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e2, t2, r2) {
      (function(e3) {
        !function(r3, n2) {
          if (!r3.setImmediate) {
            var i, s2, t3, a2, o2 = 1, h2 = {}, u2 = false, l2 = r3.document, e4 = Object.getPrototypeOf && Object.getPrototypeOf(r3);
            e4 = e4 && e4.setTimeout ? e4 : r3, i = "[object process]" === {}.toString.call(r3.process) ? function(e5) {
              process.nextTick(function() {
                c2(e5);
              });
            } : function() {
              if (r3.postMessage && !r3.importScripts) {
                var e5 = true, t4 = r3.onmessage;
                return r3.onmessage = function() {
                  e5 = false;
                }, r3.postMessage("", "*"), r3.onmessage = t4, e5;
              }
            }() ? (a2 = "setImmediate$" + Math.random() + "$", r3.addEventListener ? r3.addEventListener("message", d2, false) : r3.attachEvent("onmessage", d2), function(e5) {
              r3.postMessage(a2 + e5, "*");
            }) : r3.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e5) {
              c2(e5.data);
            }, function(e5) {
              t3.port2.postMessage(e5);
            }) : l2 && "onreadystatechange" in l2.createElement("script") ? (s2 = l2.documentElement, function(e5) {
              var t4 = l2.createElement("script");
              t4.onreadystatechange = function() {
                c2(e5), t4.onreadystatechange = null, s2.removeChild(t4), t4 = null;
              }, s2.appendChild(t4);
            }) : function(e5) {
              setTimeout(c2, 0, e5);
            }, e4.setImmediate = function(e5) {
              "function" != typeof e5 && (e5 = new Function("" + e5));
              for (var t4 = new Array(arguments.length - 1), r4 = 0; r4 < t4.length; r4++)
                t4[r4] = arguments[r4 + 1];
              var n3 = { callback: e5, args: t4 };
              return h2[o2] = n3, i(o2), o2++;
            }, e4.clearImmediate = f2;
          }
          function f2(e5) {
            delete h2[e5];
          }
          function c2(e5) {
            if (u2)
              setTimeout(c2, 0, e5);
            else {
              var t4 = h2[e5];
              if (t4) {
                u2 = true;
                try {
                  !function(e6) {
                    var t5 = e6.callback, r4 = e6.args;
                    switch (r4.length) {
                      case 0:
                        t5();
                        break;
                      case 1:
                        t5(r4[0]);
                        break;
                      case 2:
                        t5(r4[0], r4[1]);
                        break;
                      case 3:
                        t5(r4[0], r4[1], r4[2]);
                        break;
                      default:
                        t5.apply(n2, r4);
                    }
                  }(t4);
                } finally {
                  f2(e5), u2 = false;
                }
              }
            }
          }
          function d2(e5) {
            e5.source === r3 && "string" == typeof e5.data && 0 === e5.data.indexOf(a2) && c2(+e5.data.slice(a2.length));
          }
        }("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
const e = (() => {
  if ("undefined" == typeof self)
    return false;
  return "showOpenFilePicker" in self;
})(), t = e ? Promise.resolve().then(function() {
  return l;
}) : Promise.resolve().then(function() {
  return v;
});
async function n(...e2) {
  return (await t).default(...e2);
}
e ? Promise.resolve().then(function() {
  return y;
}) : Promise.resolve().then(function() {
  return b;
});
const a = e ? Promise.resolve().then(function() {
  return m;
}) : Promise.resolve().then(function() {
  return k;
});
async function o(...e2) {
  return (await a).default(...e2);
}
const s = async (e2) => {
  const t2 = await e2.getFile();
  return t2.handle = e2, t2;
};
var c = async (e2 = [{}]) => {
  Array.isArray(e2) || (e2 = [e2]);
  const t2 = [];
  e2.forEach((e3, n3) => {
    t2[n3] = { description: e3.description || "Files", accept: {} }, e3.mimeTypes ? e3.mimeTypes.map((r3) => {
      t2[n3].accept[r3] = e3.extensions || [];
    }) : t2[n3].accept["*/*"] = e3.extensions || [];
  });
  const n2 = await window.showOpenFilePicker({ id: e2[0].id, startIn: e2[0].startIn, types: t2, multiple: e2[0].multiple || false, excludeAcceptAllOption: e2[0].excludeAcceptAllOption || false }), r2 = await Promise.all(n2.map(s));
  return e2[0].multiple ? r2 : r2[0];
}, l = { __proto__: null, default: c };
function u(e2) {
  function t2(e3) {
    if (Object(e3) !== e3)
      return Promise.reject(new TypeError(e3 + " is not an object."));
    var t3 = e3.done;
    return Promise.resolve(e3.value).then(function(e4) {
      return { value: e4, done: t3 };
    });
  }
  return u = function(e3) {
    this.s = e3, this.n = e3.next;
  }, u.prototype = { s: null, n: null, next: function() {
    return t2(this.n.apply(this.s, arguments));
  }, return: function(e3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.resolve({ value: e3, done: true }) : t2(n2.apply(this.s, arguments));
  }, throw: function(e3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.reject(e3) : t2(n2.apply(this.s, arguments));
  } }, new u(e2);
}
const p = async (e2, t2, n2 = e2.name, r2) => {
  const i = [], a2 = [];
  var o2, s2 = false, c2 = false;
  try {
    for (var l2, d2 = function(e3) {
      var t3, n3, r3, i2 = 2;
      for ("undefined" != typeof Symbol && (n3 = Symbol.asyncIterator, r3 = Symbol.iterator); i2--; ) {
        if (n3 && null != (t3 = e3[n3]))
          return t3.call(e3);
        if (r3 && null != (t3 = e3[r3]))
          return new u(t3.call(e3));
        n3 = "@@asyncIterator", r3 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }(e2.values()); s2 = !(l2 = await d2.next()).done; s2 = false) {
      const o3 = l2.value, s3 = `${n2}/${o3.name}`;
      "file" === o3.kind ? a2.push(o3.getFile().then((t3) => (t3.directoryHandle = e2, t3.handle = o3, Object.defineProperty(t3, "webkitRelativePath", { configurable: true, enumerable: true, get: () => s3 })))) : "directory" !== o3.kind || !t2 || r2 && r2(o3) || i.push(p(o3, t2, s3, r2));
    }
  } catch (e3) {
    c2 = true, o2 = e3;
  } finally {
    try {
      s2 && null != d2.return && await d2.return();
    } finally {
      if (c2)
        throw o2;
    }
  }
  return [...(await Promise.all(i)).flat(), ...await Promise.all(a2)];
};
var d = async (e2 = {}) => {
  e2.recursive = e2.recursive || false, e2.mode = e2.mode || "read";
  const t2 = await window.showDirectoryPicker({ id: e2.id, startIn: e2.startIn, mode: e2.mode });
  return (await (await t2.values()).next()).done ? [t2] : p(t2, e2.recursive, void 0, e2.skipDirectory);
}, y = { __proto__: null, default: d }, f = async (e2, t2 = [{}], n2 = null, r2 = false, i = null) => {
  Array.isArray(t2) || (t2 = [t2]), t2[0].fileName = t2[0].fileName || "Untitled";
  const a2 = [];
  let o2 = null;
  if (e2 instanceof Blob && e2.type ? o2 = e2.type : e2.headers && e2.headers.get("content-type") && (o2 = e2.headers.get("content-type")), t2.forEach((e3, t3) => {
    a2[t3] = { description: e3.description || "Files", accept: {} }, e3.mimeTypes ? (0 === t3 && o2 && e3.mimeTypes.push(o2), e3.mimeTypes.map((n3) => {
      a2[t3].accept[n3] = e3.extensions || [];
    })) : o2 ? a2[t3].accept[o2] = e3.extensions || [] : a2[t3].accept["*/*"] = e3.extensions || [];
  }), n2)
    try {
      await n2.getFile();
    } catch (e3) {
      if (n2 = null, r2)
        throw e3;
    }
  const s2 = n2 || await window.showSaveFilePicker({ suggestedName: t2[0].fileName, id: t2[0].id, startIn: t2[0].startIn, types: a2, excludeAcceptAllOption: t2[0].excludeAcceptAllOption || false });
  !n2 && i && i(s2);
  const c2 = await s2.createWritable();
  if ("stream" in e2) {
    const t3 = e2.stream();
    return await t3.pipeTo(c2), s2;
  }
  return "body" in e2 ? (await e2.body.pipeTo(c2), s2) : (await c2.write(await e2), await c2.close(), s2);
}, m = { __proto__: null, default: f }, w = async (e2 = [{}]) => (Array.isArray(e2) || (e2 = [e2]), new Promise((t2, n2) => {
  const r2 = document.createElement("input");
  r2.type = "file";
  const i = [...e2.map((e3) => e3.mimeTypes || []), ...e2.map((e3) => e3.extensions || [])].join();
  r2.multiple = e2[0].multiple || false, r2.accept = i || "", r2.style.display = "none", document.body.append(r2);
  const a2 = (e3) => {
    "function" == typeof o2 && o2(), t2(e3);
  }, o2 = e2[0].legacySetup && e2[0].legacySetup(a2, () => o2(n2), r2), s2 = () => {
    window.removeEventListener("focus", s2), r2.remove();
  };
  r2.addEventListener("click", () => {
    window.addEventListener("focus", s2);
  }), r2.addEventListener("change", () => {
    window.removeEventListener("focus", s2), r2.remove(), a2(r2.multiple ? Array.from(r2.files) : r2.files[0]);
  }), "showPicker" in HTMLInputElement.prototype ? r2.showPicker() : r2.click();
})), v = { __proto__: null, default: w }, h = async (e2 = [{}]) => (Array.isArray(e2) || (e2 = [e2]), e2[0].recursive = e2[0].recursive || false, new Promise((t2, n2) => {
  const r2 = document.createElement("input");
  r2.type = "file", r2.webkitdirectory = true;
  const i = (e3) => {
    "function" == typeof a2 && a2(), t2(e3);
  }, a2 = e2[0].legacySetup && e2[0].legacySetup(i, () => a2(n2), r2);
  r2.addEventListener("change", () => {
    let t3 = Array.from(r2.files);
    e2[0].recursive ? e2[0].recursive && e2[0].skipDirectory && (t3 = t3.filter((t4) => t4.webkitRelativePath.split("/").every((t5) => !e2[0].skipDirectory({ name: t5, kind: "directory" })))) : t3 = t3.filter((e3) => 2 === e3.webkitRelativePath.split("/").length), i(t3);
  }), "showPicker" in HTMLInputElement.prototype ? r2.showPicker() : r2.click();
})), b = { __proto__: null, default: h }, P = async (e2, t2 = {}) => {
  Array.isArray(t2) && (t2 = t2[0]);
  const n2 = document.createElement("a");
  let r2 = e2;
  "body" in e2 && (r2 = await async function(e3, t3) {
    const n3 = e3.getReader(), r3 = new ReadableStream({ start: (e4) => async function t4() {
      return n3.read().then(({ done: n4, value: r4 }) => {
        if (!n4)
          return e4.enqueue(r4), t4();
        e4.close();
      });
    }() }), i2 = new Response(r3), a3 = await i2.blob();
    return n3.releaseLock(), new Blob([a3], { type: t3 });
  }(e2.body, e2.headers.get("content-type"))), n2.download = t2.fileName || "Untitled", n2.href = URL.createObjectURL(await r2);
  const i = () => {
    "function" == typeof a2 && a2();
  }, a2 = t2.legacySetup && t2.legacySetup(i, () => a2(), n2);
  return n2.addEventListener("click", () => {
    setTimeout(() => URL.revokeObjectURL(n2.href), 3e4), i();
  }), n2.click(), null;
}, k = { __proto__: null, default: P };
const jeepSqliteCss = ":host{display:block;--jeep-sqlite-top:10%;--jeep-sqlite-right:1%;--jeep-sqlite-font-size:2em;--jeep-sqlite-padding:2%;--jeep-sqlite-background-color:#a9a9a9;--jeep-sqlite-color:#ffffff}#fileElem{display:none}#pickButton{position:absolute;top:var(--jeep-sqlite-top);right:var(--jeep-sqlite-right);font-size:var(--jeep-sqlite-font-size);padding:var(--jeep-sqlite-padding);background-color:var(--jeep-sqlite-background-color);color:var(--jeep-sqlite-color)}#saveButton{position:absolute;top:var(--jeep-sqlite-top);right:var(--jeep-sqlite-right);font-size:var(--jeep-sqlite-font-size);padding:var(--jeep-sqlite-padding);background-color:var(--jeep-sqlite-background-color);color:var(--jeep-sqlite-color)}";
const JeepSqliteStyle0 = jeepSqliteCss;
const JeepSqlite$1 = /* @__PURE__ */ proxyCustomElement(class JeepSqlite extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.importProgress = createEvent(this, "jeepSqliteImportProgress", 7);
    this.exportProgress = createEvent(this, "jeepSqliteExportProgress", 7);
    this.HTTPRequestEnded = createEvent(this, "jeepSqliteHTTPRequestEnded", 7);
    this.PickDatabaseEnded = createEvent(this, "jeepSqlitePickDatabaseEnded", 7);
    this.SaveDatabaseEnded = createEvent(this, "jeepSqliteSaveDatabaseToDisk", 7);
    this.isStore = false;
    this._dbDict = {};
    this.databaseList = {};
    this._versionUpgrades = {};
    this._overwrite = true;
    this.autoSave = false;
    this.typeOrm = false;
    this.wasmPath = void 0;
    this.pickText = void 0;
    this.saveText = void 0;
    this.buttonOptions = void 0;
    this.innerAutoSave = void 0;
    this.innerTypeOrm = void 0;
    this.innerWasmPath = void 0;
    this.innerPickText = void 0;
    this.innerSaveText = void 0;
    this.innerButtonOptions = void 0;
  }
  //*****************************
  //* Watch on Property Changes *
  //*****************************
  parseAutoSave(newValue) {
    this.innerAutoSave = newValue;
  }
  parseTypeOrm(newValue) {
    this.innerTypeOrm = newValue;
  }
  parseWasmPath(newValue) {
    this.innerWasmPath = newValue;
  }
  parsePickText(newValue) {
    this.innerPickText = newValue;
  }
  parseSaveText(newValue) {
    this.innerSaveText = newValue;
  }
  parseButtonOptions(newValue) {
    this.innerButtonOptions = JSON.parse(newValue);
    const keys = Object.keys(this.innerButtonOptions);
    for (const key of keys) {
      switch (key) {
        case "top": {
          this.el.style.setProperty("--jeep-sqlite-top", this.innerButtonOptions[key]);
          break;
        }
        case "right": {
          this.el.style.setProperty("--jeep-sqlite-right", this.innerButtonOptions[key]);
          break;
        }
        case "fontSize": {
          this.el.style.setProperty("--jeep-sqlite-font-size", this.innerButtonOptions[key]);
          break;
        }
        case "padding": {
          this.el.style.setProperty("--jeep-sqlite-padding", this.innerButtonOptions[key]);
          break;
        }
        case "backgroundColor": {
          this.el.style.setProperty("--jeep-sqlite-background-color", this.innerButtonOptions[key]);
          break;
        }
        case "color": {
          this.el.style.setProperty("--jeep-sqlite-color", this.innerButtonOptions[key]);
          break;
        }
      }
    }
  }
  //**********************
  //* Method Definitions *
  //**********************
  async echo(options) {
    return options;
  }
  async createConnection(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const version2 = options.version ? options.version : 1;
    const readonly = options.readonly ? options.readonly : false;
    try {
      await this._createConnection(dbName, version2, readonly);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isConnection(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    const ret = await this._isConnection(dbName, readonly);
    return Promise.resolve(ret);
  }
  async closeConnection(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      await this._closeConnection(dbName, readonly);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async open(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      await this._open(dbName, readonly);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async close(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      await this._close(dbName, readonly);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getVersion(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const res = await this._getVersion(dbName, readonly);
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async beginTransaction(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    if (readonly) {
      return Promise.reject(`BeginTransaction: not allowed in read-only mode`);
    }
    try {
      const changes = await this._beginTransaction(dbName);
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async commitTransaction(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    if (readonly) {
      return Promise.reject(`CommitTransaction: not allowed in read-only mode`);
    }
    try {
      const changes = await this._commitTransaction(dbName);
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async rollbackTransaction(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    if (readonly) {
      return Promise.reject(`BeginTransaction: not allowed in read-only mode`);
    }
    try {
      const changes = await this._rollbackTransaction(dbName);
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isTransactionActive(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    if (readonly) {
      return Promise.reject(`isTransactionActive: not allowed in read-only mode`);
    }
    try {
      const res = await this._isTransactionActive(dbName);
      return Promise.resolve(res);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async execute(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    if (!keys.includes("statements") || options.statements.length === 0) {
      return Promise.reject("Must provide raw SQL statements");
    }
    const dbName = options.database;
    const statements = options.statements;
    let transaction = true;
    const readonly = options.readonly ? options.readonly : false;
    if (keys.includes("transaction"))
      transaction = options.transaction;
    try {
      const changes = await this._execute(dbName, statements, transaction, readonly);
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async executeSet(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    if (!keys.includes("set") || options.set.length === 0) {
      return Promise.reject("Must provide a non-empty set of SQL statements");
    }
    const dbName = options.database;
    const setOfStatements = options.set;
    let transaction = true;
    if (keys.includes("transaction"))
      transaction = options.transaction;
    const readonly = options.readonly ? options.readonly : false;
    const returnMode = options.returnMode ? options.returnMode : "no";
    try {
      const changes = await this._executeSet(dbName, setOfStatements, transaction, readonly, returnMode);
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async run(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    if (!keys.includes("statement") || options.statement.length === 0) {
      return Promise.reject("Must provide a run statement");
    }
    const dbName = options.database;
    const statement = options.statement;
    let values = [];
    if (keys.includes("values")) {
      values = options.values.length > 0 ? options.values : [];
    }
    let transaction = true;
    if (keys.includes("transaction"))
      transaction = options.transaction;
    const readonly = options.readonly ? options.readonly : false;
    const returnMode = options.returnMode ? options.returnMode : "no";
    try {
      const retChanges = await this._run(dbName, statement, values, transaction, readonly, returnMode);
      return Promise.resolve(retChanges);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async query(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    if (!keys.includes("statement") || options.statement.length === 0) {
      return Promise.reject("Must provide a query statement");
    }
    let values = [];
    if (keys.includes("values")) {
      values = options.values.length > 0 ? options.values : [];
    }
    const dbName = options.database;
    const statement = options.statement;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const retValues = await this._query(dbName, statement, values, readonly);
      return Promise.resolve(retValues);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getTableList(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const retValues = await this._getTableList(dbName, readonly);
      return Promise.resolve(retValues);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isDBExists(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const ret = await this._isDBExists(dbName, readonly);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isDBOpen(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const ret = await this._isDBOpen(dbName, readonly);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async deleteDatabase(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      return await this._deleteDatabase(dbName, readonly);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isStoreOpen() {
    return Promise.resolve(this.isStore);
  }
  async copyFromAssets(options) {
    let overwrite;
    if (options != null) {
      const keys = Object.keys(options);
      overwrite = keys.includes("overwrite") ? options.overwrite : true;
    } else {
      overwrite = true;
    }
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    try {
      await this._copyFromAssets(overwrite);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isTableExists(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    if (!keys.includes("table")) {
      return Promise.reject("Must provide a table name");
    }
    const tableName = options.table;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const ret = await this._isTableExists(dbName, tableName, readonly);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async createSyncTable(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const ret = await this._createSyncTable(dbName, readonly);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getSyncDate(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const ret = await this._getSyncDate(dbName, readonly);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async setSyncDate(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    if (!keys.includes("syncdate")) {
      return Promise.reject("Must provide a synchronization date");
    }
    const dbName = options.database;
    const syncDate = options.syncdate;
    const readonly = options.readonly ? options.readonly : false;
    try {
      await this._setSyncDate(dbName, syncDate, readonly);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async isJsonValid(options) {
    const keys = Object.keys(options);
    if (!keys.includes("jsonstring")) {
      return Promise.reject("Must provide a json object");
    }
    const jsonStrObj = options.jsonstring;
    try {
      const ret = await this._isJsonValid(jsonStrObj);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async importFromJson(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("jsonstring")) {
      return Promise.reject("Must provide a json object");
    }
    const jsonStrObj = options.jsonstring;
    try {
      const ret = await this._importFromJson(jsonStrObj);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async exportToJson(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    if (!keys.includes("jsonexportmode")) {
      return Promise.reject("Must provide a json export mode");
    }
    const dbName = options.database;
    const exportMode = options.jsonexportmode;
    const readonly = options.readonly ? options.readonly : false;
    try {
      const ret = await this._exportToJson(dbName, exportMode, readonly);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async deleteExportedRows(options) {
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      await this._deleteExportedRows(dbName, readonly);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async addUpgradeStatement(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    if (!keys.includes("upgrade")) {
      return Promise.reject("Must provide an upgrade capSQLiteVersionUpgrade Object");
    }
    const dbName = options.database;
    const upgrades = options.upgrade;
    for (const upgrade of upgrades) {
      const versionUpgradeKeys = Object.keys(upgrade);
      if (!versionUpgradeKeys.includes("toVersion") || !versionUpgradeKeys.includes("statements")) {
        return Promise.reject("Must provide an upgrade capSQLiteVersionUpgrade Object");
      }
      if (typeof upgrade.toVersion != "number") {
        return Promise.reject("upgrade.toVersion must be a number");
      }
      if (this._versionUpgrades[dbName]) {
        this._versionUpgrades[dbName][upgrade.toVersion] = upgrade;
      } else {
        const upgVDict = {};
        upgVDict[upgrade.toVersion] = upgrade;
        this._versionUpgrades[dbName] = upgVDict;
      }
    }
    return Promise.resolve();
  }
  async isDatabase(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    try {
      const ret = await this._isDatabase(dbName);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getDatabaseList() {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    try {
      const ret = await this._getDatabaseList();
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async checkConnectionsConsistency(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("dbNames")) {
      return Promise.reject(`Must provide a list of connection's name`);
    }
    const dbNames = options.dbNames;
    if (!keys.includes("openModes")) {
      return Promise.reject(`Must provide a list of connection's open mode`);
    }
    const openModes = options.openModes;
    try {
      const ret = await this._checkConnectionsConsistency(dbNames, openModes);
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async saveToStore(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    const readonly = options.readonly ? options.readonly : false;
    try {
      await this._saveToStore(dbName, readonly);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async saveToLocalDisk(options) {
    const keys = Object.keys(options);
    if (!keys.includes("database")) {
      return Promise.reject("Must provide a database name");
    }
    const dbName = options.database;
    try {
      await this._saveToLocalDisk(dbName);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getFromLocalDiskToStore(options) {
    const overwrite = options.overwrite ? options.overwrite : true;
    if (e) {
      console.log("Using the File System Access API.");
    } else {
      console.log("Using the fallback implementation.");
    }
    try {
      await this._getFromLocalDiskToStore(overwrite);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  async getFromHTTPRequest(options) {
    if (!this.isStore) {
      return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
    }
    let keys = Object.keys(options);
    if (!keys.includes("url")) {
      return Promise.reject("Must provide an url");
    }
    const url = options.url;
    const overwrite = options.overwrite ? options.overwrite : true;
    try {
      await this._getFromHTTPRequest(url, overwrite);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  }
  //*******************************
  //* Component Lifecycle Methods *
  //*******************************
  connectedCallback() {
    this.parseAutoSave(this.autoSave !== void 0 ? this.autoSave : false);
    this.parseTypeOrm(this.typeOrm !== void 0 ? this.typeOrm : false);
    this.parseWasmPath(this.wasmPath !== void 0 ? this.wasmPath : "/assets");
    this.parseSaveText(this.saveText !== void 0 ? this.saveText : "Save");
    this.parsePickText(this.pickText !== void 0 ? this.pickText : "Pick a database");
    if (this.buttonOptions !== void 0) {
      this.parseButtonOptions(this.buttonOptions);
    }
    this.openStore("jeepSqliteStore", "databases").then((mStore) => {
      this.isStore = mStore;
    });
  }
  componentWillLoad() {
  }
  async componentDidLoad() {
    this._element = this.el.shadowRoot;
    if (!this.isStore) {
      console.log("jeep-sqlite isStore = false");
    }
  }
  //******************************
  //* Private Method Definitions *
  //******************************
  async _createConnection(database, version2, readonly) {
    let upgDict = {};
    const vUpgKeys = Object.keys(this._versionUpgrades);
    if (vUpgKeys.length !== 0 && vUpgKeys.includes(database)) {
      upgDict = this._versionUpgrades[database];
    }
    const dbDictKeys = Object.keys(this._dbDict);
    let mDB;
    try {
      if (dbDictKeys.length > 0 && (dbDictKeys.includes("RW_" + database) || dbDictKeys.includes("RO_" + database))) {
        mDB = dbDictKeys.includes("RW_" + database) ? this._dbDict["RW_" + database] : this._dbDict["RO_" + database];
      } else {
        mDB = new Database(database + "SQLite.db", version2, upgDict, this.store, this.innerAutoSave, this.innerWasmPath);
      }
      const connName = readonly ? "RO_" + database : "RW_" + database;
      this._dbDict[connName] = mDB;
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err.message);
    }
  }
  async _isConnection(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (keys.includes(connName)) {
      return { result: true };
    } else {
      return { result: false };
    }
  }
  async _closeConnection(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`CloseConnection: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      if (mDB.isDBOpen()) {
        try {
          await mDB.close();
        } catch (err) {
          return Promise.reject(`CloseConnection: close ${database} failed ${err}`);
        }
      }
      delete this._dbDict[connName];
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`CloseConnection: ${err.message}`);
    }
  }
  async _open(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`Open: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      await mDB.open();
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`Open: ${err.message}`);
    }
  }
  async _close(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`Close: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      await mDB.close();
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`Close: ${err.message}`);
    }
  }
  async _saveToStore(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`SaveToStore: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      await mDB.saveToStore();
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`SaveToStore: ${err.message}`);
    }
  }
  async _saveToLocalDisk(database) {
    try {
      const keys = Object.keys(this._dbDict);
      const connName = "RW_" + database;
      if (!keys.includes(connName)) {
        return Promise.reject(`_saveToLocalDisk: No available connection for ${database}`);
      }
      const mDb = this._dbDict[connName];
      const uint = await mDb.exportDB();
      this._blob = await this.uint2blob(uint);
      const dbName = `${database}SQLite.db`;
      this._opts = { fileName: dbName, extensions: [".db"] };
      this._buttonSaveEl = document.createElement("button");
      this._buttonSaveEl.setAttribute("id", "saveButton");
      this._buttonSaveEl.innerHTML = `${this.innerSaveText} ${dbName}`;
      this._element.appendChild(this._buttonSaveEl);
      this._buttonSaveEl.addEventListener("click", this.saveFile.bind(this));
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`_saveToLocalDisk: ${err.message}`);
    }
  }
  async _getFromLocalDiskToStore(overwrite) {
    this._buttonPickEl = document.createElement("button");
    this._buttonPickEl.setAttribute("id", "pickButton");
    this._buttonPickEl.innerHTML = `${this.innerPickText}`;
    this._element.appendChild(this._buttonPickEl);
    this._buttonPickEl.addEventListener("click", this.pickDatabase.bind(this));
    this._overwrite = overwrite;
    return Promise.resolve();
  }
  async pickDatabase() {
    try {
      const blob = await n({ extensions: [".db"] });
      let uInt8Array = await this.blob2uint(blob);
      const databaseName = this.removePathSuffix(blob.name);
      const dbName = this.setPathSuffix(blob.name);
      const isExist = await UtilsStore.isDBInStore(dbName, this.store);
      if (!isExist) {
        await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
      } else {
        if (this._overwrite) {
          await UtilsStore.removeDBFromStore(dbName, this.store);
          await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
        } else {
          this.PickDatabaseEnded.emit({ message: `Error: cannot overwrite ${dbName}` });
        }
      }
      this._element.removeChild(this._buttonPickEl);
      this.PickDatabaseEnded.emit({ db_name: databaseName });
    } catch (err) {
      const msg = err.message ? err.message : err;
      this.PickDatabaseEnded.emit({ message: msg });
    }
  }
  async saveFile() {
    try {
      await o(this._blob, [this._opts]);
      const databaseName = this._opts.fileName;
      this._element.removeChild(this._buttonSaveEl);
      this.SaveDatabaseEnded.emit({ db_name: databaseName });
    } catch (err) {
      const msg = err.message ? err.message : err;
      this.SaveDatabaseEnded.emit({ message: msg });
    }
  }
  async _getVersion(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`Open: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      const version2 = await mDB.getVersion();
      const ret = {};
      ret.version = version2;
      return Promise.resolve(ret);
    } catch (err) {
      return Promise.reject(`Open: ${err.message}`);
    }
  }
  async _beginTransaction(database) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`BeginTransaction: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    let changes = {};
    const ret = await mDB.beginTransaction();
    changes = { changes: { changes: ret } };
    return Promise.resolve(changes);
  }
  async _commitTransaction(database) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`CommitTransaction: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    let changes = {};
    const ret = await mDB.commitTransaction();
    changes = { changes: { changes: ret } };
    return Promise.resolve(changes);
  }
  async _rollbackTransaction(database) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`RollbackTransaction: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    let changes = {};
    const ret = await mDB.rollbackTransaction();
    changes = { changes: { changes: ret } };
    return Promise.resolve(changes);
  }
  async _isTransactionActive(database) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`IsTransactionActive: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    let result = {};
    const res = mDB.isTransActive();
    result = { result: res };
    return Promise.resolve(result);
  }
  async _execute(database, statements, transaction, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`Execute: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    if (readonly) {
      return Promise.reject(`Execute: not allowed in read-only mode`);
    }
    let changes = {};
    const command = statements.substring(0, 6);
    if (this.innerAutoSave && command === "COMMIT" && this.innerTypeOrm) {
      changes = { changes: { changes: 0 } };
      return Promise.resolve(changes);
    }
    try {
      const ret = await mDB.executeSQL(statements, transaction);
      changes = { changes: { changes: ret } };
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(`Execute: ${err.message}`);
    }
  }
  async _executeSet(database, setOfStatements, transaction, readonly, returnMode) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`ExecuteSet: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    if (readonly) {
      return Promise.reject(`ExecuteSet: not allowed in read-only mode`);
    }
    for (const sStmt of setOfStatements) {
      if (!("statement" in sStmt) || !("values" in sStmt)) {
        return Promise.reject("ExecuteSet: Must provide a set as Array of {statement,values}");
      }
    }
    try {
      const ret = await mDB.execSet(setOfStatements, transaction, returnMode);
      const changes = { changes: {
        changes: ret.changes,
        lastId: ret.lastId,
        values: ret.values
      } };
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(`ExecuteSet: ${err.message}`);
    }
  }
  async _run(database, statement, values, transaction, readonly, returnMode) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`Run: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    if (readonly) {
      return Promise.reject(`Run: not allowed in read-only mode`);
    }
    let changes = {};
    const command = statement.substring(0, 6);
    if (this.innerAutoSave && command === "COMMIT") {
      changes = { changes: { changes: 0 } };
      return Promise.resolve(changes);
    }
    try {
      const ret = await mDB.runSQL(statement, values, transaction, returnMode);
      changes = { changes: { changes: ret.changes, lastId: ret.lastId, values: ret.values } };
      return Promise.resolve(changes);
    } catch (err) {
      return Promise.reject(`Run: ${err.message}`);
    }
  }
  async _query(database, statement, values, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`Query: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    let ret = [];
    const command = statement.substring(0, 6);
    if (this.innerAutoSave && command === "COMMIT") {
      return Promise.resolve({ values: ret });
    }
    try {
      ret = await mDB.selectSQL(statement, values);
      return Promise.resolve({ values: ret });
    } catch (err) {
      return Promise.reject(`Query failed: ${err.message}`);
    }
  }
  async _getTableList(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`GetTableList: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    let ret = [];
    try {
      ret = await mDB.getTableNames();
      return Promise.resolve({ values: ret });
    } catch (err) {
      return Promise.reject(`GetTableList failed: ${err.message}`);
    }
  }
  async _isDBExists(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`IsDBExists: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      const ret = await mDB.isDBExists(database + "SQLite.db");
      const result = { result: ret };
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(`IsDBExists: ${err.message}`);
    }
  }
  async _isDBOpen(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`IsDBOpen: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      const ret = await mDB.isDBOpen(database + "SQLite.db");
      const result = { result: ret };
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(`IsDBOpen: ${err.message}`);
    }
  }
  async _deleteDatabase(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`DeleteDatabase: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    if (readonly) {
      return Promise.reject(`DeleteDatabase: not allowed in read-only mode`);
    }
    try {
      await mDB.deleteDB(database + "SQLite.db");
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`DeleteDatabase: ${err.message}`);
    }
  }
  async _isTableExists(database, table, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`IsTableExists: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      const ret = await mDB.isTable(table);
      const result = { result: ret };
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(`IsTableExists: ${err.message}`);
    }
  }
  async _createSyncTable(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`CreateSyncTable: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    if (readonly) {
      return Promise.reject(`CreateSyncTable: not allowed in read-only mode`);
    }
    try {
      const ret = await mDB.createSyncTable();
      return Promise.resolve({ changes: { changes: ret } });
    } catch (err) {
      return Promise.reject(`CreateSyncTable: ${err.message}`);
    }
  }
  async _getSyncDate(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`GetSyncDate: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    try {
      const ret = await mDB.getSyncDate();
      return Promise.resolve({ syncDate: ret });
    } catch (err) {
      return Promise.reject(`GetSyncDate: ${err.message}`);
    }
  }
  async _setSyncDate(database, syncDate, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`SetSyncDate: No available connection for ${database}`);
    }
    const mDB = this._dbDict[connName];
    if (readonly) {
      return Promise.reject(`SetSyncDate: not allowed in read-only mode`);
    }
    try {
      const ret = await mDB.setSyncDate(syncDate);
      if (ret.result) {
        return Promise.resolve();
      } else {
        return Promise.reject(`SetSyncDate: ${ret.message}`);
      }
    } catch (err) {
      return Promise.reject(`SetSyncDate: ${err.message}`);
    }
  }
  async _isJsonValid(jsonStrObj) {
    const jsonObj = JSON.parse(jsonStrObj);
    const isValid2 = await UtilsJSON.isJsonSQLite(jsonObj);
    if (!isValid2) {
      return Promise.reject("IsJsonValid: Stringify Json Object not Valid");
    } else {
      return Promise.resolve({ result: true });
    }
  }
  async _importFromJson(jsonStrObj) {
    var _a, _b;
    const jsonObj = JSON.parse(jsonStrObj);
    const isValid2 = await UtilsJSON.isJsonSQLite(jsonObj);
    if (!isValid2) {
      return Promise.reject("ImportFromJson: Stringify Json Object not Valid");
    }
    const vJsonObj = jsonObj;
    const dbName = `${vJsonObj.database}SQLite.db`;
    const dbVersion = (_a = vJsonObj.version) !== null && _a !== void 0 ? _a : 1;
    const mode = vJsonObj.mode;
    const overwrite = (_b = vJsonObj.overwrite) !== null && _b !== void 0 ? _b : false;
    const mDb = new Database(dbName, dbVersion, {}, this.store, this.innerAutoSave, this.innerWasmPath);
    try {
      if (overwrite && mode === "full") {
        const isExists = UtilsStore.isDBInStore(dbName, this.store);
        if (isExists) {
          await UtilsStore.removeDBFromStore(dbName, this.store);
        }
      }
      await mDb.open();
      const tableList = await mDb.getTableNames();
      if (mode === "full" && tableList.length > 0) {
        const curVersion = await mDb.getVersion();
        if (dbVersion < curVersion) {
          return Promise.reject(`ImportFromJson: Cannot import a version lower than ${curVersion}`);
        }
        if (curVersion === dbVersion) {
          return Promise.resolve({ changes: { changes: 0 } });
        }
      }
      const changes = await mDb.importJson(vJsonObj, this.importProgress);
      await mDb.close();
      return Promise.resolve({ changes: { changes } });
    } catch (err) {
      return Promise.reject(`ImportFromJson: ${err.message}`);
    }
  }
  async _exportToJson(database, exportMode, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = readonly ? "RO_" + database : "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`ExportToJson: No available connection for ${database}`);
    }
    const mDb = this._dbDict[connName];
    try {
      const ret = await mDb.exportJson(exportMode, this.exportProgress);
      const keys2 = Object.keys(ret);
      if (keys2.includes("message")) {
        return Promise.reject(`ExportToJson: ${ret.message}`);
      } else {
        return Promise.resolve({ export: ret });
      }
    } catch (err) {
      return Promise.reject(`ExportToJson: ${err.message}`);
    }
  }
  async _deleteExportedRows(database, readonly) {
    const keys = Object.keys(this._dbDict);
    const connName = "RW_" + database;
    if (!keys.includes(connName)) {
      return Promise.reject(`ExportToJson: No available connection for ${database}`);
    }
    const mDb = this._dbDict[connName];
    if (readonly) {
      return Promise.reject(`SetSyncDate: not allowed in read-only mode`);
    }
    try {
      await mDb.deleteExportedRows();
    } catch (err) {
      return Promise.reject(`DeleteExportedRows: ${err.message}`);
    }
  }
  async _copyFromAssets(overwrite) {
    const res = await this.loadJSON("/assets/databases/databases.json");
    if (res != null) {
      this.databaseList = JSON.parse(res);
      const keys = Object.keys(this.databaseList);
      if (keys.includes("databaseList")) {
        try {
          for (const dbName of this.databaseList.databaseList) {
            if (dbName.substring(dbName.length - 3) === ".db") {
              await this.copyDatabase(`/assets/databases/${dbName}`, overwrite);
            }
            if (dbName.substring(dbName.length - 4) === ".zip") {
              await this.unzipDatabase(`/assets/databases/${dbName}`, overwrite);
            }
          }
          return Promise.resolve();
        } catch (err) {
          return Promise.reject(`CopyFromAssets: ${err.message}`);
        }
      } else {
        return Promise.reject(`CopyFromAssets: no key databaseList in databases.json`);
      }
    } else {
      return Promise.reject(`CopyFromAssets: no databases.json file in /assets/databases folder`);
    }
  }
  async _getFromHTTPRequest(url, overwrite) {
    try {
      let message;
      if (url.substring(url.length - 3) === ".db") {
        await this.copyDatabase(url, overwrite);
        message = "db";
      }
      if (url.substring(url.length - 4) === ".zip") {
        await this.unzipDatabase(url, overwrite);
        message = "zip";
      }
      this.HTTPRequestEnded.emit({ message });
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(`GetFromHTTPRequest: ${err.message}`);
    }
  }
  async _isDatabase(database) {
    try {
      const ret = await UtilsStore.isDBInStore(database + "SQLite.db", this.store);
      const result = { result: ret };
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(`IsDatabase: ${err.message}`);
    }
  }
  async _getDatabaseList() {
    try {
      const ret = await UtilsStore.getDBListFromStore(this.store);
      const result = { values: ret };
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(`GetDatabaseList: ${err.message}`);
    }
  }
  async _checkConnectionsConsistency(dbNames, openModes) {
    const ret = {};
    ret.result = false;
    const dbConns = [];
    dbNames.forEach((value, i) => {
      dbConns.push(`${openModes[i]}_${value}`);
    });
    try {
      let inConnectionsSet = new Set(Object.keys(this._dbDict));
      const outConnectionSet = new Set(dbConns);
      if (outConnectionSet.size === 0) {
        await this._resetDbDict(Object.keys(this._dbDict));
        return Promise.resolve(ret);
      }
      if (inConnectionsSet.size < outConnectionSet.size) {
        await this._resetDbDict(Object.keys(this._dbDict));
        return Promise.resolve(ret);
      }
      if (inConnectionsSet.size > outConnectionSet.size) {
        const opt = {};
        for (const key of inConnectionsSet) {
          if (!Array.from(outConnectionSet.keys()).includes(key)) {
            let readonly = false;
            if (key.substring(0, 3) === "RO_") {
              readonly = true;
            }
            opt.database = key.substring(3);
            opt.readonly = readonly;
            await this._closeConnection(opt.database, opt.readonly);
          }
        }
      }
      inConnectionsSet = new Set(Object.keys(this._dbDict));
      if (inConnectionsSet.size === outConnectionSet.size) {
        const symDiffSet = await this.symmetricDifference(inConnectionsSet, outConnectionSet);
        if (symDiffSet.size === 0) {
          ret.result = true;
          return Promise.resolve(ret);
        } else {
          await this._resetDbDict(Object.keys(this._dbDict));
          return Promise.resolve(ret);
        }
      } else {
        await this._resetDbDict(Object.keys(this._dbDict));
        return Promise.resolve(ret);
      }
    } catch (err) {
      return Promise.reject(`CheckConnectionsConsistency: ${err.message}`);
    }
  }
  async _resetDbDict(keys) {
    try {
      for (const key of keys) {
        const opt = {};
        let readonly = false;
        if (key.substring(0, 3) === "RO_") {
          readonly = true;
        }
        opt.database = key.substring(3);
        opt.readonly = readonly;
        await this._closeConnection(opt.database, opt.readonly);
      }
    } catch (err) {
      return Promise.reject(`ResetDbDict: ${err.message}`);
    }
  }
  async symmetricDifference(setA, setB) {
    let _difference = /* @__PURE__ */ new Set();
    setA.forEach((element) => {
      _difference.add(element.substring(3));
    });
    let _compare = /* @__PURE__ */ new Set();
    setB.forEach((element) => {
      _compare.add(element.substring(3));
    });
    for (const elem of _compare) {
      if (_difference.has(elem)) {
        _difference.delete(elem);
      } else {
        _difference.add(elem);
      }
    }
    return _difference;
  }
  async unzipDatabase(dbZipName, overwrite) {
    return new Promise((resolve2, reject) => {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", dbZipName, true);
      xhr.responseType = "arraybuffer";
      xhr.onerror = () => {
        reject(new Error(`unzipDatabase: failed`));
      };
      xhr.onload = () => {
        jszip_min.exports.loadAsync(xhr.response).then(async (zip) => {
          const keys = Object.keys(zip.files);
          try {
            for (const filename of keys) {
              await this.retrieveDBFromZip(zip.files, filename, overwrite);
            }
            resolve2();
          } catch (err) {
            reject(new Error(`unzipDatabase Error: ${err.message}`));
          }
        });
      };
      xhr.send();
    });
  }
  async retrieveDBFromZip(zipFiles, fileName, overwrite) {
    return new Promise((resolve2, reject) => {
      zipFiles[fileName].async("nodebuffer").then(async (fileData) => {
        try {
          const uInt8Array = new Uint8Array(fileData);
          const dbName = this.setPathSuffix(fileName);
          const isExist = await UtilsStore.isDBInStore(dbName, this.store);
          if (!isExist) {
            await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
          } else {
            if (overwrite) {
              await UtilsStore.removeDBFromStore(dbName, this.store);
              await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
            } else {
              reject(new Error(`retrieveDBFromZip: cannot overwrite ${dbName}`));
            }
          }
          resolve2();
        } catch (err) {
          reject(new Error(`retrieveDBFromZip:: ${err.message}`));
        }
      });
    });
  }
  async copyDatabase(dbInName, overwrite) {
    return new Promise((resolve2, reject) => {
      var xhr = new XMLHttpRequest();
      var uInt8Array;
      xhr.open("GET", dbInName, true);
      xhr.responseType = "arraybuffer";
      xhr.onerror = () => {
        reject(new Error(`CopyDatabase: failed`));
      };
      xhr.onload = () => {
        uInt8Array = new Uint8Array(xhr.response);
      };
      xhr.onloadend = async () => {
        const dbName = this.setPathSuffix(dbInName);
        const isExist = await UtilsStore.isDBInStore(dbName, this.store);
        if (!isExist) {
          await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
        } else {
          if (overwrite) {
            await UtilsStore.removeDBFromStore(dbName, this.store);
            await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
          } else {
            reject(new Error(`CopyDatabase Error: cannot overwrite ${dbName}`));
          }
        }
        resolve2();
      };
      xhr.send();
    });
  }
  async loadJSON(jsonFileName) {
    return new Promise((resolve2, reject) => {
      var xobj = new XMLHttpRequest();
      xobj.overrideMimeType("application/json");
      xobj.open("GET", jsonFileName, true);
      xobj.onerror = () => {
        reject(new Error(`LoadJSON: failed`));
      };
      xobj.onreadystatechange = function() {
        if (xobj.status == 404)
          resolve2(null);
        if (xobj.readyState == 4 && xobj.status == 200) {
          resolve2(xobj.responseText);
        }
      };
      xobj.send(null);
    });
  }
  async openStore(dbName, tableName) {
    let ret = false;
    const config2 = this.setConfig(dbName, tableName);
    this.store = localForage.createInstance(config2);
    if (this.store != null) {
      this.storeName = dbName;
      ret = true;
    }
    return ret;
  }
  setConfig(dbName, tableName) {
    const config2 = {
      name: dbName,
      storeName: tableName,
      driver: [localForage.INDEXEDDB],
      version: 1
    };
    return config2;
  }
  removePathSuffix(db2) {
    return db2.includes("SQLite.db") ? db2.split("SQLite.db")[0] : db2.substring(db2.length - 3) === ".db" ? db2.slice(0, db2.lastIndexOf(".")) : db2;
  }
  setPathSuffix(db2) {
    let toDb = db2.slice(db2.lastIndexOf("/") + 1);
    const ext = ".db";
    if (db2.substring(db2.length - 3) === ext) {
      if (!db2.includes("SQLite.db")) {
        toDb = db2.slice(db2.lastIndexOf("/") + 1, -3) + "SQLite.db";
      }
    }
    return toDb;
  }
  async blob2uint(blob) {
    return new Response(blob).arrayBuffer().then((buffer) => {
      const uint = new Uint8Array(buffer);
      return uint;
    });
  }
  async uint2blob(uint) {
    const blob = new Blob([uint.buffer]);
    return Promise.resolve(blob);
  }
  render() {
    return;
  }
  static get assetsDirs() {
    return ["assets"];
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "autoSave": ["parseAutoSave"],
      "typeOrm": ["parseTypeOrm"],
      "wasmPath": ["parseWasmPath"],
      "pickText": ["parsePickText"],
      "saveText": ["parseSaveText"],
      "buttonOptions": ["parseButtonOptions"]
    };
  }
  static get style() {
    return JeepSqliteStyle0;
  }
}, [1, "jeep-sqlite", {
  "autoSave": [516, "autosave"],
  "typeOrm": [516, "typeorm"],
  "wasmPath": [513, "wasmpath"],
  "pickText": [513, "picktext"],
  "saveText": [513, "savetext"],
  "buttonOptions": [513, "buttonoptions"],
  "innerAutoSave": [32],
  "innerTypeOrm": [32],
  "innerWasmPath": [32],
  "innerPickText": [32],
  "innerSaveText": [32],
  "innerButtonOptions": [32],
  "echo": [64],
  "createConnection": [64],
  "isConnection": [64],
  "closeConnection": [64],
  "open": [64],
  "close": [64],
  "getVersion": [64],
  "beginTransaction": [64],
  "commitTransaction": [64],
  "rollbackTransaction": [64],
  "isTransactionActive": [64],
  "execute": [64],
  "executeSet": [64],
  "run": [64],
  "query": [64],
  "getTableList": [64],
  "isDBExists": [64],
  "isDBOpen": [64],
  "deleteDatabase": [64],
  "isStoreOpen": [64],
  "copyFromAssets": [64],
  "isTableExists": [64],
  "createSyncTable": [64],
  "getSyncDate": [64],
  "setSyncDate": [64],
  "isJsonValid": [64],
  "importFromJson": [64],
  "exportToJson": [64],
  "deleteExportedRows": [64],
  "addUpgradeStatement": [64],
  "isDatabase": [64],
  "getDatabaseList": [64],
  "checkConnectionsConsistency": [64],
  "saveToStore": [64],
  "saveToLocalDisk": [64],
  "getFromLocalDiskToStore": [64],
  "getFromHTTPRequest": [64]
}, void 0, {
  "autoSave": ["parseAutoSave"],
  "typeOrm": ["parseTypeOrm"],
  "wasmPath": ["parseWasmPath"],
  "pickText": ["parsePickText"],
  "saveText": ["parseSaveText"],
  "buttonOptions": ["parseButtonOptions"]
}]);
const JeepSqlite2 = JeepSqlite$1;
setupIonicReact();
window.addEventListener("DOMContentLoaded", async () => {
  try {
    const platform2 = Capacitor.getPlatform();
    if (platform2 === "web") {
      const sqlite = new SQLiteConnection(CapacitorSQLite);
      customElements.define("jeep-sqlite", JeepSqlite2);
      const jeepSqliteEl = document.createElement("jeep-sqlite");
      document.body.appendChild(jeepSqliteEl);
      await customElements.whenDefined("jeep-sqlite");
      await sqlite.initWebStore();
    }
    const root = client.createRoot(document.getElementById("root"));
    root.render(
      /* @__PURE__ */ React.createElement(Main, null)
    );
  } catch (e2) {
    console.log(e2);
  }
});
export {
  Keyboard as K,
  WebPlugin as W,
  clamp as a,
  componentOnReady as b,
  createGesture as c,
  doc as d,
  addEventListener$1 as e,
  findClosestIonContent as f,
  removeEventListener as g,
  KeyboardResize as h,
  isRTL$1 as i,
  win$1 as j,
  raf as k,
  getScrollElement as l,
  scrollByPoint as m,
  now$1 as n,
  createAnimation as o,
  pointerCoord as p,
  getIonPageElement as q,
  readTask as r,
  scrollToTop as s,
  writeTask as w
};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}